<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>「OOP」JML | 烟湮燕眼's Notes</title><meta name="keywords" content="OOP,JML"><meta name="author" content="烟湮燕眼"><meta name="copyright" content="烟湮燕眼"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="规格什么是规格对一个方法&#x2F;类&#x2F;程序的外部可感知行为的抽象表示  意义 规格把设计与实现有效分离 准确理解一个方法的行为，是多人协同开发时的交互基础 可以以逻辑方式来验证代码实现的正确性 作为开展测试设计的依据。我们不能只在黑盒层次开展测试，也需要对类、方法和接口进行测试  如何表示规格由许多研究，比如形式化语言。要表示规格，需要实现：  方法规格抽象 执行前对输入的要求—-前置条件(precond">
<meta property="og:type" content="article">
<meta property="og:title" content="「OOP」JML">
<meta property="og:url" content="http://yoursite.com/2021/05/25/ObjectOriented/%E3%80%8COO%E3%80%8D-JML/index.html">
<meta property="og:site_name" content="烟湮燕眼&#39;s Notes">
<meta property="og:description" content="规格什么是规格对一个方法&#x2F;类&#x2F;程序的外部可感知行为的抽象表示  意义 规格把设计与实现有效分离 准确理解一个方法的行为，是多人协同开发时的交互基础 可以以逻辑方式来验证代码实现的正确性 作为开展测试设计的依据。我们不能只在黑盒层次开展测试，也需要对类、方法和接口进行测试  如何表示规格由许多研究，比如形式化语言。要表示规格，需要实现：  方法规格抽象 执行前对输入的要求—-前置条件(precond">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/03/07/VZlJGrpcOBaUtdo.jpg">
<meta property="article:published_time" content="2021-05-25T11:18:06.000Z">
<meta property="article:modified_time" content="2021-05-30T11:59:36.059Z">
<meta property="article:author" content="烟湮燕眼">
<meta property="article:tag" content="OOP">
<meta property="article:tag" content="JML">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/03/07/VZlJGrpcOBaUtdo.jpg"><link rel="shortcut icon" href="/img/%E9%BB%84%E6%98%8F_1.jpg"><link rel="canonical" href="http://yoursite.com/2021/05/25/ObjectOriented/%E3%80%8COO%E3%80%8D-JML/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-05-30 19:59:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="烟湮燕眼's Notes" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/%E9%AD%94%E6%B3%95_1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">烟湮燕眼's Notes</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">「OOP」JML</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-25T11:18:06.000Z" title="发表于 2021-05-25 19:18:06">2021-05-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-30T11:59:36.059Z" title="更新于 2021-05-30 19:59:36">2021-05-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ObjectOriented/">ObjectOriented</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="「OOP」JML"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="规格"><a href="#规格" class="headerlink" title="规格"></a>规格</h1><h2 id="什么是规格"><a href="#什么是规格" class="headerlink" title="什么是规格"></a>什么是规格</h2><p>对一个方法/类/程序的外部<strong>可感知</strong>行为的抽象表示 </p>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><ul>
<li>规格把设计与实现有效分离</li>
<li>准确理解一个方法的行为，是多人协同开发时的交互基础</li>
<li>可以以逻辑方式来验证代码实现的正确性</li>
<li>作为开展测试设计的依据。我们不能只在黑盒层次开展测试，也需要对类、方法和接口进行测试</li>
</ul>
<h2 id="如何表示规格"><a href="#如何表示规格" class="headerlink" title="如何表示规格"></a>如何表示规格</h2><p>由许多研究，比如形式化语言。<br>要表示规格，需要实现：</p>
<ul>
<li>方法规格抽象<ul>
<li>执行前对输入的要求—-前置条件(precondition)</li>
<li>执行过程中对于环境(参数、所在this)的改变描述—-副作用(Side-Effects)</li>
<li>执行后返回结果应该满足的约束—-后置条件(postcondition)</li>
</ul>
</li>
<li>数据规格抽象(类型抽象)<ul>
<li>数据状态应该满足的要求—-不变式(invariant)</li>
<li>数据状态变化应该满足的要求—-约束(constraint)</li>
</ul>
</li>
</ul>
<h2 id="类型层次下的规格关系"><a href="#类型层次下的规格关系" class="headerlink" title="类型层次下的规格关系"></a>类型层次下的规格关系</h2><p>子类重写方法可以减弱父类方法规定的Requires,或者加强父类方法规定的Ensures</p>
<p>子类可以对父类进行扩充，但需要保持父类的规格仍然成立</p>
<p>LSP替换原则：在任何父类型对象出现的地方使用子类对象都不会破坏user程序的行为</p>
<h1 id="JML"><a href="#JML" class="headerlink" title="JML"></a>JML</h1><p>JML (Java Modeling Language) 是一种行为接口规格语言（Behavior Interface Specification Language，BISL），基于 Larch 方法构建。通过 JML 及其支持工具，不仅可以基于规格自动构造测试用例，并整合了 SMT Solver 等工具以静态方式来检查代码实现对规格的满足情况。</p>
<p>一般而言，JML 有两种主要的用法：</p>
<p>（1）开展规格化设计。这样交给代码实现人员的将不是可能带有内在模糊性的自然语言描述，而是逻辑严格的规格。</p>
<p>（2）针对已有的代码实现，书写其对应的规格，从而提高代码的可维护性。这在遗留代码的维护方面具有特别重要的意义。</p>
<p>JML 的设计考虑到了未来扩展需要，把语言分成了几个层次。其中 level 0 是最核心的语言特征，要求所有的 JML 工具都要支持。这里记录 level 0 中最核心和最常用的一些要素。</p>
<h2 id="1-注释结构"><a href="#1-注释结构" class="headerlink" title="1. 注释结构"></a>1. 注释结构</h2><p>JML 以 javadoc 注释的方式来表示规格，每行都以 @ 起头。有两种注释方式，行注释和块注释。其中行注释的表示方式为 <code>//@annotation</code>，块注释的方式为 <code>/* @ annotation @*/</code>。按照 Javadoc 习惯， JML 注释一般放在被注释成分的紧邻上部，如下面的例子所示。其中有效的 Java 代码为 line1，line 3，line 15，line18 和 line19。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jmlspecs.samples.jmlrefman;               <span class="comment">// line 1</span></span><br><span class="line">                                                      <span class="comment">// line 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntHeap</span> </span>&#123;                       <span class="comment">// line 3</span></span><br><span class="line">                                                      <span class="comment">// line 4</span></span><br><span class="line">    <span class="comment">//@ public model non_null int [] elements;        // line 5</span></span><br><span class="line">                                                      <span class="comment">// line 6</span></span><br><span class="line">    <span class="comment">/*@ public normal_behavior                        // line 7</span></span><br><span class="line"><span class="comment">      @   requires elements.length &gt;= 1;              // line 8</span></span><br><span class="line"><span class="comment">      @   assignable \nothing;                        // line 9</span></span><br><span class="line"><span class="comment">      @   ensures \result                             // line 10</span></span><br><span class="line"><span class="comment">      @        == (\max int j;                        // line 11</span></span><br><span class="line"><span class="comment">      @               0 &lt;= j &amp;&amp; j &lt; elements.length;  // line 12</span></span><br><span class="line"><span class="comment">      @               elements[j]);                   // line 13</span></span><br><span class="line"><span class="comment">      @*/</span>                                             <span class="comment">// line 14</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="comment">/*@ pure @*/</span> <span class="function"><span class="keyword">int</span> <span class="title">largest</span><span class="params">()</span></span>;       <span class="comment">// line 15</span></span><br><span class="line">                                                      <span class="comment">// line 16</span></span><br><span class="line">    <span class="comment">//@ ensures \result == elements.length;           // line 17</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="comment">/*@ pure @*/</span> <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;          <span class="comment">// line 18</span></span><br><span class="line">&#125;;                                                    <span class="comment">// line 19 </span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，定义了一个抽象类 <code>IntHeap</code> 。该类提供了两个抽象方法，<code>largest()</code> 和 <code>size()</code>。第 15 行和第 18 行的 JML 规格表示这两个方法都是纯粹查询方法（<code>/*@ pure @ */</code>），即方法的执行不会有任何副作用。这两个方法的规格必须建立在 <code>IntHeap</code> 所管理的数据规格上，因此为了准确说明这两个方面的规格，首先给出了 <code>IntHeap</code> 所管理的数据规格，如第 5 行所示。其中的 <code>model</code> 表示后面的 <code>int[] elements</code> 仅仅是规格层次的描述，并不是这个类的声明组成部分，此外也不意味该类的实现人员必须提供这样的属性定义，<code>non_null</code> 的意义是 <code>elements</code> 这个数组对象引用不能为 <code>null</code>。有了这个基础， 第 17 行给出了 <code>size</code> 方法的后置条件 (post-condition)，即任何时候该方法的执行都会返回 <code>IntHeap</code> 中存储的元素个数(<code>elements.length</code>)，其中的 <code>\result</code> 是 JML 的关键词，表示方法的执行返回结果。<code>largest</code> 的规格通过从第 7 行到第 14 行的注释块来定义，包括三个部分：</p>
<p>（1）<code>requires</code> 子句定义该方法的前置条件(pre-condition)，<code>elements.length&gt;=1</code>，即 <code>IntHeap</code> 中管理着至少一个元素；</p>
<p>（2）副作用范围限定，<code>assignable</code> 列出这个方法能够修改的类成员属性，<code>\nothing</code> 是个关键词，表示这个方法不对任何成员属性进行修改，所以是一个 <code>pure</code> 方法。</p>
<p>（3）<code>ensures</code> 子句定义了后置条件，即 <code>largest</code> 方法的返回结果等于 <code>elements</code> 中存储的所有整数中的最大的那个(<code>\max</code> 也是一个关键词)。</p>
<p>需要注意的是，规格中的每个子句都必须以分号结尾，否则会导致 JML 工具无法解析。相比较而言，largest 方法的规格复杂，而<code>size</code>方法的规格则相对简略。在 JML 中对应着两类规格写法，前者适用于前置条件不是恒真的场景，后者则适用于无需描述其前置条件的场景。</p>
<p>最后还要补充说明一下规格变量的声明。按照 JML 的语法，可以区分两类规格变量，静态或实例。如果是在 Interface 中声明规格变量，则要求明确变量的类别。针对上面的例子，如果是静态规格变量，则声明为 <code>//@public static model non_null int []elements</code>；如果是实例规格变量，则可声明为 <code>//@public instance model non_null int []elements</code>。</p>
<h2 id="2-JML表达式"><a href="#2-JML表达式" class="headerlink" title="2. JML表达式"></a>2. JML表达式</h2><p>JML 的表达式是对 Java 表达式的扩展，新增了一些操作符和原子表达式。同样 JML 表达式中的操作符也有优先级的概念。请参见 JML 语言手册 12.3 节 (Expression) 获得完整的优先级列表。需要提醒的是，JML 相对于 Java 新增的表达式成分仅用于 JML 中的断言 (assertion) 语句和其他相关的注释体。特别需要提醒，在 JML 断言中，不可以使用带有赋值语义的操作符，如 <code>++，--，+=</code> 等操作符，因为这样的操作符会对被限制的相关变量的状态进行修改，产生副作用。</p>
<h3 id="2-1-原子表达式"><a href="#2-1-原子表达式" class="headerlink" title="2.1 原子表达式"></a>2.1 原子表达式</h3><p><code>\result</code> 表达式：表示一个非 <code>void</code> 类型的方法执行所获得的结果，即方法执行后的返回值。<code>\result</code> 表达式的类型就是方法声明中定义的返回值类型。如针对方法：<code>public boolean equals (Object o)</code>，<code>\result</code> 的类型是 <code>boolean</code>，任意传递一个 <code>Object</code> 类型的对象来调用该方法，可以使用 <code>\result</code> 来表示 <code>equals</code> 的执行结果（<code>true </code>表示 <code>this</code> 和 <code>o</code> 相等；<code>false </code>表示不相等）。</p>
<p><code>\old(expr)</code> 表达式：用来表示一个表达式 <code>expr</code> 在相应方法执行前的取值。该表达式涉及到评估 <code>expr</code> 中的对象是否发生变化，遵从 Java 的引用规则，即针对一个对象引用而言，只能判断引用本身是否发生变化，而不能判断引用所指向的对象实体内容是否发生变化。假设一个类有属性 <code>v</code> 为 <code>HashMap</code>，假设在方法执行前 <code>v</code> 的取值为 <code>0x952ab340</code>，即指向了存储在该地址的具体 <code>HashMap</code> 对象，则 <code>\old(v)</code> 的值就是这个引用地址。如果方法执行过程中没有改变 <code>v</code> 指向的对象，则 <code>v</code> 和 <code>\old(v)</code> 有相同的取值，即使方法在执行过程中对 <code>v</code> 指向的 <code>HashMap</code> 执行了插入或删除操作。因此 <code>v.size()</code> 和 <code>\old(v).size()</code> 也有相同的结果。很多情况下，我们希望获得 <code>v</code> 在方法执行前所管理的对象个数，这时应使用 <code>\old(v.size()</code>)。作为一般规则，任何情况下，都应该使用 <code>\old</code> 把关心的表达式取值整体括起来。</p>
<p><code>\not_assigned(x,y,...)</code> 表达式：用来表示括号中的变量是否在方法执行过程中被赋值。如果没有被赋值，返回为 <code>true</code>，否则返回 <code>false</code>。实际上，该表达式主要用于后置条件的约束表示上，即限制一个方法的实现不能对列表中的变量进行赋值。</p>
<p><code>\not_modified(x,y,...)</code> 表达式：与上面的 <code>\not_assigned</code> 表达式类似，该表达式限制括号中的变量在方法执行期间的取值未发生变化。</p>
<p><code>\nonnullelements(container)</code> 表达式：表示 <code>container</code> 对象中存储的对象不会有 <code>null</code>，等价于下面的断言，其中 <code>\forall</code> 是 JML 的关键词，表示针对所有 <code>i</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">container != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">(\forall <span class="keyword">int</span> i; <span class="number">0</span> &lt;= i &amp;&amp; i &lt; container.length;</span><br><span class="line">                container[i] != <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure>

<p><code>\type(type)</code> 表达式：返回类型 <code>type</code> 对应的类型 (Class)，如 <code>type(boolean)</code> 为 <code>Boolean.TYPE</code>。<code>TYPE</code> 是 JML 采用的缩略表示，等同于 Java 中的<code>java.lang.Class</code>。</p>
<p><code>\typeof(expr)</code> 表达式：该表达式返回 <code>expr</code> 对应的准确类型。如 <code>\typeof(false)</code> 为 <code>Boolean.TYPE</code>。</p>
<h3 id="2-2-量化表达式"><a href="#2-2-量化表达式" class="headerlink" title="2.2 量化表达式"></a>2.2 量化表达式</h3><p><code>\forall</code> 表达式：全称量词修饰的表达式，表示对于给定范围内的元素，每个元素都满足相应的约束。<code>(\forall int i,j; 0 &lt;= i &amp;&amp; i &lt; j &amp;&amp; j &lt; 10; a[i] &lt; a[j])</code>，意思是针对任意 <code>0 &lt;= i &lt; j &lt; 10，a[i] &lt; a[j]</code>。这个表达式如果为真 (<code>true</code>)，则表明数组 <code>a</code> 实际是升序排列的数组。</p>
<p><code>\exists</code> 表达式：存在量词修饰的表达式，表示对于给定范围内的元素，存在某个元素满足相应的约束。<code>(\exists int i; 0 &lt;= i &amp;&amp; i &lt; 10; a[i] &lt; 0)</code>，表示针对 <code>0 &lt;= i &lt; 10</code>，至少存在一个 <code>a[i]&lt;0</code>。</p>
<p><code>\sum</code> 表达式：返回给定范围内的表达式的和。<code>(\sum int i; 0 &lt;= i &amp;&amp; i &lt; 5; i)</code>，这个表达式的意思计算 <code>[0,5)</code> 范围内的整数 <code>i</code> 的和，即 <code>0 + 1 + 2 + 3 + 4 = 10</code>。注意中间的 <code>0 &lt;= i &amp;&amp; i &lt; 5</code> 是对 <code>i</code> 范围的限制，求和表达式为最后面的那个 <code>i</code>。同理，我们构造表达式 <code>(\sum int i; 0 &lt;= i &amp;&amp; i &lt; 5; i*i)</code>，则返回的结果为 <code>1 + 4 + 9 + 16</code>。</p>
<p><code>\product</code> 表达式：返回给定范围内的表达式的连乘结果。<code>(\product int i; 0 &lt; i &amp;&amp; i &lt; 5; i)</code>，这个表达式的意思是针对 <code>(0,5)</code> 范围的整数的连乘结果，即 <code>1* 2* 3 * 4</code> 。</p>
<p><code>\max</code> 表达式：返回给定范围内的表达式的最大值。<code>(\max int i; 0 &lt;= i &amp;&amp; i &lt; 5; i)</code>，这个表达式返回 <code>[0,5)</code> 中的最大的整数，即 <code>4</code>。</p>
<p><code>\min</code> 表达式：返回给定范围内的表达式的最小值。<code>(\min int i; 0 &lt;= i &amp;&amp; i &lt; 5; i)</code>，这个表达式返回 <code>[0,5)</code> 中的最小的整数，即 <code>0</code>。</p>
<p><code>\num_of</code> 表达式：返回指定变量中满足相应条件的取值个数。<code>(\num_of int x; 0 &lt; x &amp;&amp; x &lt;= 20; x % 2 == 0)</code>，这个表达式给出 <code>(0,20]</code> 以内能够被 <code>2</code> 整除的整数个数，得到的数目为 <code>10</code>。一般的，<code>\num_of</code> 表达式可以写成 <code>(\num_of T x; R(x);P(x))</code>，其中 <code>T</code> 为变量 <code>x</code> 的类型，<code>R(x)</code> 为 <code>x</code> 的取值范围；<code>P(x)</code> 定义了 <code>x</code> 需要满足的约束条件。从逻辑上来看，该表达式也等价于 <code>(\sum T x; R(x) &amp;&amp; P(x); 1)</code>。</p>
<h3 id="2-3-集合表达式"><a href="#2-3-集合表达式" class="headerlink" title="2.3 集合表达式"></a>2.3 集合表达式</h3><p>集合构造表达式：可以在 JML 规格中构造一个局部的集合（容器），明确集合中可以包含的元素。<code>new JMLObjectSet &#123;Integer i | s.contains(i) &amp;&amp; 0 &lt; i.intValue() &#125; </code>表示构造一个 <code>JMLObjectSet</code> 对象，其中包含的元素类型为 <code>Integer</code>，该集合中的所有元素都在容器集合 <code>s</code> 中出现（注：该容器集合指 Java 程序中构建的容器，比如 <code>ArrayList</code>），且整数值大于 <code>0</code> 。集合构造表达式的一般形式为：<code>new ST &#123;T x | R(x) &amp;&amp; P(x)&#125;</code>，其中的 <code>R(x)</code> 对应集合中 <code>x</code> 的范围，通常是来自于某个既有集合中的元素，如 <code>s.has(x)</code> ，<code>P(x)</code> 对应 <code>x</code> 取值的约束。</p>
<h3 id="2-4-操作符"><a href="#2-4-操作符" class="headerlink" title="2.4 操作符"></a>2.4 操作符</h3><p>JML 表达式中可以正常使用 Java 语言所定义的操作符，包括算术操作符、逻辑预算操作符等。此外，JML 专门又定义了如下四类操作符。</p>
<p>(1) 子类型关系操作符：<code>E1&lt;:E2</code>，如果类型 <code>E1</code> 是类型 <code>E2</code> 的子类型 (sub type)，则该表达式的结果为真，否则为假。如果 <code>E1</code> 和 <code>E2</code> 是相同的类型，该表达式的结果也为真，如 <code>Integer.TYPE&lt;:Integer.TYPE </code>为真；但<code>Integer.TYPE&lt;:ArrayList.TYPE </code>为假。需要指出的是，任意一个类 <code>X</code> ，都必然满足 <code>X.TYPE&lt;:Object.TYPE</code>。</p>
<p>(2) 等价关系操作符：<code>b_expr1&lt;==&gt;b_expr2</code>或者<code>b_expr1&lt;=!=&gt;b_expr2</code>，其中 <code>b_expr1</code> 和 <code>b_expr2</code> 都是布尔表达式，这两个表达式的意思是 <code>b_expr1==b_expr2</code> 或者 <code>b_expr1!=b_expr2</code> 。可以看出，这两个操作符和 Java 中的 <code>==</code> 和 <code>!=</code> 具有相同的效果，按照 JML 语言定义，<code>&lt;==&gt;</code> 比 <code>==</code> 的优先级要低，同样 <code>&lt;=!=&gt;</code> 比 <code>!=</code> 的优先级低。</p>
<p>(3) 推理操作符：<code>b_expr1==&gt;b_expr2</code> 或者 <code>b_expr2&lt;==b_expr1</code>。对于表达式 <code>b_expr1==&gt;b_expr2</code> 而言，当 <code>b_expr1==false</code>，或者 <code>b_expr1==true</code> 且 <code>b_expr2==true</code> 时，整个表达式的值为 <code>true</code>。</p>
<p>(4) 变量引用操作符：除了可以直接引用 Java 代码或者 JML 规格中定义的变量外，JML 还提供了几个概括性的关键词来引用相关的变量。<code>\nothing</code> 指示一个空集；<code>\everything</code> 指示一个全集，即包括当前作用域下能够访问到的所有变量。变量引用操作符经常在assignable句子中使用，如 <code>assignable \nothing</code> 表示当前作用域下每个变量都不可以在方法执行过程中被赋值。</p>
<h2 id="3-方法规格"><a href="#3-方法规格" class="headerlink" title="3. 方法规格"></a>3. 方法规格</h2><p>方法规格是 JML 的重要内容，本手册仅涉及最基础的部分，而不引述 JML 扩展部分的内容。方法规格的核心内容包括三个方面，前置条件、后置条件和副作用约定。其中前置条件是对方法输入参数的限制，如果不满足前置条件，方法执行结果不可预测，或者说不保证方法执行结果的正确性；后置条件是对方法执行结果的限制，如果执行结果满足后置条件，则表示方法执行正确，否则执行错误。副作用指方法在执行过程中对输入对象或 <code>this</code> 对象进行了修改（对其成员变量进行了赋值，或者调用其修改方法）。课程区分两类方法：全部过程和局部过程。前者对应着前置条件恒为真，即可以适应于任意调用场景；后者则提供了非恒真的前置条件，要求调用者必须确保调用时满足相应的前置条件。从设计角度，软件需要适应用户的所有可能输入，因此也需要对不符合前置条件的输入情况进行处理，往往对应着异常处理。从规格的角度，JML 区分这两种场景，分别对应正常行为规格 (normal_behavior) 和异常行为规格 (expcetional_behavior)。</p>
<ul>
<li>前置条件 (pre-condition)</li>
</ul>
<p>前置条件通过 <code>requires</code> 子句来表示：<code>requires P;</code>。其中 <code>requires</code> 是 JML 关键词，表达的意思是“要求调用者确保P为真”。注意，方法规格中可以有多个 <code>requires</code> 子句，是并列关系，即调用者必须同时满足所有的并列子句要求。如果设计者想要表达或的逻辑，则应该使用一个 <code>requires</code> 子句，在其中的谓词 <code>P</code> 中使用逻辑或操作符来表示相应的约束场景：<code>requires P1||P2;</code>。</p>
<ul>
<li>后置条件 (post-condition)</li>
</ul>
<p>后置条件通过 <code>ensures</code> 子句来表示：<code>ensures P;</code>。其中 <code>ensures</code> 是 JML 关键词，表达的意思是“方法实现者确保方法执行返回结果一定满足谓词P的要求，即确保 <code>P</code> 为真”。同样，方法规格中可以有多个 <code>ensures</code> 子句，是并列关系，即方法实现者必须同时满足有所并列 <code>ensures</code> 子句的要求。如果设计者想要表达或的逻辑，这应该在在一个 <code>ensures</code> 子句中使用逻辑或 （<code>||</code>）操作符来表示相应的约束场景：<code>ensures P1||P2;</code>。</p>
<ul>
<li>副作用范围限定 (side-effects)</li>
</ul>
<p>副作用指方法在执行过程中会修改对象的属性数据或者类的静态成员数据，从而给后续方法的执行带来影响。从方法规格的角度，必须要明确给出副作用范围。JML 提供了副作用约束子句，使用关键词 <code>assignable</code> 或者 <code>modifiable</code>。从语法上来看，副作用约束子句共有两种形态，一种不指明具体的变量，而是用JML关键词来概括；另一种则是指明具体的变量列表。下面是几种经常出现的副作用约束子句形态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerSet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> ArrayList&lt;Integer&gt; elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> Integer max;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> Integer min;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*@</span></span><br><span class="line"><span class="comment">    @ ...</span></span><br><span class="line"><span class="comment">    @ assignable \nothing;</span></span><br><span class="line"><span class="comment">    @ assignable \everything;</span></span><br><span class="line"><span class="comment">    @ modifiable \nothing;</span></span><br><span class="line"><span class="comment">    @ modifiable \everthing;</span></span><br><span class="line"><span class="comment">    @ assignable elements;</span></span><br><span class="line"><span class="comment">    @ modifiable elements;</span></span><br><span class="line"><span class="comment">    @ assignable elements, max, min;</span></span><br><span class="line"><span class="comment">    @ modifiable elements, max, min;</span></span><br><span class="line"><span class="comment">    @*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如该例子所述，<code>assignble </code>表示可赋值，而 <code>modifiable</code> 则表示可修改。虽然二者有细微的差异，在大部分情况下，二者可交换使用。其中 <code>\nothing</code> 和 <code>\everything</code> 是两个关键词，前者表示当前作用域内可见的所有类成员变量和方法输入对象都不可以赋值或者修改；后者表示当前作用域内可见的所有类成员变量和方法输入对象都可以赋值或者修改。也可以指明具体可修改的变量列表，一个变量或多个变量，如果是多个则通过逗号分隔，如 <code>@ assignable elements, max, min;</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注<span class="number">1</span>：JML不允许在副作用约束子句中指定规格声明的变量数据，因为这样的声明只是为了描述规格，并不意味实现者一定要实现这样的数据。</span><br><span class="line">注<span class="number">2</span>：默认情况下，方法的规格对调用者可见，但是方法所在类的成员变量一般都声明为 <span class="keyword">private</span> ,对调用者不可见。有时方法规格不得不使用类的成员变量来限制方法的行为，比如上面例子中的副作用范围限定，这就和类对相应成员变量的私有化保护产生了冲突。为了解决这个问题，JML提供了 <span class="comment">/*@spec_public@*/</span> 来注释一个类的私有成员变量，表示在规格中可以直接使用，从而调用者可见。</span><br></pre></td></tr></table></figure>

<p>设计中会出现某些纯粹访问性的方法，即不会对对象的状态进行任何改变，也不需要提供输入参数，这样的方法无需描述前置条件，也不会有任何副作用，且执行一定会正常结束。对于这类方法，可以使用简单的（轻量级）方式来描述其规格，即使用 <code>pure</code> 关键词：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//@ ensures \result == bachelor || \result == master;</span></span><br><span class="line"><span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="function"><span class="keyword">int</span> <span class="title">getStatus</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//@ ensures \result &gt;= 0;</span></span><br><span class="line"><span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="function"><span class="keyword">int</span> <span class="title">getCredits</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>针对上面的三个例子，<code>getName</code> 甚至不需要做任何限定，是一种极简的场景；<code>getStatus</code> 例子则限定了返回值 <code>\result</code> 要么 <code>==bachelor</code>，要么 <code>==master</code>；<code>getCredits</code> 的例子则限定了返回值必须大于等于 <code>0</code> ：<code>\result &gt;=0</code>。</p>
<p>在方法规格中，有些前置条件可以引用 <code>pure</code> 方法返回的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ requires c &gt;= 0;</span></span><br><span class="line"><span class="comment">@ ensures getCredits() == \old(getCredits()) + c;</span></span><br><span class="line"><span class="comment">@*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCredits</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>

<p>有时候，前置条件或后置条件需要对不止一个变量进行约束，往往是需要对一个容器中的所有元素进行约束，这时就需要使用 <code>\forall</code> 或者 <code>\exists</code> 表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ requires size &lt; limit &amp;&amp; !contains(elem);</span></span><br><span class="line"><span class="comment">@ ensures \result == true;</span></span><br><span class="line"><span class="comment">@ ensures contains(elem);</span></span><br><span class="line"><span class="comment">@ ensures (\forall int e;</span></span><br><span class="line"><span class="comment">@ e != elem;</span></span><br><span class="line"><span class="comment">@ contains(e) &lt;==&gt; \old(contains(e)));</span></span><br><span class="line"><span class="comment">@ ensures size == \old(size) + 1;</span></span><br><span class="line"><span class="comment">@*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> elem)</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br></pre></td></tr></table></figure>

<p>上面的这个例子要求调用 <code>add</code> 方法之前，调用者必须确保当前对象管理的元素（整数）数目不能超过限制(<code>limit</code>)，同时不能重复加入相同的整数（<code>!contains(elem)</code>）。该方法的规格有三个并列的后置条件，<code>ensures contains(elem)</code> 要求 <code>add</code> 方法一定要把参数 <code>elem</code> 对应的整数加入到容器中；<code>ensures size == \old(size) + 1 </code>要求容器中管理的整数数目增加一个；中间的那个后置条件要求原来容器中包含的整数仍然在容器中，使用 <code>\forall </code>表达式来表示。</p>
<p>更进一步，假设带有规模限制的整数容器还提供了一个 <code>remove</code> 方法，这个方法要求：（1）如果输入参数在容器中，则移除该整数；（2）任何情况下，都不能移除容器中不等于输入参数的任何整数。要对这个方法的后置条件进行设计，需要从两个方面进行限制，一个是方法运行结果中不包含输入的整数，同时容器原来不等于输入参数的整数仍然还在容器中；另一方面需要对象容器的规模进行限制，如果输入参数在容器中，则容器存储的整数数目减少一个，否则保持不变。按照这个设计，可以得到如下完整的方法规格：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ ensures !contains(elem);</span></span><br><span class="line"><span class="comment">@ ensures (\forall int e;</span></span><br><span class="line"><span class="comment">@ e != elem;</span></span><br><span class="line"><span class="comment">@ contains(e) &lt;==&gt; \old(contains(e)));</span></span><br><span class="line"><span class="comment">@ ensures \old(contains(elem)) ==&gt; size == \old(size) - 1;</span></span><br><span class="line"><span class="comment">@ ensures !\old(contains(elem)) ==&gt; size == \old(size);</span></span><br><span class="line"><span class="comment">@*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> elem)</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如前所述，为了有效的区分方法的正常功能行为和异常行为，JML 提供了这两类行为的区分机制，可以明确按照这两类行为来分别描述方法的规格，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">@ requires z &lt;= 99;</span></span><br><span class="line"><span class="comment">@ assignable \nothing;</span></span><br><span class="line"><span class="comment">@ ensures \result &gt; z;</span></span><br><span class="line"><span class="comment">@ also</span></span><br><span class="line"><span class="comment">@ public exceptional_behavior</span></span><br><span class="line"><span class="comment">@ requires z &lt; 0;</span></span><br><span class="line"><span class="comment">@ assignable \nothing;</span></span><br><span class="line"><span class="comment">@ signals (IllegalArgumentException e) true;</span></span><br><span class="line"><span class="comment">@*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">cantBeSatisfied</span><span class="params">(<span class="keyword">int</span> z)</span> <span class="keyword">throws</span> IllegalArgumentException；</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>public normal_behavior </code>表示接下来的部分对 <code>cantBeSatisfied(int z)</code> 方法的正常功能给出规格。所谓正常功能，一般指输入或方法关联this对象的状态在正常范围内时所指向的功能。与正常功能相对应的是异常功能，即 <code>public exceptional_behavior</code> 下面所定义的规格。其中的 <code>public</code> 指相应的规格在所在包范围内的所有其他规格处都可见。需要说明的是，如果一个方法没有异常处理行为，则无需区分正常功能规格和异常功能规格，因而也就不必使用这两个关键词。</p>
<p>上面例子中出现了一个关键词 <code>also</code>，它的意思是除了正常功能规格外，还有一个异常功能规格。需要说明的是，按照JML语言规范定义，有两种使用 <code>also</code> 的场景：（1）父类中对相应方法定义了规格，子类重写了该方法，需要补充规格，这时应该在补充的规格之前使用 <code>also</code> ；（2）一个方法规格中涉及多个功能规格描述，正常功能规格或者异常功能规格，需要使用 <code>also</code> 来分隔。</p>
<p>我们仔细看上面的例子，实际上存在逻辑矛盾，即正常功能的前置条件蕴含了异常功能的前置条件（<code>&#123;z &lt;= 99&#125; </code>与 <code>&#123;z &lt; 0&#125;</code> 有交集），因此对于这个例子的规格而言，任何实现都不可能满足该规格。这样的矛盾规格是严重的设计错误，要避免。作为一种重要的设计检查原则，同一个方法的正常功能前置条件和异常功能前置条件一定不重叠。对于上面的例子而言，如果正常功能前置条件修改为 <code>z &gt;= 0</code> 就能满足这个要求。可以看出不论是正常功能规格，或者是异常功能规格，都包括前置条件、后置条件和副作用声明。不同的是，异常功能规格中，后置条件常常表示为抛出异常，使用 <code>signals</code> 子句来表示。</p>
<ul>
<li>signals 子句</li>
</ul>
<p>signals 子句的结构为 <code>signals (***Exception e) b_expr;</code>，意思是当 <code>b_expr</code> 为 <code>true</code> 时，方法会抛出括号中给出的相应异常 <code>e</code>。对于上面的例子而言，只要输入满足 <code>z &lt; 0</code>，就一定会抛出异常 <code>IllegalArgumentException</code>。需要注意的是，所抛出的既可以是 Java 预先定义的异常类型，也可以是用户自定义的异常类型。此外，还有一个注意事项，如果一个方法在运行时会抛出异常，一定要在方法声明中明确指出（使用 Java 的 <code>throws</code> 表达式），且必须确保 signals 子句中给出的异常类型一定等同于方法声明中给出的异常类型，或者是后者的子类型。</p>
<p>还有一个简化的 signals 子句，即 signals_only 子句，后面跟着一个异常类型。signals 子句强调在对象状态满足某个条件时会抛出符合相应类型的异常；而 signals_only 则不强调对象状态条件，强调满足前置条件时抛出相应的异常。</p>
<p>有时候，为了更加明确的区分异常，会针对输入参数的取值范围抛出不同的异常，从而提醒调用者进行不同的处理。这时可以使用多个 exceptional_behavior：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="comment">/** A specification that can&#x27;t be satisfied. */</span></span><br><span class="line">  <span class="comment">//@ public model non_null int[] credits; </span></span><br><span class="line">  <span class="comment">/*@ normal_behavior</span></span><br><span class="line"><span class="comment">    @ requires z &gt;=0 &amp;&amp; z &lt;= 100;</span></span><br><span class="line"><span class="comment">    @ assignable \nothing;</span></span><br><span class="line"><span class="comment">    @ ensures \result == credits.length;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    @ also</span></span><br><span class="line"><span class="comment">    @ exceptional_behavior</span></span><br><span class="line"><span class="comment">	@ requires z &lt; 0;</span></span><br><span class="line"><span class="comment">	@ assignable \nothing;</span></span><br><span class="line"><span class="comment">	@ signals_only IllegalArgumentException;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	@ also</span></span><br><span class="line"><span class="comment">    @ exceptional_behavior</span></span><br><span class="line"><span class="comment">	@ requires z &gt; 100;</span></span><br><span class="line"><span class="comment">	@ assignable \nothing;</span></span><br><span class="line"><span class="comment">	@ signals_only OverFlowException;</span></span><br><span class="line"><span class="comment">    @*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">recordCredit</span><span class="params">(<span class="keyword">int</span> z)</span> <span class="keyword">throws</span> IllegalArgumentException, OverFlowException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个例子是针对 <code>Student</code> 类提供的 <code>recordCredit(int z)</code> 方法，从规格角度定义了一个规格数据 <code>int[] credits</code>，并提供了三个功能规格，使用两个 <code>also</code> 进行了分隔。注意看三个功能规格的 <code>requires</code> 子句，在一起覆盖了方法输入参数的所有看取值范围，而且彼此没有交叉。这是功能规格设计的基本要求，同学们一定要小心这一点。其中两个异常功能规格使用 signals_only 子句分别抛出相应的异常。需要指出的是，在异常功能规格中，除了抛出异常，也一样可以正常使用 ensures 子句来描述方法执行产生的其他结果。</p>
<h2 id="4-类型规格"><a href="#4-类型规格" class="headerlink" title="4. 类型规格"></a>4. 类型规格</h2><p>类型规格指针对 Java 程序中定义的数据类型所设计的限制规则，一般而言，就是指针对类或接口所设计的约束规则。从面向对象角度来看，类或接口包含数据成员和方法成员的声明及或实现。不失一般性，一个类型的成员要么是静态成员 (static member)，要么是实例成员 (instance member)。一个类的静态方法不可以访问这个类的非静态成员变量（即实例变量）。静态成员可以直接通过类型来引用，而实例成员只能通过类型的实例化对象来引用。因此，在设计和表示类型规格时需要加以区分。</p>
<p>JML 针对类型规格定义了多种限制规则，从课程的角度，我们主要涉及两类，不变式限制 (invariant) 和约束限制 (constraints)。无论哪一种，类型规格都是针对类型中定义的数据成员所定义的限制规则，一旦违反限制规则，就称相应的状态有错。</p>
<ul>
<li>不变式 invariant</li>
</ul>
<p>不变式（invariant）是要求在所有<strong>可见状态</strong>下都必须满足的特性，语法上定义 <code>invariant P</code>，其中 <code>invariant </code>为关键词，<code>P </code>为谓词。对于类型规格而言，<strong>可见状态 (visible state)</strong> 是一个特别重要的概念。下面所述的几种时刻下对象 <code>o</code> 的状态都是可见状态：</p>
<ul>
<li><p>对象的有状态构造方法（用来初始化对象成员变量初值）的执行结束时刻</p>
</li>
<li><p>在调用一个对象回收方法（finalize 方法）来释放相关资源开始的时刻</p>
</li>
<li><p>在调用对象 <code>o</code> 的非静态、有状态方法（non-helper）的开始和结束时刻</p>
</li>
<li><p>在调用对象 <code>o</code> 对应的类或父类的静态、有状态方法的开始和结束时刻</p>
</li>
<li><p>在未处于对象 <code>o</code> 的构造方法、回收方法、非静态方法被调用过程中的任意时刻</p>
</li>
<li><p>在未处于对象 <code>o</code> 对应类或者父类的静态方法被调用过程中的任意时刻</p>
</li>
</ul>
<p>由上面的定义可知，凡是会修改成员变量（包括静态成员变量和非静态成员变量）的方法执行期间，对象的状态都不是可见状态。这里的可见不是一般意义上的能否见到，而是带有完整可见的意思。在会修改状态的方法执行期间，对象状态不稳定，随时可能会被修改。换句话说，在方法执行期间，对象的不变式有可能不满足。因此，类型规格强调在任意可见状态下都要满足不变式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Path</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> ArrayList &lt;Integer&gt; seq_nodes;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> Integer start_node;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> Integer end_node;</span><br><span class="line">    <span class="comment">/*@ invariant seq_nodes != null &amp;&amp; </span></span><br><span class="line"><span class="comment">      @ seq_nodes[0] == start_node &amp;&amp; </span></span><br><span class="line"><span class="comment">      @ seq_nodes[seq_nodes.length-1] == end_node &amp;&amp; </span></span><br><span class="line"><span class="comment">      @ seq_nodes.length &gt;=2;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面的例子所示，<code>Path</code> 类的不变式定义了 <code>seq_nodes</code> 不能为 <code>null</code> ，且任意一个 <code>path</code> 对象至少包括两个节点，一个起始节点 (<code>start_node</code>) 和一个终止节点 (<code>end_node</code>) 。一个类可以包括多个不变式，相互独立。如果一个对象的可见状态不满足不变式，则称该对象的状态有错。实际工程中，如果一个类中有两个产生逻辑矛盾的不变式（即二者不可能同时为真），则出现了规格设计缺陷。需要指出的是，不变式中可以直接引用 <code>pure</code> 形态的方法。</p>
<p>对应类成员变量有静态和非静态之分，JML 区分两类不变式，静态不变式 (static invariant) 和实例不变式 (instance invariant)。其中静态不变式只针对类中的静态成员变量取值进行约束，而实例不变式则可以针对静态成员变量和非静态成员变量的取值进行约束。可以在不变式定义中明确使用 <code>instance invariant </code>或 <code>static invariant </code>来表示不变式的类别。</p>
<ul>
<li>状态变化约束 constraint</li>
</ul>
<p>对象的状态在变化时往往也许满足一些约束，这种约束本质上也是一种不变式。JML 为了简化使用规则，规定invariant 只针对可见状态(即当下可见状态)的取值进行约束，而是用 constraint 来对前序可见状态和当前可见状态的关系进行约束。如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceCounter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> <span class="keyword">long</span> counter;</span><br><span class="line">    <span class="comment">//@ invariant counter &gt;= 0;</span></span><br><span class="line">    <span class="comment">//@ constraint counter == \old(counter)+1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类 <code>ServiceCounter</code> 拥有一个成员变量 <code>counter</code> ，包含一个不变式和一个状态变化约束。不变式指出<code>counter &gt;= 0</code>，而 constraint 不同，约束每次修改 <code>counter</code> 只能加 <code>1</code>。虽然这个约束可以在可能对 <code>counter</code> 进行修改的方法中通过后置条件来表示，但是每个可能修改 <code>counter</code> 的方法都需要加上这样的后置条件，远不如 constraint 这样的表示来的方便。不仅如此，invariant 和 constraint 可以直接被子类继承获得。</p>
<p>和不变式一样，JML 也根据类的静态成员变量区分了两类约束：static constraint 和 instance constraint。其中static constraint 只涉及类的静态成员变量，而 instance constraint 则可以涉及类的静态成员变量和非静态成员变量。同样，也可以在规格中通过关键词来明确加以区分：<code>static constraint P </code>和 <code>instance constraint P</code>。</p>
<ul>
<li>方法与类型规格的关系</li>
</ul>
<p>如果一个类是不可变类，其实就没必要定义其不变式，只需要在构造方法中明确其初始状态应该满足的后置条件即可。当然，也可以反过来，定义不变式，而不定义构造方法的后置条件。事实上，在大部分情况下，一个类有几种不同类别的方法：静态初始化（不是方法，但也是一种行为）、有状态静态方法、有状态构造方法、有状态非静态方法。下表给出了两类不变式与这些方法的关系：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">静态成员初始化</th>
<th align="center">有状态静态方法</th>
<th align="center">有状态构造方法</th>
<th align="center">有状态非静态方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">static invariant</td>
<td align="center">建立</td>
<td align="center">保持</td>
<td align="center">保持</td>
<td align="center">保持</td>
</tr>
<tr>
<td align="center">instance invariant</td>
<td align="center">(无关)</td>
<td align="center">(无关)</td>
<td align="center">建立</td>
<td align="center">保持，除非是finalizer方法</td>
</tr>
</tbody></table>
<p>注：“建立”的含义是静态成员建立了满足相应不变式的类或对象状态。“保持”的含义是如果方法执行前不变式满足，执行后还应该满足相应的不变式。</p>
<p>同理，JML 也对 constraint 与方法之间的关系进行了约定：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">静态成员初始化</th>
<th align="center">有状态静态方法</th>
<th align="center">有状态构造方法</th>
<th align="center">有状态非静态方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">static constraint</td>
<td align="center">(无关)</td>
<td align="center">遵从</td>
<td align="center">遵从</td>
<td align="center">遵从</td>
</tr>
<tr>
<td align="center">instance constraint</td>
<td align="center">(无关)</td>
<td align="center">(无关)</td>
<td align="center">(无关)</td>
<td align="center">遵从</td>
</tr>
</tbody></table>
<p>注：“遵从”的含义是成员变量的当前取值和上一个取值之间的关系满足 constraint 的规定，即“遵从规定”。</p>
<h2 id="5-一个完整例子"><a href="#5-一个完整例子" class="headerlink" title="5. 一个完整例子"></a>5. 一个完整例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="comment">/*@ spec_public @*/</span> String name;</span><br><span class="line">	<span class="comment">//@ public invariant credits &gt;= 0;</span></span><br><span class="line">	<span class="keyword">private</span> <span class="comment">/*@ spec_public @*/</span> <span class="keyword">int</span> credits;</span><br><span class="line">	<span class="comment">/*@ public invariant credits &lt; 180 ==&gt; !master &amp;&amp;</span></span><br><span class="line"><span class="comment">	  @ credits &gt;= 180 ==&gt; master;</span></span><br><span class="line"><span class="comment">	  @*/</span></span><br><span class="line">	<span class="keyword">private</span> <span class="comment">/*@ spec_public @*/</span> <span class="keyword">boolean</span> master;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">/*@ requires sname != null;</span></span><br><span class="line"><span class="comment">	  @ assignable \everything;</span></span><br><span class="line"><span class="comment">	  @ ensures name == sname &amp;&amp; credits == 0 &amp;&amp; master == false;</span></span><br><span class="line"><span class="comment">	  @*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span> <span class="params">(String sname)</span> </span>&#123;</span><br><span class="line">		name = sname;</span><br><span class="line">		credits = <span class="number">0</span>;</span><br><span class="line">		master = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ requires c &gt;= 0;</span></span><br><span class="line"><span class="comment">	  @ ensures credits == \old(credits) + c;</span></span><br><span class="line"><span class="comment">	  @ assignable credits, master;</span></span><br><span class="line"><span class="comment">	  @ ensures (credits &gt;= 180) ==&gt; master</span></span><br><span class="line"><span class="comment">	  @*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCredits</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		updateCredits(c);</span><br><span class="line">		<span class="keyword">if</span> (credits &gt;= <span class="number">180</span>) &#123;</span><br><span class="line">			changeToMaster();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ requires c &gt;= 0;</span></span><br><span class="line"><span class="comment">	  @ ensures credits == \old(credits) + c;</span></span><br><span class="line"><span class="comment">	  @ assignable credits;</span></span><br><span class="line"><span class="comment">	  @*/</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateCredits</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		credits += c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ requires credits &gt;= 180;</span></span><br><span class="line"><span class="comment">	  @ ensures master;</span></span><br><span class="line"><span class="comment">	  @ assignable master;</span></span><br><span class="line"><span class="comment">	  @*/</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">changeToMaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		master = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ ensures this.name == name;</span></span><br><span class="line"><span class="comment">	  @ assignable this.name;</span></span><br><span class="line"><span class="comment">	  @*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ ensures \result == name;</span></span><br><span class="line"><span class="comment">	  @*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是一个针对 <code>Student</code> 类的完整例子。该类提供了三个私有成员变量：<code>private String name</code>、<code>private int credits </code> 和<code>private boolean master</code>。如前所述，因为这三个是私有成员，规格中是不可见的，JML 通过使用 <code>/*@ spec_public @*/</code> 来解决这个问题。</p>
<p>对比看一下 <code>addCredits(c)</code> 方法和 <code>updateCredits(c)</code> 方法的规格，二者的共同效果是 <code>credits == \old(credits) + c</code>（如果 <code>c &gt;= 0</code>）。<code>(credits &gt;= 180) ==&gt; master </code>给出了 <code>addCredits(c)</code> 方法的差异化功能，即不仅仅改变学分，还会判断学分情况，从而及时改变 <code>master</code> 变量的取值。如果忽略掉了这个后置条件，实际上就隐藏了设计错误。注意方法的规格不对什么情况调用什么方法做出规定（这实际上是非常细节的实现问题），虽然 JML 提供了 callable 子句来规定一个方法在执行过程可能会调用哪些方法，但是并不会对方法执行的后置条件产生实质影响。</p>
<p>针对从给定方法实现中来提取规格的场景，实践中往往会有方法调用，这时需要把被调用方法的后置条件附加到当前方法，并增加关于该方法被调用条件的约束。可以很清楚的看到，<code>addCredits</code> 规格合并了 <code>changeToMaster</code> 的后置条件，但增加了相应的调用条件约束（<code>credits &gt;= 180</code>）。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OOP/">OOP</a><a class="post-meta__tags" href="/tags/JML/">JML</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/03/07/VZlJGrpcOBaUtdo.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/26/OperatingSystem/OS_%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"><img class="prev-cover" src="https://img.imgdb.cn/item/608787d0d1a9ae528f47fb66.jpg" onerror="onerror=null;src='/img/404_2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">「OS」文件管理（文件系统）</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/19/OperatingSystem/OS-IO%E7%AE%A1%E7%90%86/"><img class="next-cover" src="https://img.imgdb.cn/item/608787d0d1a9ae528f47fb66.jpg" onerror="onerror=null;src='/img/404_2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">「OS」IO管理</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/%E9%AD%94%E6%B3%95_1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">烟湮燕眼</div><div class="author-info__description">slack off happily</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/defender-dhy" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%84%E6%A0%BC"><span class="toc-text">规格</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%84%E6%A0%BC"><span class="toc-text">什么是规格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%84%8F%E4%B9%89"><span class="toc-text">意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E8%A7%84%E6%A0%BC"><span class="toc-text">如何表示规格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%B1%82%E6%AC%A1%E4%B8%8B%E7%9A%84%E8%A7%84%E6%A0%BC%E5%85%B3%E7%B3%BB"><span class="toc-text">类型层次下的规格关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JML"><span class="toc-text">JML</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B3%A8%E9%87%8A%E7%BB%93%E6%9E%84"><span class="toc-text">1. 注释结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-JML%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">2. JML表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%8E%9F%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">2.1 原子表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%87%8F%E5%8C%96%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">2.2 量化表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%9B%86%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">2.3 集合表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">2.4 操作符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95%E8%A7%84%E6%A0%BC"><span class="toc-text">3. 方法规格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B1%BB%E5%9E%8B%E8%A7%84%E6%A0%BC"><span class="toc-text">4. 类型规格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E4%BE%8B%E5%AD%90"><span class="toc-text">5. 一个完整例子</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 烟湮燕眼</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>