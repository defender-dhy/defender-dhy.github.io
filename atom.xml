<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>烟湮燕眼&#39;s Notes</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-05-16T15:14:04.530Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>烟湮燕眼</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「C++ 内存管理」</title>
    <link href="http://yoursite.com/2021/05/16/cpp/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2021/05/16/cpp/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-05-16T01:00:15.000Z</published>
    <updated>2021-05-16T15:14:04.530Z</updated>
    
    
    
    
    <category term="C++ 内存管理" scheme="http://yoursite.com/categories/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
    <category term="内存管理" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>「C++ 基础」继承 &amp; 多态 内存原理</title>
    <link href="http://yoursite.com/2021/05/15/cpp/2%20-%20%E7%BB%A7%E6%89%BF%20&amp;%20%E5%A4%9A%E6%80%81/"/>
    <id>http://yoursite.com/2021/05/15/cpp/2%20-%20%E7%BB%A7%E6%89%BF%20&amp;%20%E5%A4%9A%E6%80%81/</id>
    <published>2021-05-15T01:00:15.000Z</published>
    <updated>2021-05-16T09:31:49.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承可以重用代码功能和提高执行效率的效果。 </p><p>一个类可以派生自多个类。类派生列表以一个或多个基类命名，形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>-<span class="keyword">class</span>:</span> access-specifier base-<span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure><p>未使用访问修饰符 access-specifier，则默认为 private。 </p><p>一个派生类继承的基类方法不包括如下几种情况：</p><ul><li>基类的构造函数、析构函数和拷贝构造函数。</li><li>基类的重载运算符。</li><li>基类的友元函数。</li></ul><h2 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h2><p>通常使用 <code>public</code> 继承</p><ul><li><strong>public 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中均不变</li><li><strong>protected 继承：</strong>基类 public 成员的访问属性在派生类中变成 protected。其他两种访问属性不变。</li><li><strong>private 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中均变成 private</li></ul><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>即一个子类可以有多个父类，它继承了多个父类的特性。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;</span>派生类名&gt;:&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类 Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line">      <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类 PaintCost</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintCost</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getCost</span><span class="params">(<span class="keyword">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> area * <span class="number">70</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line">   <span class="keyword">int</span> area;</span><br><span class="line"> </span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">   area = Rect.<span class="built_in">getArea</span>();</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total paint cost: $&quot;</span> &lt;&lt; Rect.<span class="built_in">getCost</span>(area) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。在程序中任意点可以根据所调用的对象类型来选择调用的函数，即<strong>动态链接</strong>。虚函数必须实现。</p><p>首先明确虚函数的目的：让不同的派生类将继承自父类的同一个虚成员函数(接口)的根据派生类的功能需求进行不同行为的实现，以此达到不同的派生类提供调用层的决策代码同一个函数接口的不同实现版本，从而保持对调用层代码逻辑无需变动,而且隐藏了同一个函数接口的不同版本的实现细节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> ReturnType <span class="title">FunctionName</span><span class="params">(Parameter)</span></span>;</span><br></pre></td></tr></table></figure><p>尽管C++编译器允许父类和子类中定义<strong>相同名称</strong>的非虚成员函数，但这是一种不良的设计，因为一个适当的函数名标识了它要实现某个具体的功能。当我们在多个类中要为不同的类实现某个具体功能的不同版本，就应该使用虚函数。</p><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>如果在基类中不能对虚函数给出有意义的实现，就会用到纯虚函数。其声明为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funtion1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。</p><p>友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。</p><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p>多继承(环状继承)，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&#123;</span>......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> A&#123;.....&#125;;</span><br></pre></td></tr></table></figure><p>这个菱形继承中，D 的成员变量和成员函数继承到类 A 中变成了两份，这样就可能会产生命名冲突。我们需要在冲突成员前指明它具体来自哪个类：<code>B::chengyuan</code>。</p><p>未解决多继承时的命名冲突和冗余数据问题，c++提出了虚继承，使得在派生类中只保留一份间接基类的成员。</p><p><code>class 类名: virtual 继承方式 父类名</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&#123;</span>......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> A&#123;.....&#125;;</span><br></pre></td></tr></table></figure><p>虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 D 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p><p>此外，如果虚基类的成员只被一条派生路径覆盖，那么仍然可以直接访问这个被覆盖的成员。但是如果该成员被两条或多条路径覆盖了，那就不能直接访问了，此时必须指明该成员属于哪个类。</p><p>假设 D 定义了一个名为 x 的成员变量，当我们在 A 中直接访问 x 时，会有三种可能性：</p><ul><li>如果 B 和 C 中都没有 x 的定义，那么 x 将被解析为 D 的成员，此时不存在二义性。</li><li>如果 B 或 C 其中的一个类定义了 x，也不会有二义性，派生类的 x 比虚基类的 x 优先级更高。</li><li>如果 B 和 C 中都定义了 x，那么直接访问 x 将产生二义性问题。</li></ul><p>可以看到，使用多继承经常会出现二义性问题，必须十分小心。也因此c++之后很多面向对象编程语言都不支持多继承。</p><p>C++标准库中的 iostream 类就是一个虚继承的实际应用案例。iostream 从 istream 和 ostream 直接继承而来，而 istream 和 ostream 又都继承自一个共同的名为 base_ios 的类，是典型的菱形继承。此时 istream 和 ostream 必须采用虚继承，否则将导致 iostream 类中保留两份 base_ios 类的成员。</p><h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p><img src="https://pic.imgdb.cn/item/60a0db976ae4f77d35ba3413.jpg"></p><p>首先，每个使用虚函数的类或从基类派生的虚函数的类都被赋予自己的虚表。该表只是C++编译器在<strong>编译时</strong>设置的<strong>静态数组</strong>。虚表包含当前类中所有虚成员函数的函数指针的相关条目，那么填入虚表的虚成员函数指针有四种来源：</p><ul><li><p>派生类本身原创定义的虚函数。</p></li><li><p>从父类继承的虚成员函数，且该函数未被派生类重写。</p></li><li><p>从父类继承的虚成员函数，但该函数已被派生类重写。需要注意的是，<strong>虚表的虚成员函数指针始终指向该类中的最新的派生版本的虚成员函数</strong>。也就是说重写后，派生类虚表中存的该函数的地址是重写后该函数在内存中的地址。</p></li><li><p>若当前类定义了虚析构函数，那么该类的虚析构函数的函数的地址会“成双成对”地填入虚表中。按照惯例,由于定义类时优先定义解构函数，再实现其他成员函数，因此该虚解构函数对的地址通常会出现在表中头两行。</p><p>为什么是两个函数？</p><ul><li>第一个析构函数，称为**完整对象析构函数(complete object destructor)**，执行销毁操作时无需在对象上调用delete()。</li><li>第二个解构函数称<strong>删除析构函数</strong>( deleting destructor)，在销毁对象后调用delete()。</li><li>两者都摧毁了任何虚拟基类。一个独立的非虚函数称为<strong>基类对象解构函数</strong>(base object destructor)，执行对象的销毁操作，但不执行其<strong>虚拟基类子对象</strong>的销毁操作，并且不调用delete()。</li></ul></li></ul><p>然后，当类对象实例化时，会将<code>*_vptr</code>设置为指向该类的虚表。</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>编译时，多态性是通过<strong>类成员函数重写</strong>和<strong>operator函数重载</strong>实现的。</p><p>运行时，多态性是通过使用继承和虚函数实现的。C++编译器在运行时，根据决策逻辑判断传入对象的类型，然后查找并根据该类虚表中的虚成员函数的地址，进行动态调度目标类中的成员函数。</p><h2 id="静态绑定-amp-动态绑定"><a href="#静态绑定-amp-动态绑定" class="headerlink" title="静态绑定 &amp; 动态绑定"></a>静态绑定 &amp; 动态绑定</h2><p><strong>绑定：</strong>是指将<strong>变量</strong>和<strong>函数名</strong>转换为地址的过程。</p><p><strong>静态绑定</strong>（前绑定）：在程序执行之前，程序编译阶段就确定的绑定。</p><ul><li>早期绑定意味着绑定的函数或者变量，该语句在编译阶段已经被编译成 <strong><code>call 函数地址</code></strong> 或 <strong><code>callq 函数地址</code></strong> 这样的汇编指令格式，并且这些汇编指令中的函数地址在程序编译后是固定不变的。</li><li>优点是效率高、编译器会帮你检查。非虚函数、静态函数都属于静态绑定。</li></ul><p><strong>动态绑定</strong>（后绑定）：是指在运行时才确定的函数调用。</p><ul><li>在一些带有决策性的业务逻辑的代码中，要等到用户的反馈，直到运行时，根据决策的结果才能知道将调用哪个函数。这称为后期绑定(或动态绑定)，动态绑定的技术的本源就是函数指针。在C ++中<strong>运行时多态</strong>正是使用的就是函数指针。</li><li>优点是不用申明类型，运行时方便修改。python 的动态语言特性（无需考虑变量类型）就是因为 Python 的解析器的底层就是用到了运行时的一系列<strong>类型检测</strong>和<strong>类型检测后的内存分配</strong>以及C的<strong>函数指针</strong>的<strong>间接调用</strong>等技术完成了对Python代码的解析和资源初始化，这一切是以低性能为代价的。</li></ul><p>C++编译器仅当遇到如下条件才会做动态绑定：</p><ul><li>通过类型指针,该指针是<code>upcast</code>操作的指针</li><li>该类型指针调用的是虚函数</li></ul><p>体现在汇编中，比如 <code>callq *%rdx</code>，就是调用寄存器中缓存的虚函数指针所指向的虚函数。而如果是静态绑定，那么就会是这样的汇编语句：<code>callq 0x401384</code> </p><h2 id="Upcasting-amp-downcasting"><a href="#Upcasting-amp-downcasting" class="headerlink" title="Upcasting &amp; downcasting"></a>Upcasting &amp; downcasting</h2><p>将派生类对象赋值给基类对象、将派生类指针赋值给基类指针、将派生类引用赋值给基类引用，这在 C++ 中称为向上转型（<code>Upcasting</code>）。向上转型无需强制类型转换，但会丢失精度。</p><p>所谓向下转型（<code>downcasting</code>），即父类对象转换为子类对象，需要类型转换。</p><p>强制类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// false</span></span><br><span class="line">Person p=<span class="keyword">new</span> <span class="built_in">Person</span>();</span><br><span class="line">Student stu=(Student)p;</span><br><span class="line"><span class="comment">// right</span></span><br><span class="line">Person p=<span class="keyword">new</span> <span class="built_in">Student</span>();</span><br><span class="line">Student stu=(Student)p; </span><br></pre></td></tr></table></figure><p>动态类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">destType* dstObj=<span class="keyword">dynamic_cast</span>&lt;destType*&gt;(src)</span><br></pre></td></tr></table></figure><p><code>dynamic_cast</code>是运行时处理的，运行时要进行运行时类型检查。转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。</p><p>如果要进行动态类型转换，基类中一定要有虚函数，因为运行时类型检查需要 “ <strong>运行时类型信息</strong>（<code>Runtime type information，RTTI</code>)”，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表。某些语言实现仅保留有限的类型信息，例如 [ 继承树 ] 信息，而某些实现会保留较多信息，例如对象的属性及方法信息。这确实增加了开销。但是RTTI可以确保进行类型转换(包含隐式转换和动态类型转换)之类的操作可以安全地进行。</p><p>如果运行时<code>src</code>和<code>destType</code>所引用的对象是相同类型，或者存在<code>is-a</code>关系(public继承)则转换成功；否则转换失败。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span>       </span><br><span class="line">    <span class="function">virtualvoid <span class="title">func</span><span class="params">()</span></span>&#123;&#125;           </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&#123;      </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;      </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Derived *pd = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    Base *pb = pd;</span><br><span class="line">Derived *pd2 = <span class="keyword">dynamic_cast</span>&lt;derived*&gt;(pb); <span class="comment">//向下转型，仍然有效地得到一个Derived类实例副本</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类的转换时，在类层次间进行上行转换时，<code>dynamic_cast</code>和<code>static_cast</code>的效果是一样的。在进行下行转换时，<code>dynamic_cast</code>具有类型检查的功能，比 <code>static_cast</code>更安全。</p><h2 id="内存原理"><a href="#内存原理" class="headerlink" title="内存原理"></a>内存原理</h2><p>首先，我们知道对于我们的自定义类型，如果我们没有重载<code>=</code>，是无法强制将一个类型对象类型转换并赋值给另一个类型的对象的。因为当我们尝试执行<code>a=b</code>，那么其实质就是调用了对象 a 的<code>operator=()</code>操作符函数，即等价于如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="keyword">operator</span>=(<span class="keyword">const</span> B &amp;b);</span><br></pre></td></tr></table></figure><p>而对于类实例的指针，我们是可以强制转换并赋值的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span><span class="keyword">int</span> i=<span class="number">1</span>;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span><span class="keyword">double</span> k=<span class="number">1.1</span>;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    A *p=&amp;a;</span><br><span class="line">    B *q=&amp;b;</span><br><span class="line">    p=(A*)q;<span class="comment">// 编译器允许</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若从大尺寸的类B强制类型转换类A，内存会将拷贝低地址位的内存数据，而丢弃高地址位的内存数据。若小尺寸到大尺寸转换，则源操作数的所有字节数据会按低地址到高地址的顺序依次拷贝到目标操作数，目标操作数超出源操作数尺寸的剩余高地址部分数据，编译器会以0填充。</p><p><strong>继承链</strong></p><p>继承动作的实质其实是：派生类通过继承得到类成员函数在内存中的地址。</p><p>父类公开或受保护的成员函数(包括虚函数)同样是被派生类继承，但继承的只是父类成员函数的<strong>调用权</strong>，在继承关系中，派生类从基类继承的成员函数实质上继承的是存储在代码段(<strong>Code Segment</strong>)内存区中，基类可共享的成员函数的内存地址，因为每个成员函数都有一个唯一的<strong>内存地址</strong>。</p><p>而所谓类型，其实就是规定这个类型的变量对哪部分内存拥有操作权限。</p><p>在继承中，派生类都从父类获得一份公开(public)或受保护(protected)的父类数据成员(属性)的副本，也就是说，每个派生类对象内部都持有一份“特殊版本”的父类实例的信息。所以父类类型指针，规定访问的是父类大小的内存区域，若我们将继承类实例化的对象赋给该指针，自然而然父类副本外的内存（即继承类的自定义部分）无法被父类指针访问。</p><p>因此，<code>Upcast</code>操作仅仅是拷贝了派生类中的基类实例副本，派生类所属的内存区域对于基类对象是一无所知的。这也产生了一个问题 —— “**对象切片(<code>Object Slicing</code>)**”，即当拷贝时，派生类原创的成员(属性和方法)会被编译器”阉割”掉。</p><p>在对象切片的作用下可能出现以下情况：</p><ul><li><p>对于非虚成员函数来说，基类对象只能得到基类原创定义且可被继承的成员函数的地址，派生类原创定义的成员函数的地址，对于 upcast 操作后的基类对象是不可见的。</p></li><li><p>对于虚成员函数来说，如下三种情况。对于基类对象运行时绑定哪个虚成员函数的地址，是依据填入基类的虚表的函数地址来判断的。</p><ul><li>若该函数是派生类原创定义的，对于upcast操作后的基类对象是不可见的。</li><li>若该函数是基类原创定义且未被派生类重写，对于 upcast 操作后的基类对象，该基类版本的虚函数可见。</li><li>若该函数是基类原创定义且已被派生类重写，对于 upcast 操作后的基类对象，该派生类版本的虚成员函数可见。</li></ul></li></ul><p><small>注：所谓内存访问限制，访存本身其实是没什么限制的，只是越界了会访问到无效数据而已（比如栈上的对象越界访问可能会访问到其他局部变量，堆上的对象越界访问可能会访问到堆块对齐的部分）编译器能做的只是从语法层面去限制生成越界的访存机器码，而不是防止访存的行为本身（即便编译器也能被骗过）</small></p><p>参考：<a href="https://zhuanlan.zhihu.com/p/192178632">https://zhuanlan.zhihu.com/p/192178632</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h1&gt;&lt;p&gt;继承可以重用代码功能和提高执行效率的效果。 &lt;/p&gt;
&lt;p&gt;一个类可以派生自多个类。类派生列表以一个或多个基类命名，形式如下：&lt;/p&gt;
&lt;f</summary>
      
    
    
    
    <category term="C++ 基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
    <category term="OOP" scheme="http://yoursite.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>「JVM」垃圾回收机制</title>
    <link href="http://yoursite.com/2021/05/14/Java/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2021/05/14/Java/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2021-05-14T02:44:17.000Z</published>
    <updated>2021-05-16T15:14:49.696Z</updated>
    
    <content type="html"><![CDATA[<p>与 C++ 程序设计语言相比，Java 程序设计语言拥有一个独特的语言特性——自动垃圾回收机制 (Garbage Collection)。在 Java 和 C++ 中，新创建一个对象都需要使用 <code>new</code> 运算符。然而，在 C++ 中，程序员需要人工管理内存，对于不再使用的对象使用 <code>delete</code> 运算符显式地回收内存；在 Java 中，程序员无需人工管理内存，JVM 会自动触发垃圾回收，将没有被引用的对象占据的内存空间释放。</p><h2 id="基本垃圾回收机制"><a href="#基本垃圾回收机制" class="headerlink" title="基本垃圾回收机制"></a>基本垃圾回收机制</h2><p>基本的 Java 垃圾回收机制如下：</p><p>首先，垃圾回收器会找出当前哪些对象是正在使用中的，并将其标记为存活对象；以及哪些对象是没有被引用的，并将其标记为未引用对象，这一步称为<strong>标记</strong> 。下图显示了一个标记前后的内存图的样式：</p><p><img src="https://oscimg.oschina.net/oscnet/1459c0fb17fd074a53898d29839ebfaf5ac.jpg" alt="img"></p><p>其次，垃圾回收器会将当前所有未引用对象删除，也就是上图中橙色的部分。</p><p><img src="https://oscimg.oschina.net/oscnet/e6c1fbbf3a3d2d31365d5b74ae5d111333b.jpg" alt="img"></p><p>最后，为了提升性能，在删除完未引用对象后，通常还会采取<strong>压缩</strong>操作，将内存中的存活对象放置在一起，以便后续能够更加高效快捷地分配新的对象。</p><p><img src="https://oscimg.oschina.net/oscnet/01b56829ee40fe72ebca25d554f1adcefce.jpg" alt="img"></p><h2 id="分代垃圾回收机制"><a href="#分代垃圾回收机制" class="headerlink" title="分代垃圾回收机制"></a>分代垃圾回收机制</h2><p>在实际的程序中，如果完全采用上面的基本垃圾回收机制，会导致垃圾回收非常低效，这是因为每一次垃圾回收都需要标记所有的对象并进行删除和压缩；垃圾回收的耗时与分配的对象数量成正相关的联系。</p><p>实际上，对一个程序运行过程中所有对象的存活时间进行统计，可以得到下面的图：</p><p><img src="https://oscimg.oschina.net/oscnet/711116febb97b1ca9f7d75dd6688b06dafe.jpg" alt="img"></p><p>横轴代表程序运行时间，纵轴代表分配的字节</p><p>从图中我们可以看出，大部分对象的存活时间都比较短(聚集在左侧)，存活的对象随着程序的运行逐渐减少，因此，利用对象存活时间的规律对内存中的对象进行分代，可以加快垃圾回收的效率。</p><p>JVM的分代将堆分为如下几个部分：</p><p><img src="https://oscimg.oschina.net/oscnet/805cb061ab8aa9b4f13c372855f13c8b854.jpg" alt="img"></p><p>图中红色部分和橙色部分为新生代，用来存储刚分配的对象和分配不久的对象；蓝色部分为老年代，用来存储存活了一定时期的对象；绿色部分为永久代，主要用来存放类和元数据的信息。</p><p>在 JVM 分代的设计下，垃圾回收被重新设计为如下过程：</p><p>首先，任何新分配的对象都存放于 <code>eden</code> 内存中，此时两个 <code>Survivor</code> 都是空的。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geqksgniujj315g0nk0vl.jpg" alt="image-20200513094116818"></p><p>当新分配的对象达到一定数量时，会将 <code>eden</code> 的空间填满，此时会触发**次垃圾回收(小型垃圾回收)**，我们称之为 <strong><code>MinorGC</code><strong>。具体地，<code>MinorGC</code> 采用的是</strong>标记-复制算法</strong>，首先对 <code>eden</code> 和 <code>FromSurvivorSpace</code> 中的对象进行标记，然后将存活对象复制到 <code>ToSurvivorSpace</code> 中去，随之清空 <code>eden</code> 和 <code>FromSurvivorSpace</code> 中的对象，并将 <code>FromSurvivorSpace</code> 和 <code>ToSurvivorSpace</code> 区域调换，如下图所示：</p><p><img src="https://oscimg.oschina.net/oscnet/bea90b63a47b9fdfae7a31fb3cd8595c894.jpg" alt="img"></p><p>在下一次的 <code>MinorGC</code> 时，会重复同样的操作，<code>Survivor</code> 区会再次发生交换：</p><p><img src="https://oscimg.oschina.net/oscnet/66c2ecf7a0fb11fdca60651c033bbac02d3.jpg" alt="img"></p><p>注意到：从 <code>eden</code> 区迁移到 <code>Survivor</code> 区的对象此时开始有年龄 <code>Age </code>的概念，这里的 <code>Age</code> 是用来表示对象的存活时间，每经过一次 <code>MinorGC</code>，对象的 <code>Age</code> 增加 <code>1</code>。</p><p>经过了一定次数的 <code>MinorGC</code> 后，有些对象的年龄会达到一定的阈值，图中示例为 <code>8</code>，此时这些年龄达到阈值的对象会被转移到老年区 <code>tenured</code> 中，表示为常使用的对象：</p><p><img src="https://oscimg.oschina.net/oscnet/a813815a4e8e6a3601c75ebfc2ae80d9dc7.jpg" alt="img"></p><p>对于老年代中的对象而言，未引用的对象不会在 <code>MinorGC</code> 中被回收，而是在**主垃圾回收 (大型垃圾回收)**，我们称之为 <strong><code>MajorGC</code></strong> 中被回收。</p><p><code>MinorGC</code> 的作用范围是新生代，<code>MajorGC</code> 的作用范围是老年代，<code>MinorGC</code> 发生的频率高，而 <code>MajorGC</code> 发生的频率则较低。老年代中的对象普遍比较稳定，通常会长期存在，所以变化不是特别频繁。<code>MajorGC</code> 采用的是<strong>标记-压缩算法</strong>，也就是上面提到的基本垃圾回收机制。</p><h2 id="代码模拟"><a href="#代码模拟" class="headerlink" title="代码模拟"></a>代码模拟</h2><p>以下是一个简单的垃圾回收机制模拟：</p><ul><li><code>MyObject</code><ul><li>模拟创建的对象</li></ul></li><li><code>MyHeap</code><ul><li>普通小顶堆</li></ul></li><li><code>JvmHeap</code><ul><li>JVM 中的堆，<code>eden</code>、<code>survivor</code>、<code>tenured </code> 均使用堆来实现，继承自<code>MyHeap</code>。</li></ul></li><li><code>MyJvm</code><ul><li>模拟的 JVM，负责管理堆、创建对象、删除对象引用和垃圾回收</li></ul></li><li><code>Main</code><ul><li>模拟程序的输入输出，输入方式为先输入指令名称，换行后再输入参数。</li><li>输入有以下几条指令：<ul><li><code>CreateObject</code> ：创建新的对象，换行后输入创建对象的个数</li><li><code>SetUnreferenced</code> ：将对象设置为未引用，换行后输入删除引用的对象id，用空格分隔</li><li><code>RemoveUnreferenced</code>：直接在堆中移除未引用的对象</li><li><code>MinorGC</code> ：小型垃圾回收</li><li><code>MajorGC</code> ：大型垃圾回收</li><li><code>SnapShot</code> ：查看当前 JVM 中堆的快照</li></ul></li></ul></li></ul><p><code>MyObject.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">MyObject</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> totalId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> <span class="keyword">boolean</span> referenced;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    MyObject() &#123;</span><br><span class="line">        id = totalId;<span class="comment">// 保证创建新对象的id不重复</span></span><br><span class="line">        totalId++;</span><br><span class="line">        referenced = <span class="keyword">true</span>;</span><br><span class="line">        age = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ assignable age;</span></span><br><span class="line"><span class="comment">      @ ensures age == newAge;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> newAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = newAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ ensures \result == age;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ ensures \result == id;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ assignable referenced;</span></span><br><span class="line"><span class="comment">      @ ensures referenced == newReferenced;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReferenced</span><span class="params">(<span class="keyword">boolean</span> newReferenced)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.referenced = newReferenced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ ensures \result == referenced;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function"><span class="keyword">boolean</span> <span class="title">getReferenced</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> referenced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires this == o;</span></span><br><span class="line"><span class="comment">      @ ensures \result == true;</span></span><br><span class="line"><span class="comment">      @ also</span></span><br><span class="line"><span class="comment">      @ requires this != o &amp;&amp; (o == null || !(o instanceof MyObject));</span></span><br><span class="line"><span class="comment">      @ ensures \result == false;</span></span><br><span class="line"><span class="comment">      @ also</span></span><br><span class="line"><span class="comment">      @ requires this != o &amp;&amp; o != null &amp;&amp; o instanceof MyObject;</span></span><br><span class="line"><span class="comment">      @ ensures \result == (id == (MyObject) o.getId() &amp;&amp;</span></span><br><span class="line"><span class="comment">      @         referenced == (MyObject) o.getReferenced() &amp;&amp;</span></span><br><span class="line"><span class="comment">      @         age == (MyObject) o.getAge());</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> MyObject)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        MyObject myObject = (MyObject) o;</span><br><span class="line">        <span class="keyword">return</span> id == myObject.getId() &amp;&amp; referenced == myObject.getReferenced()</span><br><span class="line">                &amp;&amp; age == myObject.getAge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(id, referenced, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires object != null;</span></span><br><span class="line"><span class="comment">      @ ensures ((age &lt; object.age) || (age == object.age &amp;&amp; id &lt; object.id)) ==&gt; (\result == -1);</span></span><br><span class="line"><span class="comment">      @ ensures ((age &gt; object.age) || (age == object.age &amp;&amp; id &gt;= object.id)) ==&gt; (\result == 1);</span></span><br><span class="line"><span class="comment">      @ also</span></span><br><span class="line"><span class="comment">      @ public exceptional_behavior</span></span><br><span class="line"><span class="comment">      @ requires object == null;</span></span><br><span class="line"><span class="comment">      @ signals (NullPointerException e) object == null;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(MyObject object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((age &lt; object.age) || (age == object.age &amp;&amp; id &lt; object.id)) &#123;</span><br><span class="line">        <span class="comment">// 年龄小的更小；年龄相同，则创建早的更小</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyHeap.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gcsimulation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHeap</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;<span class="comment">// 下标从1开始</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;   <span class="comment">// 初始划分的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;   <span class="comment">// 实际堆的大小</span></span><br><span class="line"></span><br><span class="line">    MyHeap(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        elementData = <span class="keyword">new</span> Object[capacity + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ ensures \result == size;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ ensures \result == elementData</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> Object[] getElementData() &#123;</span><br><span class="line">        <span class="keyword">return</span> elementData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires index &gt;= 1 &amp;&amp; index &lt;= getSize();</span></span><br><span class="line"><span class="comment">      @ assignable elementData;</span></span><br><span class="line"><span class="comment">      @ ensures (\forall int i; 1 &lt;= i &amp;&amp; i &lt;= getSize() &amp;&amp; i != index;</span></span><br><span class="line"><span class="comment">      @          \not_modified(elementData[i]));</span></span><br><span class="line"><span class="comment">      @ ensures elementData[index] == element;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="comment">// 置换 index 处数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElementData</span><span class="params">(<span class="keyword">int</span> index, T element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[index] = element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ assignable size;</span></span><br><span class="line"><span class="comment">      @ ensures size == 0;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="comment">// 清除堆的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires newSize &gt;= 0;</span></span><br><span class="line"><span class="comment">      @ assignable size;</span></span><br><span class="line"><span class="comment">      @ ensures size == newSize;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires indexA &gt;= 1 &amp;&amp; indexA &lt;= getSize() &amp;&amp; indexB &gt;= 1 &amp;&amp; indexB &lt;= getSize();</span></span><br><span class="line"><span class="comment">      @ assignable elementData;</span></span><br><span class="line"><span class="comment">      @ ensures (\forall int i; 1 &lt;= i &amp;&amp; i &lt;= getSize() &amp;&amp; i != indexA &amp;&amp; i != indexB;</span></span><br><span class="line"><span class="comment">      @          \not_modified(elementData[i]));</span></span><br><span class="line"><span class="comment">      @ ensures elementData[indexA] == \old(elementData[indexB]);</span></span><br><span class="line"><span class="comment">      @ ensures elementData[indexB] == \old(elementData[indexA]);</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> indexA, <span class="keyword">int</span> indexB)</span> </span>&#123;</span><br><span class="line">        T temp = (T) elementData[indexA];</span><br><span class="line">        elementData[indexA] = elementData[indexB];</span><br><span class="line">        elementData[indexB] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T newElement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">            Object[] oldElementData = elementData.clone();</span><br><span class="line">            <span class="comment">// 现有大小达到划分的容量，动态扩容</span></span><br><span class="line">            capacity = capacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            elementData = <span class="keyword">new</span> Object[capacity + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; i++) &#123;</span><br><span class="line">                elementData[i] = oldElementData[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        elementData[++size] = newElement;</span><br><span class="line">        <span class="keyword">int</span> tempIndex = size;</span><br><span class="line">        <span class="comment">// 将新添加元素向上调整，使其满足小顶堆性质（父节点大于子节点）</span></span><br><span class="line">        <span class="keyword">while</span> (tempIndex / <span class="number">2</span> != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                ((T) elementData[tempIndex]).compareTo((T) elementData[tempIndex / <span class="number">2</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(tempIndex, tempIndex / <span class="number">2</span>);</span><br><span class="line">            tempIndex /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;No element found in list.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除堆顶常规方法，将最后一个元素置换到堆顶，再一路往下调整满足堆结构</span></span><br><span class="line">        elementData[<span class="number">1</span>] = elementData[size--];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; size) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左右儿子都有，那么如果不满足小于两个儿子的小顶堆性质，要保证换到父节点的儿子小于另一个儿子</span></span><br><span class="line">            <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">1</span> &lt;= size) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((T) elementData[index]).compareTo((T) elementData[index * <span class="number">2</span>]) &gt; <span class="number">0</span> ||</span><br><span class="line">                        ((T) elementData[index]).compareTo((T) elementData[index * <span class="number">2</span> + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (((T) elementData[index * <span class="number">2</span> + <span class="number">1</span>]).compareTo(</span><br><span class="line">                            (T) elementData[index * <span class="number">2</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        swap(index * <span class="number">2</span>, index);</span><br><span class="line">                        index = <span class="number">2</span> * index;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        swap(index * <span class="number">2</span> + <span class="number">1</span>, index);</span><br><span class="line">                        index = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index * <span class="number">2</span> &lt;= size) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((T) elementData[index]).compareTo((T) elementData[index * <span class="number">2</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    swap(index * <span class="number">2</span>, index);</span><br><span class="line">                    index = <span class="number">2</span> * index;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JvmHeap.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gcsimulation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmHeap</span> <span class="keyword">extends</span> <span class="title">MyHeap</span>&lt;<span class="title">MyObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    JvmHeap(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传入要设置为未引用的 id list，将id在该list中的对象状态置为未引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUnreferencedId</span><span class="params">(List&lt;Integer&gt; objectId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> id : objectId) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="keyword">this</span>.getSize(); i++) &#123;</span><br><span class="line">                MyObject myObject = (MyObject) <span class="keyword">this</span>.getElementData()[i];</span><br><span class="line">                <span class="keyword">if</span> (myObject.getId() == id) &#123;</span><br><span class="line">                    myObject.setReferenced(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">this</span>.setElementData(i, myObject);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ assignable elementData, size;</span></span><br><span class="line"><span class="comment">      @ ensures size == (\sum int i; 1 &lt;= i &amp;&amp; i &lt;= \old(size) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @                              \old(elementData[i].getReferenced()) == true; 1);</span></span><br><span class="line"><span class="comment">      @ ensures (\forall int i; 1 &lt;= i &amp;&amp; i &lt;= \old(size);</span></span><br><span class="line"><span class="comment">      @          \old(elementData[i].getReferenced()) == true ==&gt;</span></span><br><span class="line"><span class="comment">      @           (\exist int j; 1 &lt;= j &amp;&amp; j &lt;= size; elementData[j].equals(\old(elementData[i]))))</span></span><br><span class="line"><span class="comment">      @ ensures (\forall int i; 1 &lt;= i &amp;&amp; i &lt;= \old(size);</span></span><br><span class="line"><span class="comment">      @          \old(elementData[i].getReferenced()) == false ==&gt;</span></span><br><span class="line"><span class="comment">      @           (\forall int j; 1 &lt;= j &amp;&amp; j &lt;= size;</span></span><br><span class="line"><span class="comment">      @           !elementData[j].equals(\old(elementData[i]))))</span></span><br><span class="line"><span class="comment">      @ ensures (\forall int i; 1 &lt;= i &amp;&amp; i &lt;= size;</span></span><br><span class="line"><span class="comment">      @          (\exists int j; 1 &lt;= j &amp;&amp; j &lt;= \old(size);</span></span><br><span class="line"><span class="comment">      @          elementData[i].equals(\old(elementData[j]))));</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="comment">// 移除 Jvm 堆中所有未标记的元素。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeUnreferenced</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可对原有的堆进行克隆，并通过 clear 方法将堆的 size 置为 0</span></span><br><span class="line">        Object[] oldElementData = <span class="keyword">this</span>.getElementData().clone();</span><br><span class="line">        <span class="keyword">int</span> oldSize = <span class="keyword">this</span>.getSize();</span><br><span class="line">        clear();</span><br><span class="line"><span class="comment">// 遍历原有的堆中的各个对象，调用 add 方法将其中已标记的对象加入至新堆中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= oldSize; i++) &#123;</span><br><span class="line">            MyObject myObject = (MyObject) oldElementData[i];</span><br><span class="line">            <span class="keyword">if</span> (myObject.getReferenced() == <span class="keyword">true</span>) &#123;</span><br><span class="line">                add(myObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires size &gt; 0;</span></span><br><span class="line"><span class="comment">      @ ensures (\exist int i; 1 &lt;= i &amp;&amp; i &lt;= size;</span></span><br><span class="line"><span class="comment">      @          (\forall int j; 1 &lt;= j &amp;&amp; j &lt;= size &amp;&amp; j != i;</span></span><br><span class="line"><span class="comment">      @            elementData[i].compareTo(elementData[j]) == -1) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @           \result == elementData[i]);</span></span><br><span class="line"><span class="comment">      @ also</span></span><br><span class="line"><span class="comment">      @ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires size == 0;</span></span><br><span class="line"><span class="comment">      @ ensures \result == null;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="comment">// 根据小顶堆性质，堆顶就是年龄最小的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function">MyObject <span class="title">getYoungestOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getSize() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (MyObject) getElementData()[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyJvm.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gcsimulation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJvm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_TENURING_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JvmHeap eden;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;JvmHeap&gt; survive = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fromSurviveSpace = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> JvmHeap tenured;</span><br><span class="line"></span><br><span class="line">    MyJvm() &#123;</span><br><span class="line">        eden = <span class="keyword">new</span> JvmHeap(DEFAULT_CAPACITY);</span><br><span class="line">        survive.add(<span class="keyword">new</span> JvmHeap(DEFAULT_CAPACITY));</span><br><span class="line">        survive.add(<span class="keyword">new</span> JvmHeap(DEFAULT_CAPACITY));</span><br><span class="line">        tenured = <span class="keyword">new</span> JvmHeap(DEFAULT_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createObject</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            MyObject newObject = <span class="keyword">new</span> MyObject();</span><br><span class="line">            eden.add(newObject);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (eden.getSize() == DEFAULT_CAPACITY) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Eden reaches its capacity,triggered Minor Garbage Collection.&quot;</span>);</span><br><span class="line">                <span class="comment">// 填满eden时，会触发小型垃圾回收机制</span></span><br><span class="line">                minorGC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUnreferenced</span><span class="params">(List&lt;Integer&gt; objectId)</span> </span>&#123;</span><br><span class="line">        eden.setUnreferencedId(objectId);</span><br><span class="line">        survive.get(fromSurviveSpace).setUnreferencedId(objectId);</span><br><span class="line">        tenured.setUnreferencedId(objectId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeUnreferenced</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        eden.removeUnreferenced();</span><br><span class="line">        survive.get(fromSurviveSpace).removeUnreferenced();</span><br><span class="line">        tenured.removeUnreferenced();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">minorGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Eden 中已标记的对象变为 1 岁并转移到 ToSurvivorSpace；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= eden.getSize(); i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) eden.getElementData()[i];</span><br><span class="line">            <span class="keyword">if</span> (!mo.getReferenced()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mo.setAge(mo.getAge() + <span class="number">1</span>);</span><br><span class="line">            survive.get(<span class="number">1</span> - fromSurviveSpace).add(mo);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// FromSurvivorSpace 中已标记的对象老一岁后，若未超过年龄阈值 8，则转移到 ToSurvivorSpace，反之转移到老年区 Tenured；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= survive.get(fromSurviveSpace).getSize(); i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) survive.get(fromSurviveSpace).getElementData()[i];</span><br><span class="line">            <span class="keyword">if</span> (!mo.getReferenced()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mo.setAge(mo.getAge() + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (mo.getAge() &gt; MAX_TENURING_THRESHOLD) &#123;</span><br><span class="line">                tenured.add(mo);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                survive.get(<span class="number">1</span> - fromSurviveSpace).add(mo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 清空 FromSurvivorSpace 和 Eden ，并交换 FromSurvivorSpace 与 ToSurvivorSpace。</span></span><br><span class="line">        eden.setSize(<span class="number">0</span>);</span><br><span class="line">        survive.get(fromSurviveSpace).setSize(<span class="number">0</span>);</span><br><span class="line">        fromSurviveSpace = <span class="number">1</span> - fromSurviveSpace;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">majorGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 拷贝老年区对象副本，清空老年区，将仍在引用状态的对象还回老年区中，相当于移除了未引用对象</span></span><br><span class="line">        Object[] oldElement = tenured.getElementData().clone();</span><br><span class="line">        <span class="keyword">int</span> oldSize = tenured.getSize();</span><br><span class="line">        tenured.setSize(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= oldSize; i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) oldElement[i];</span><br><span class="line">            <span class="keyword">if</span> (!mo.getReferenced()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tenured.add(mo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSnapShot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Eden: &quot;</span> + eden.getSize());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= eden.getSize(); i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) eden.getElementData()[i];</span><br><span class="line">            System.out.print(mo.getId() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Survive 0: &quot;</span> + survive.get(<span class="number">0</span>).getSize());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= survive.get(<span class="number">0</span>).getSize(); i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) survive.get(<span class="number">0</span>).getElementData()[i];</span><br><span class="line">            System.out.print(mo.getId() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MyObject youngestInSurvive0 = survive.get(<span class="number">0</span>).getYoungestOne();</span><br><span class="line">        <span class="keyword">if</span> (youngestInSurvive0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;, the youngest one &quot;</span> + youngestInSurvive0.getId() +</span><br><span class="line">                    <span class="string">&quot;&#x27;s age is &quot;</span> + youngestInSurvive0.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Survive 1: &quot;</span> + survive.get(<span class="number">1</span>).getSize());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= survive.get(<span class="number">1</span>).getSize(); i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) survive.get(<span class="number">1</span>).getElementData()[i];</span><br><span class="line">            System.out.print(mo.getId() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MyObject youngestInSurvive1 = survive.get(<span class="number">1</span>).getYoungestOne();</span><br><span class="line">        <span class="keyword">if</span> (youngestInSurvive1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;, the youngest one &quot;</span> + youngestInSurvive1.getId() +</span><br><span class="line">                    <span class="string">&quot;&#x27;s age is &quot;</span> + youngestInSurvive1.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Tenured: &quot;</span> + tenured.getSize());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tenured.getSize(); i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) tenured.getElementData()[i];</span><br><span class="line">            System.out.print(mo.getId() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MyObject youngestInTenured = tenured.getYoungestOne();</span><br><span class="line">        <span class="keyword">if</span> (youngestInTenured != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;, the youngest one &quot;</span> + youngestInTenured.getId() +</span><br><span class="line">                    <span class="string">&quot;&#x27;s age is &quot;</span> + youngestInTenured.getAge());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n---------------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Main.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gcsimulation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyJvm myJvm = <span class="keyword">new</span> MyJvm();</span><br><span class="line">        System.out.println(<span class="string">&quot;Start JVM Garbage Collection Simulation.&quot;</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String operation = scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (operation.equals(<span class="string">&quot;CreateObject&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = scanner.nextInt();</span><br><span class="line">                myJvm.createObject(count);</span><br><span class="line">                System.out.println(<span class="string">&quot;Create &quot;</span> + count + <span class="string">&quot; Objects.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">&quot;SetUnreferenced&quot;</span>)) &#123;</span><br><span class="line">                List&lt;Integer&gt; unrefList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span> (scanner.hasNextInt()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> id = scanner.nextInt();</span><br><span class="line">                    unrefList.add(id);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Set id: &quot;</span> + id + <span class="string">&quot; Unreferenced Object.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                myJvm.setUnreferenced(unrefList);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">&quot;RemoveUnreferenced&quot;</span>)) &#123;</span><br><span class="line">                myJvm.removeUnreferenced();</span><br><span class="line">                System.out.println(<span class="string">&quot;Remove Unreferenced Object.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">&quot;MinorGC&quot;</span>)) &#123;</span><br><span class="line">                myJvm.minorGC();</span><br><span class="line">                System.out.println(<span class="string">&quot;Execute Minor Garbage Collection.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">&quot;MajorGC&quot;</span>)) &#123;</span><br><span class="line">                myJvm.majorGC();</span><br><span class="line">                System.out.println(<span class="string">&quot;Execute Major Garbage Collection.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">&quot;SnapShot&quot;</span>)) &#123;</span><br><span class="line">                myJvm.getSnapShot();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Invalid operation.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;End of JVM Garbage Collection Simulation.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;与 C++ 程序设计语言相比，Java 程序设计语言拥有一个独特的语言特性——自动垃圾回收机制 (Garbage Collection)。在 Java 和 C++ 中，新创建一个对象都需要使用 &lt;code&gt;new&lt;/code&gt; 运算符。然而，在 C++ 中，程序员需要人工管</summary>
      
    
    
    
    <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>「C++ 基础」重载</title>
    <link href="http://yoursite.com/2021/05/08/cpp/3%20-%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2021/05/08/cpp/3%20-%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2021-05-08T01:00:15.000Z</published>
    <updated>2021-05-16T09:10:29.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><p>为方便使用，C++ 允许在同一个作用域内，声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，不能仅通过返回类型的不同来重载函数。 </p><p>当调用一个<strong>重载函数</strong>或<strong>重载运算符</strong>时，编译器通过把所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为<strong>重载决策</strong>。 </p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，不能仅通过返回类型的不同来重载函数。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">printData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;整数为: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>  f)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;浮点数为: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c[])</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字符串为: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   printData pd;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出整数</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="number">5</span>);</span><br><span class="line">   <span class="comment">// 输出浮点数</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="number">500.263</span>);</span><br><span class="line">   <span class="comment">// 输出字符串</span></span><br><span class="line">   <span class="keyword">char</span> c[] = <span class="string">&quot;Hello C++&quot;</span>;</span><br><span class="line">   pd.<span class="built_in">print</span>(c);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>允许程序使用表达式而不是命名函数，可以编写和阅读更容易。</p><p>重载函数的函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。 </p><p>将多个合法操作符连接也是合法的。如可以定义一个<code>operator **</code>来用于幂运算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp;);</span><br></pre></td></tr></table></figure><p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp;, <span class="keyword">const</span> Box&amp;);</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        Box box;</span><br><span class="line">        box.length = <span class="keyword">this</span>-&gt;length + b.length;</span><br><span class="line">        box.breadth = <span class="keyword">this</span>-&gt;breadth + b.breadth;</span><br><span class="line">        box.height = <span class="keyword">this</span>-&gt;height + b.height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> length;</span><br><span class="line">    <span class="keyword">double</span> breadth;</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Box3 = Box1 + Box2;</span><br><span class="line">    volume = Box3.<span class="built_in">getVolume</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Volume of Box3 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可重载的运算符列表：</p><table><thead><tr><th>双目算术运算符</th><th>+ (加)，-(减)，*(乘)，/(除)，% (取模)</th></tr></thead><tbody><tr><td>关系运算符</td><td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于)</td></tr><tr><td>逻辑运算符</td><td>||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td></tr><tr><td>单目运算符</td><td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td></tr><tr><td>自增自减运算符</td><td>++(自增)，–(自减)</td></tr><tr><td>位运算符</td><td>| (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td></tr><tr><td>赋值运算符</td><td>=, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=</td></tr><tr><td>空间申请与释放</td><td>new, delete, new[ ] , delete[]</td></tr><tr><td>其他运算符</td><td><code>()</code>(函数调用)，<code>-&gt;</code>(成员访问)，<code>,</code>(逗号)，<code>[]</code>(下标)</td></tr></tbody></table><p>不可重载的运算符列表：</p><ul><li><code>.</code>：成员访问运算符</li><li><code>.*</code>  <code>-&gt;*</code>：成员指针访问运算符</li><li><code>::</code>：域运算符</li><li><code>sizeof</code>：长度运算符</li><li><code>?:</code>：条件运算符</li><li><code>#</code>： 预处理符号</li></ul><h3 id="一元运算符重载"><a href="#一元运算符重载" class="headerlink" title="一元运算符重载"></a>一元运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Distance</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> feet;   <span class="comment">// 0 到无穷</span></span><br><span class="line">    <span class="keyword">int</span> inches; <span class="comment">// 0 到 12</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 所需的构造函数</span></span><br><span class="line">    <span class="built_in">Distance</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        feet = <span class="number">0</span>;</span><br><span class="line">        inches = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Distance</span>(<span class="keyword">int</span> f, <span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        feet = f;</span><br><span class="line">        inches = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 显示距离的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayDistance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;F: &quot;</span> &lt;&lt; feet &lt;&lt; <span class="string">&quot; I:&quot;</span> &lt;&lt; inches &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载负运算符（ - ）</span></span><br><span class="line">    Distance <span class="keyword">operator</span>-()</span><br><span class="line">    &#123;</span><br><span class="line">        feet = -feet;</span><br><span class="line">        inches = -inches;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Distance</span>(feet, inches);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Distance D1(11, 10), D2(-5, 11);</span><br><span class="line"></span><br><span class="line">    -D1;                  <span class="comment">// 取相反数</span></span><br><span class="line">    D1.<span class="built_in">displayDistance</span>(); <span class="comment">// 距离 D1</span></span><br><span class="line"></span><br><span class="line">    -D2;                  <span class="comment">// 取相反数</span></span><br><span class="line">    D2.<span class="built_in">displayDistance</span>(); <span class="comment">// 距离 D2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h3><p>上上例</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Distance</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> feet;   <span class="comment">// 0 到无穷</span></span><br><span class="line">    <span class="keyword">int</span> inches; <span class="comment">// 0 到 12</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 所需的构造函数</span></span><br><span class="line">    <span class="built_in">Distance</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        feet = <span class="number">0</span>;</span><br><span class="line">        inches = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Distance</span>(<span class="keyword">int</span> f, <span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        feet = f;</span><br><span class="line">        inches = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 显示距离的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayDistance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;F: &quot;</span> &lt;&lt; feet &lt;&lt; <span class="string">&quot; I:&quot;</span> &lt;&lt; inches &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载小于运算符（ &lt; ）</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Distance &amp;d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (feet &lt; d.feet)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (feet == d.feet &amp;&amp; inches &lt; d.inches)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Distance D1(11, 10), D2(5, 11);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (D1 &lt; D2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;D1 is less than D2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;D2 is less than D1 &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输入输出运算符重载"><a href="#输入输出运算符重载" class="headerlink" title="输入输出运算符重载"></a>输入输出运算符重载</h3><p> C++ 能够使用流提取运算符 &gt;&gt; 和流插入运算符 &lt;&lt; 来输入和输出内置的数据类型。 可以重载流提取运算符和流插入运算符来操作对象等用户自定义的数据类型。 </p><p><strong>注意：</strong> 我们需要把运算符重载函数声明为类的友元函数，这样我们就能不用创建对象而直接调用函数。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Distance</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> feet;   <span class="comment">// 0 到无穷</span></span><br><span class="line">    <span class="keyword">int</span> inches; <span class="comment">// 0 到 12</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 所需的构造函数</span></span><br><span class="line">    <span class="built_in">Distance</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        feet = <span class="number">0</span>;</span><br><span class="line">        inches = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Distance</span>(<span class="keyword">int</span> f, <span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        feet = f;</span><br><span class="line">        inches = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;output, <span class="keyword">const</span> Distance &amp;D)</span><br><span class="line">    &#123;</span><br><span class="line">        output &lt;&lt; <span class="string">&quot;F : &quot;</span> &lt;&lt; D.feet &lt;&lt; <span class="string">&quot; I : &quot;</span> &lt;&lt; D.inches;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;input, Distance &amp;D)</span><br><span class="line">    &#123;</span><br><span class="line">        input &gt;&gt; D.feet &gt;&gt; D.inches;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Distance D1(11, 10), D2(5, 11), D3;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the value of object : &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; D3;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;First Distance : &quot;</span> &lt;&lt; D1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Second Distance :&quot;</span> &lt;&lt; D2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Third Distance :&quot;</span> &lt;&lt; D3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;重载&quot;&gt;&lt;a href=&quot;#重载&quot; class=&quot;headerlink&quot; title=&quot;重载&quot;&gt;&lt;/a&gt;重载&lt;/h1&gt;&lt;p&gt;为方便使用，C++ 允许在同一个作用域内，声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，不能</summary>
      
    
    
    
    <category term="C++ 基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="重载" scheme="http://yoursite.com/tags/%E9%87%8D%E8%BD%BD/"/>
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>「OS」进程管理</title>
    <link href="http://yoursite.com/2021/05/06/OperatingSystem/OS-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2021/05/06/OperatingSystem/OS-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2021-05-06T09:14:23.530Z</published>
    <updated>2021-05-12T13:33:49.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>进程：</strong>为了揭示多道程序、分时系统引发的动态特性（执行-暂停 -执行），而引入了进程。定义可参看内存管理。<br><strong>并发：</strong>有两个活动a1和a2，如果在某一时刻t，无论它们是在同一处理机上还是在不同的处理机上执行，只要都处在各自的起点和终点之间的某一处，则称a1和a2是并发执行的。<br><strong>并行：</strong>两个程序在同一时间度量下同时运行在不同的处理机上，则称这两个程序是并行执行的<br><strong>竞争：</strong>多个进程在读写一个共享数据时结果依赖于它们执行的相对时间<br><strong>竞争条件：</strong>多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关，称为竞争（发生）条件。<br><strong>Bernstein条件：</strong>满足该条件，则程序并发执行结果可再现。该条件可简单理解为两个程序只可以同时读。</p><h2 id="进程与程序"><a href="#进程与程序" class="headerlink" title="进程与程序"></a>进程与程序</h2><ul><li><strong>进程是动态的，程序是静态的</strong>：程序是有序代码的集合；进程是程序的执行。通常进程不可在计算机之间迁移；而程序通常对应着文件，静态和可以复制。</li><li><strong>进程是暂时的，程序是永久的</strong>：进程是一个状态变化的过程，程序可长久保存。</li><li>进程与程序的<strong>对应关系</strong>：通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。</li></ul><h2 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h2><blockquote><p>由若干条指令所组成的指令序列，来实现某个特定的操作功能<br>原语是操作系统核心组成部分，必须在管态（内核态）下执行，且常驻内存。其指令序列的执行是连续的、不可分割的。</p></blockquote><h3 id="创建原语"><a href="#创建原语" class="headerlink" title="创建原语"></a>创建原语</h3><ul><li>fork<br>创建子进程。一次调用有两个返回值。<br>在fork函数执行完毕后，子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID，如果出现错误则返回负值。</li><li>exec<br>程序替换。<br>当子进程调用exec函数来运行另一个程序时，这个进程的地址空间代码和数据都被新程序的代码和数据刷新替换。<h3 id="撤销原语"><a href="#撤销原语" class="headerlink" title="撤销原语"></a>撤销原语</h3></li><li>kill<br>释放资源、撤销子进程、重新调度<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2></li></ul><p><strong>就绪状态</strong>：进程已获得除处理机外的所需资源，只要分配CPU就可执行。</p><p><strong>执行状态</strong>：占用处理机资源；处于此状态的进程的数目小于等于CPU的数目。在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的idle进程（相当于空操作）。</p><p><strong>阻塞状态</strong>：正在执行的进程，由于发生某种事件而暂时无法执行，便放弃处理机处于暂停状态。</p><p><img src="https://img.imgdb.cn/item/60914edfd1a9ae528ffe8e3e.png"></p><h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h2><p>进程控制的主要任务是<strong>创建</strong>和<strong>撤销</strong>进程，以及实现进程的<strong>状态转换</strong>。</p><p>系统为每个进程定义了一个数据结构：进程控制块<strong>PCB</strong>。在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>进程的创建与撤销。是进程的唯一标志。</p><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ul><li><strong>进程标识符</strong>：每个进程都必须有一个唯一的标识符。Linux系统中是一个整型数。 在进程创建时由系统赋予。</li><li><strong>现场保护区：</strong>进程阻塞释放CPU时，要将CPU的各种状态信息保存</li><li><strong>互斥与同步机制：</strong>用于实现进程间互斥、同步和通信所需的信号量等</li><li>程序和数据地址，当前状态，优先级，资源清单，链接字（指出该进程所在队列中下一个进程PCB的首地址）</li></ul><h3 id="组织方式"><a href="#组织方式" class="headerlink" title="组织方式"></a>组织方式</h3><ul><li>线性表</li></ul><p>不论进程的状态如何，将所有的PCB连续地存放在内存的系统区</p><ul><li>索引方式</li></ul><p>系统按照进程的状态分别建立就绪索引表、 阻塞索引表等</p><ul><li>链接表方式</li></ul><p>系统按照进程的状态将进程的 PCB 组成队列，从而形成就绪队列、阻塞队列、运行队列等。</p><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p><strong>进程上下文</strong>，即一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈上的内容。</p><p>当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。这些内容被保存在任务自己的堆栈中, 入栈工作完成后就把下一个将要运行的任务的当前状况从该任务的栈中重新装入CPU寄存器, 并跳转到下一个进程被中断时的PC，开始下一个任务的运行, 这一过程就是<code>context switch</code>。</p><p>而陷入/退出内核（模态切换 <code>Mode Switch</code>），是由中断、异常、Trap指令（系统调用）引起。系统调用涉及到进程从用户态到内核态的切换（<code>mode switch</code>），此时涉及到的切换主要是寄存器上下文的切换，和通常所说的进程上下文切换（<code>Process Context Switch</code>）不同，mode switch 的消耗相对要小很多。</p><p>注：处理器总处于以下状态中的一种：</p><ol><li>内核态，运行于进程上下文，内核代表进程运行于内核空间；</li><li>内核态，运行于中断上下文，内核代表硬件运行于内核空间；</li><li>用户态，运行于用户空间。</li></ol><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><blockquote><p>线程（<code>thread</code>）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。<br>现代操作系统将资源拥有者称为进程，将可执行单元称为线程。</p></blockquote><h2 id="进程-amp-线程"><a href="#进程-amp-线程" class="headerlink" title="进程 &amp; 线程"></a>进程 &amp; 线程</h2><ul><li>线程间共享相同的地址空间，方便共享资源（也有栈、PC 等私有资源）。而进程地址空间相互独立，同步需要借助消息通信机制。</li><li>进程切换涉及虚拟地址空间的切换而线程不会，有效减少切换造成的开销。</li><li>进程创建/撤销时需要分配/回收大量资源，线程更轻量，开销更少</li><li>多线程并发度更高<h2 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h2><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3></li></ul><blockquote><p><code>User level threads(ULT)</code>，线程在用户空间，是通过 library 模拟的 thread，不需要或仅需要极少的 kernel 支持。由用户程序自行调用、调度和维护。</p></blockquote><p>典型的有：</p><ul><li><code>POSIX Pthreads</code><br>用于线程创建和同步的 POSIX 标准API , 可在用户级或者内核级实现。该 API 规定了线程库的行为，但不限定实现方法，在类 UNIX 系统（Solaris, Linux, Mac OS X）中很常见。</li><li><code>Java Threads</code></li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>线程的创建、撤消和调度不需要OS内核的支持，是在语言或用户库这一级处理，容易进行优化</li><li>可运行在任何操作系统上，只需要线程库的支持<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>用户级线程执行系统调用指令时将导致其所属进程被中断，内核会因此而阻塞所有相关的线程。</li><li>内核只能将处理器分配给进程，即使有多个处理器，也无法实现一个进程中的多个线程的并行执行。<h3 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h3><blockquote><p><code>Kernel level threads (KLT)</code>，kernel 有好几个分身, 一个分身可以处理一件事。支持内核线程的操作系统内核称作<strong>多线程内核</strong></p></blockquote><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4></li><li>CPU调度以线程为单位，由OS的线程调度程序负责线程的调度。内核可以在多个处理器上调度一个进程的多个线程实现同步并行执行</li><li>系统调用导致的阻塞只发生在线程级别</li><li>内核中的一些处理可以通过多线程实现<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4></li><li>一个进程中的线程切换需要内核参与，线程的切换涉及到两个模式的切换（进程-进程、线程-线程）</li><li>效率降低<h3 id="混合的线程实现方式"><a href="#混合的线程实现方式" class="headerlink" title="混合的线程实现方式"></a>混合的线程实现方式</h3><blockquote><p>线程在用户空间创建和管理，实现从用户空间线程到内核空间线程的映射</p></blockquote><h4 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h4>实现用户级线程和内核级线程的连接方式</li><li>Many-to-One Model<br>多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。</li><li>One-to-one Model<br>每个用户级线程映射到一个内核级线程。并发能力较强，但对应用程序性能影响大</li><li>Many-to-Many Model<br>n 个用户级线程映射到 m 个内核级线程上（m $\le$ n）<h1 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2></li></ul><p><strong>临界资源：</strong>一次仅允许一个进程访问的资源</p><p><strong>临界区：</strong>每个进程中访问临界资源的那段代码称为临界区</p><p><strong>进程互斥：</strong>两个或两个以上的进程，不能同时进入关于同一组共享资源的临界区，否则可能发生与时间有关的错误</p><p><strong>进程同步：</strong>系统中各进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性的过程。让本来异步并发的进程相互配合，有序推进。</p><h2 id="临界区管理"><a href="#临界区管理" class="headerlink" title="临界区管理"></a>临界区管理</h2><p><strong>空闲让进：</strong>临界资源处于空闲状态，允许进程进入临界区。临界区内仅有一个进程运行。<br><strong>忙则等待：</strong>临界区有正在执行的进程，所有其他进程则不可以进入临界区。<br><strong>有限等待：</strong>对要求访问临界区的进程，应保证在有限时间内进入自己的临界区，避免死等。<br><strong>让权等待：</strong>当进程（长时间）不能进入自己的临界区时，应立即释放处理机，尽量避免忙等。</p><h2 id="基于信号量的同步与互斥"><a href="#基于信号量的同步与互斥" class="headerlink" title="基于信号量的同步与互斥"></a>基于信号量的同步与互斥</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><blockquote><p>一个确定的二元组(s, q)，其中s是一个具有非负初值的整型变量，q是一个初始状态为空的队列程序。对其访问都是原子操作，且只允许对它进行P(信号变量)和V(信号变量)操作。它用来累计唤醒次数，由 Dijkstra 提出。</p></blockquote><p><strong>semWait 操作（P操作）</strong>：</p><ul><li>使信号量减1。若值为负，则执行 semWait 的进程被阻塞。否则进程继续执行。</li><li>有进程被阻塞时就会进入 q 队列</li></ul><p><strong>semSignal操作（V操作）</strong></p><ul><li>使信号量加1。若值小于或等于零，则被semWait操作阻塞的进程被解除阻塞。<br>PV 操作简单但不安全，使用不当会出现死锁。</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>二元信号量：取值仅为“0”或“1”，主要用作实现互斥。</li><li>一般信号量：初值为可用物理资源的总数，用于进程间的协作同步问题。</li></ul><h3 id="在并发中的应用"><a href="#在并发中的应用" class="headerlink" title="在并发中的应用"></a>在并发中的应用</h3><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>常使用二元信号量的PV操作实现两个进程的互斥。<br>信号量初值为 1，⼀个进程在进⼊临界区之前执⾏semWait操作，退出临界区后再执⾏⼀个semSignal操作。</p><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>想要先执行<code>code1 &amp; code2</code>，再执行<code>code 4</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>; <span class="comment">// 同步信号量初值为 0</span></span><br><span class="line"><span class="built_in">p1</span>() &#123;</span><br><span class="line">    code <span class="number">1</span>;</span><br><span class="line">    code <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">V</span>(S);</span><br><span class="line">    code <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">p2</span>() &#123;</span><br><span class="line">    <span class="built_in">P</span>(S);</span><br><span class="line">    code <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前驱关系"><a href="#前驱关系" class="headerlink" title="前驱关系"></a>前驱关系</h4><p>在”前操作”之后对相应同步变量执行 V 操作</p><p>在”后操作”之前对相应的同步变量执行 P 操作</p><p>例如：<code>S1-&gt;S2, S1-&gt;S3</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">semaphore a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">p1() &#123;</span><br><span class="line">...</span><br><span class="line">S1;</span><br><span class="line">V(a);</span><br><span class="line">V(b);</span><br><span class="line">&#125;</span><br><span class="line">p2() &#123;</span><br><span class="line">...</span><br><span class="line">P(a);</span><br><span class="line">S2;</span><br><span class="line">&#125;</span><br><span class="line">p3() &#123;</span><br><span class="line">...</span><br><span class="line">P(b);</span><br><span class="line">S3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有限并发"><a href="#有限并发" class="headerlink" title="有限并发"></a>有限并发</h4><p>指有n（1≤n≤c，c是⼀个常量）个进程并发执⾏⼀个函数或者⼀个资源。⼀个初始值为c 的信号量可以实现这种并发。</p><h3 id="信号量集机制"><a href="#信号量集机制" class="headerlink" title="信号量集机制"></a>信号量集机制</h3><p>信号量集是指同时需要多个资源时的信号量操作</p><h4 id="AND-型"><a href="#AND-型" class="headerlink" title="AND 型"></a>AND 型</h4><p>将进程需要的所有共享资源一次全部分配给它；待该进程使用完后再一起释放。</p><h4 id="一般型"><a href="#一般型" class="headerlink" title="一般型"></a>一般型</h4><p>进程对信号量$S_i$的测试值为$t_i$（用于信号量的判断，即$S_i &gt;= t_i$，资源数量低于ti时，便不予分配），占用值为 $d_i$（用于信 号量的增减，即$S_i = S_i - d_i$ 和 $S_i = S_i + d_i$ ）</p><h2 id="基于管程的同步与互斥"><a href="#基于管程的同步与互斥" class="headerlink" title="基于管程的同步与互斥"></a>基于管程的同步与互斥</h2><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><blockquote><p>管程是一种高级同步机制，由四部分组成：1. 管程的名称；2. 局部于管程内部的共享数据结构（变量）说明  3. 对该数据结构进行操作的一组互斥执行的过程；4. 对局部于管程内部的共享数据设置初始值的语句</p></blockquote><p><strong>条件变量：</strong>为了区别等待的不同原因，管程引入了条件变量。不同的条件变量，对应不同原因的进程阻塞等待队列，初始时为空。若条件变量名为X，则调用同步原语的形式为<code>wait(X)</code>和<code>signal(X)</code>。</p><p><strong>与信号量区别：</strong></p><ul><li>条件变量的值不可增减，P-V操作的信号量值可增减</li><li>wait操作一定会阻塞当前进程；但P操作只有当信号量的值小于0时才会阻塞。</li><li>如果没有等待的进程，signal将丢失；而V操作增加了信号量的值，不会丢失。</li><li>访问条件变量必须拥有管程的锁<h3 id="Hoare-管程"><a href="#Hoare-管程" class="headerlink" title="Hoare 管程"></a>Hoare 管程</h3></li></ul><p><strong>入口等待队列</strong>：因为管程是互斥进入的，所以当一个进程试图进入一个已被占用的管程时它应当在管程的入口处等待，因而在管程的入口处应当有一个进程等待队列，称作入口等待队列。<br><strong>紧急等待队列</strong>：如果进程Ｐ唤醒进程Ｑ，则Ｐ等待Ｑ继续；Ｑ执行完又唤醒进程Ｒ，则Ｑ等待Ｒ继续，… 如此，在管程内部，由于执行唤醒操作，可能会出现多个等待进程（已被唤醒，但由于管程的互斥进入而等待），这个管程内部的等待队列被称为紧急等待队列，其优先级高于入口等待队列。</p><h4 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h4><ul><li><code>x.wait()</code><br>如果紧急等待队列非空，则唤醒第一个等待者；否则释放管程的使用权，执行此操作的进程排入x队列尾部（紧急等待队列与x队列的关系：紧急等待队列是由于管程的互斥进入而等待的队列，而x队列是因资源被占用而等待的队列）</li><li><code>x.signal()</code><br>如果x队列为空，则相当于空操作，执行此操作的进程继续；否则唤醒第一个等待者，执行<code>x.signal()</code>操作的进程排入紧急等待队列的<h4 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h4></li><li>mutex 用与互斥<br>初值为 1，进程退出管程时应执行V(mutex)开放管程，以便让其他调用者进入。为了使进程在等待资源期间，其他进程能进入管程， 故在wait操作中也必须执行V(mutex)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P(mutex);        &#x2F;&#x2F; 管程入口</span><br><span class="line">…</span><br><span class="line">Body of F</span><br><span class="line">…</span><br><span class="line">If(next_count &gt; 0)</span><br><span class="line">V(next);</span><br><span class="line">Else</span><br><span class="line">V(mutex);        &#x2F;&#x2F; 管程出口    </span><br></pre></td></tr></table></figure></li><li>next 初值为 0<br>凡发出si gnal操作的进程应该用P(next)挂起自己，直到被释放进程退出管程或产生其他等待条件。<br>进程在退出管程的过程前，须检查是否有别的进程在信号量next上等待，若有，则用V(next)唤醒它。next-count（初值为0），用来记录在next上等待的进程个数</li><li>x-sem 初值为 0<br>申请资源得不到满足时，执行P(x-sem)挂起。由于释放资源时，需要知道是否有别的进程在等待资源，用计数器x-count（初值<br>为0）记录等待资源的进程数。<br>执行signal操作时，应让等待资源的诸进程中的某个进程立即恢复运行，而不让其他进程抢先进入管程，这可以用V(x-se m)来实现<h2 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信 IPC"></a>进程间通信 IPC</h2></li></ul><p><strong>低级通信：</strong>只能传递状态和整数值（控制信息），包括进程互斥和同步所采用的信号量和管程机制。<br><strong>高级通信：</strong>适用于分布式系统，基于共享内存的多处理机系统，单处理机系统，能够传送任意数量的数据，可以解决进程的同步问题和通信问题，主要包括三类：管道、共享内存、消息系统。</p><h3 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h3><ul><li>数据只能向一个方向流动；写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。需要双方通信时，需要建立起两个管道；</li><li>只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）</li><li>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，不属于某种文件系统，而是单独构成一种文件系统，并且只存在于内存中。<h3 id="Named-Pipe-FIFO"><a href="#Named-Pipe-FIFO" class="headerlink" title="Named Pipe / FIFO"></a>Named Pipe / FIFO</h3></li><li>克服了”只能用于具有亲缘关系的进程间通信”的限制</li><li>它提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中。这样，只要可以访问该路径，就能够彼此通过FIFO 相互通信<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3>共享内存是指：同一块物理内存被映射到进程A、B各自的进程地址空间。</li><li>共享内存是最有用的进程间通信方式，也是最快的IPC形式（因为它避免了其它形式的IPC必须执行的开销巨大的缓冲复制）。<ul><li>当多个进程共享同一块内存区域，需要同步机制约束（互斥锁和信号量都可以）。<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3>通过两个通信原语（OS系统调用）:    </li></ul></li><li><code>send (destination, &amp;message)</code></li><li><code>receive(source, &amp;message)</code><h2 id="经典进程互斥与同步问题"><a href="#经典进程互斥与同步问题" class="headerlink" title="经典进程互斥与同步问题"></a>经典进程互斥与同步问题</h2><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3></li></ul><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区取出一个产品并使用。</p><p>producer :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">生产一个产品</span><br><span class="line">    <span class="built_in">P</span>(empty);</span><br><span class="line">    <span class="built_in">P</span>(mutex);</span><br><span class="line">    one &gt;&gt; buffer</span><br><span class="line">    <span class="built_in">V</span>(mutex);</span><br><span class="line">    <span class="built_in">V</span>(full);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>consumer : </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">P</span>(full);</span><br><span class="line">    <span class="built_in">P</span>(mutex);</span><br><span class="line">    one &lt;&lt; buffer</span><br><span class="line">    <span class="built_in">V</span>(mutex);</span><br><span class="line">    <span class="built_in">V</span>(empty);</span><br><span class="line">    使用产品;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>P 操作的互换可能会导致死锁（缓冲区无产品，且先执行 consumer；缓冲区满，producer阻塞）</p><p><strong>多生产者-多消费者</strong></p><p>不同类别的生产者生产的物品不同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">// 实现互斥访问盘子（缓冲区）</span></span><br><span class="line">semaphore apple = <span class="number">0</span>;<span class="comment">// 盘子中有几个苹果</span></span><br><span class="line">semaphore orange = <span class="number">0</span>;<span class="comment">// 盘子中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>;<span class="comment">// 盘子中还可以放多少水果</span></span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/609bbe12d1a9ae528f9bd01c.jpg"></p><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><p>对共享资源的读写操作，任一时刻“写者 ”最多只允许一个，而“读者”则允许多个。即”读写互斥”和”写写互斥”。</p><p>为了不令读进程之间也互斥，而读进 程与写进程又必须互斥访问，那么我们可以让第一个访问文件的读进程“加锁”，让最后一个访问完文件的读进程“解锁”。可以设置一个整数量 count 来记录当前有几个读进程在访问文件。</p><p><strong>读进程优先：</strong></p><p><img src="https://pic.imgdb.cn/item/609bd615d1a9ae528f5f909d.jpg"></p><p><strong>读写公平：</strong></p><p><img src="https://pic.imgdb.cn/item/609bd65dd1a9ae528f61e44a.jpg"></p><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>5个哲学家围绕一张圆桌而坐，桌子上放着5支筷子，每两个哲学家之间放一支；哲学家的动作包括思考和进餐，进餐时需要同时拿起他左边和右边的两支筷子，思考时则同时将两支筷子放回原处。如果筷子已在其他人手上，则需要等待。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>（破除资源互斥） 至多只允许四个哲学家同时（尝试）进餐,以保证至少有一个哲学家能够进餐,最终总会释放出他所使用过的两支筷子,从而可使更多的哲学家进餐。设置信号量room=4。</li><li>（破除资源互斥）对筷子进行编号，每个哲学家按编号从低到高拿起筷子。或者对哲学家编号，奇数号哲学家先拿左，再拿右；偶数号相反。</li><li>（破除保持等待）同时拿起两根筷子，否则不拿起。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//互斥地取筷子  </span></span><br><span class="line"><span class="built_in">Pi</span>()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">P</span>(mutex);  </span><br><span class="line">        <span class="built_in">P</span>(chopstick[i]);  </span><br><span class="line">        <span class="built_in">P</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">//拿右  </span></span><br><span class="line">        <span class="built_in">V</span>(mutex);  </span><br><span class="line">        吃饭  </span><br><span class="line">        <span class="built_in">V</span>(chopstick [i]);  </span><br><span class="line">        <span class="built_in">V</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">//放右  </span></span><br><span class="line">        思考</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h</summary>
      
    
    
    
    <category term="OperatingSystem" scheme="http://yoursite.com/categories/OperatingSystem/"/>
    
    
    <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>「OS」内存管理</title>
    <link href="http://yoursite.com/2021/05/03/OperatingSystem/OS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2021/05/03/OperatingSystem/OS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-05-03T10:07:00.000Z</published>
    <updated>2021-05-06T09:56:54.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>地址空间</strong>：一个进程能够用于访问内存的地址集合</p><p><strong>程序</strong>：是静止的，存放在磁盘上的可执行文件，是进程的实体。</p><p><strong>进程</strong>：是动态的，包括进程控制块 PCB，程序和程序处理对象（数据集），是一个程序的执行过程，是资源分配的基本单位。通常把进程分为系统进程和用户进程。</p><p><strong>作业</strong>：用户需要计算机完成的某项任务，是要求计算机所做工作的集合。通常包括程序、数据、操作说明书。</p><p><strong>系统碎片：</strong>内存中无法被利用的存储空间称为碎片</p><p><strong>内部碎片</strong>：分配给作业的存储空间中未被利用的部分</p><p><strong>外部碎片</strong>：系统中无法利用的小的空闲分区，如分区与分区之间存在的碎片。这是造成内存系统性能下降的主要原因，它可以通过<strong>紧凑技术</strong>等被整理后清除。</p><p><strong>紧凑技术：</strong>通过移动作业，把多个分散的小分区拼接成一个大分区。</p><ul><li>时机：找不到足够大的空闲分区，但总空闲分区容量满足要求。</li><li>实现支撑：<strong>动态重定位</strong></li></ul><h1 id="存储管理的功能"><a href="#存储管理的功能" class="headerlink" title="存储管理的功能"></a>存储管理的功能</h1><ul><li>存储分配和回收</li><li>地址变换<br>  可执行文件生成中的链接技术、程序加载时的重定位技术、进程运行时硬件和软件的地址变换技术</li><li>存储共享和保护</li><li>存储器扩充</li></ul><h1 id="分区式内存管理"><a href="#分区式内存管理" class="headerlink" title="分区式内存管理"></a>分区式内存管理</h1><h2 id="分区式分配"><a href="#分区式分配" class="headerlink" title="分区式分配"></a>分区式分配</h2><p>把内存分为大小相等或不等的分区，每个应用程序占用一个或几个分区。</p><h3 id="固定式分区"><a href="#固定式分区" class="headerlink" title="固定式分区"></a>固定式分区</h3><p>系统初始化时，内存划分为若干固定大小（不一定相等）的连续分区。程序适应分区。</p><ul><li>易于实现</li><li>但内碎片会造成浪费，并且分区总数固定，限制了并发执行的程序数目</li><li>采用分区表来记录分区大小和使用情况</li></ul><h3 id="可变式分区"><a href="#可变式分区" class="headerlink" title="可变式分区"></a>可变式分区</h3><p>分区边界可移动</p><ul><li>没有内碎片，但会有外碎片</li></ul><h2 id="闲置空间的管理"><a href="#闲置空间的管理" class="headerlink" title="闲置空间的管理"></a>闲置空间的管理</h2><p>跟踪内存使用情况的方法有：<strong>位图表示法</strong>和<strong>链表表示法</strong></p><h3 id="位图表示法"><a href="#位图表示法" class="headerlink" title="位图表示法"></a>位图表示法</h3><p>给每个分配单元赋予一个二进制数位,用来记录该分配单元是否闲置</p><ul><li>空间开销固定，时间开销低，但没有容错能力。</li></ul><h3 id="链表表示法"><a href="#链表表示法" class="headerlink" title="链表表示法"></a>链表表示法</h3><p>将分配单元按照是否闲置链接起来。</p><ul><li>有一定的容错能力：链表有被占空间和闲置空间的表项，可以相互验证</li></ul><h2 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h2><h3 id="基于顺序搜索"><a href="#基于顺序搜索" class="headerlink" title="基于顺序搜索"></a>基于顺序搜索</h3><h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><p>每个空闲区按其在内存中地址递增的顺序连在一起，在为作业分配存储区域时，从空闲区域链的始端开始查找，选第一个满足请求的空白块。</p><ul><li>导致空闲碎片集中在低地址区</li></ul><h4 id="下次适应算法"><a href="#下次适应算法" class="headerlink" title="下次适应算法"></a>下次适应算法</h4><p>将所有空闲区组织成一个循环链表，每次为存储请求查找合适分区时，总是从上次查找结束的地方开始</p><ul><li>可能会导致缺乏大的空闲分区</li></ul><h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><p>寻找大小最接近作业要求的存储区域</p><ul><li>产生许多难以利用的小空闲碎片</li></ul><h4 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h4><p>总是寻找最大的空闲区</p><ul><li>缺乏大的空闲分区</li></ul><h3 id="基于索引搜索"><a href="#基于索引搜索" class="headerlink" title="基于索引搜索"></a>基于索引搜索</h3><p>比顺序搜索快，一般用于大中型系统</p><h4 id="快速适应算法"><a href="#快速适应算法" class="headerlink" title="快速适应算法"></a>快速适应算法</h4><p>把空闲分区按容量大小进行分类，常用大小的空闲区设立单独的空闲区链表。系统为多个空闲链表设立一张管理索引表。</p><h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>介于固定分区与可变分区之间的动态分区技术。规定：无论已分配分区或空闲分区，其大小均为$2^k(k\in int)$</p><p>目前应用于 Linux 系统和多处理机系统。</p><p><strong>伙伴</strong>：在分配存储块时将一个大的存储块分裂成两个大小相等的小块，这两个小块称为”伙伴”。</p><p><strong>分配流程：</strong><br>当一个长度为 n 的进程申请内存，若$2^{i-1}&lt;n&lt;2^i$，则在空闲分区大小为$2^i$的空闲分区链表中查找<br>若该长度空闲分区耗尽，则查找大小为$2^{i+1}$的一个空闲分区，将其分为相等的两个分区，一个用于分配，一个加入大小为$2^{i}$的空闲链表中。以此向上类推。</p><p><strong>内存释放：</strong>考虑将被释放块与其伙伴和并成一个大的空闲块，然后继续合并直至不能合并为止。</p><h2 id="分区的存储保护"><a href="#分区的存储保护" class="headerlink" title="分区的存储保护"></a>分区的存储保护</h2><h3 id="界限寄存器法"><a href="#界限寄存器法" class="headerlink" title="界限寄存器法"></a>界限寄存器法</h3><ul><li>上下界寄存器<br>对于一个地址，将其与上界寄存器和下界寄存器比较，如果越界就报告地址错误</li><li>基址、限长寄存器<h3 id="存储保护键法"><a href="#存储保护键法" class="headerlink" title="存储保护键法"></a>存储保护键法</h3>给每个存储块赋予一个单独保护键，相当于一把锁；进入系统的每个作业也赋予一个保护键，相当于一把钥匙。<h2 id="内存扩充"><a href="#内存扩充" class="headerlink" title="内存扩充"></a>内存扩充</h2></li></ul><p><strong>覆盖</strong>与<strong>交换</strong>可以解决小的内存空间运行大的作业的问题。(现代 OS 主要用交换）</p><h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><p>把一个程序划分为一系列功能相对独立的程序段，让执行时不要求同时装入内存的程序段组成一组（称为覆盖段），共享主存的同一个区域。</p><p>一般要求作业各模块之间有明确的调用结构，程序员向系统指明覆盖结构，由 os 自动完成覆盖。</p><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>把暂时不用的进程（等待 I/O）及其数据从主存移至辅存，把指定程序或数据从辅存读入主存，让其在系统中运行。</p><p>交换时，需要：1. 保存前一个进程的现场，寄存器 &amp; 堆栈等。2. 创建新进程的运行现场</p><ul><li>覆盖可以减少单个程序运行所需的空间，交换可以减少多个程序同时占用的内存。</li></ul><h1 id="分页式存储管理"><a href="#分页式存储管理" class="headerlink" title="分页式存储管理"></a>分页式存储管理</h1><p>把一个逻辑地址连续的程序分散存放到若干不连续的内存区域内。既可充分利用内存空间，也可减少移动带来的开销。</p><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>页</strong>：把每个作业的地址空间分成一些大小相等的片，称之为页面。</p><p><strong>存储块/页框</strong>：把物理内存的存储空间也分成和页面大小相同的片。</p><p><strong>页表：</strong>存放在内存中，记录进程的内存分配情况，实现进程运行时的动态重定位。</p><p><strong>纯分页系统：</strong>不具备页面对换功能的分页存储管理方式。在调度一个作业时，必须把它的所有页一次装到主存的页框内。若页框数不足，则作业必须等待。</p><p><strong>地址结构：</strong></p><ul><li>逻辑地址：<code>31~页号~12|11~页内偏移~0</code></li><li>物理地址：<code>21~块号~12|11~块内偏移~0</code></li></ul><p><strong>有效内存访问时间：</strong>（对一级页表）<br>$$<br>EAT=(单次内存访问时间+TLB 查询时间)\times TLB 命中率+(2\times 单次内存访问时间+TLB 查询时间)\times(1-TLB 命中率)<br>$$</p><h2 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h2><p>逻辑地址：把相对地址分为页号和页内地址两部分。<br>页表定位：页表始址＋页号 x 页表项长度。<br>查询页表：读出块号。<br>物理地址：块号＋块内地址。（块内地址＝页内地址）</p><h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><p>由于一级页表在划分页面数很多时会导致页表项很多，占用内存多，因此需要多级页表来实现页表分级，从而实现动态调入页表。</p><h3 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h3><p>将页表再进行分页，离散地将各个页表页面存放在不同的物理块中，同时再建立一张外部页表（即<strong>页目录</strong>）用于记录页表页面对应的物理块号。<br>正在运行的进程需要把页目录调入内存，然后将当前所需的二级页表调入内存，其余二级页表待需要时再调入。</p><h2 id="快表-TLB"><a href="#快表-TLB" class="headerlink" title="快表 TLB"></a>快表 TLB</h2><p>页表机制导致内存访问效率下降。不分页时获取数据只需访存 1 次，而一级页表需要访存 2 次，二级页表需要访存 3 次。</p><p>快表是一种特殊的高速缓冲存储器（Cache），内容是页表中的一部分或全部内容。CPU 产生逻辑地址的页号，首先在快表中寻找，若命中就找出其对应的物理块；若未命中，再到页表中找其对应的物理块，并将相应的页表项复制到快表。若快表中内容满，则按某种算法淘汰某些页。</p><p><img src="https://img.imgdb.cn/item/60911bffd1a9ae528ffe47d1.png"></p><h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><ul><li>有的 TLB 在每个 TLB 表项中还保存有 ASID（ASID 可用来唯一标识进程），这样 TLB 就可以同时包含多个进程的条目。否则每当进程切换时，TLB 就需要被 flushed，因为不同的进程虚拟地址空间相同，不冲刷可能会导致解析为其他进程的虚拟页。</li></ul><h2 id="页目录自映射"><a href="#页目录自映射" class="headerlink" title="页目录自映射"></a>页目录自映射</h2><h2 id="哈希页表"><a href="#哈希页表" class="headerlink" title="哈希页表"></a>哈希页表</h2><h2 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h2><h2 id="页共享与保护"><a href="#页共享与保护" class="headerlink" title="页共享与保护"></a>页共享与保护</h2><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>各进程把需要共享的数据/程序的相应页指向相同物理块<br>但如果共享数据与不共享数据在同一块中，不易保密。而事实上也很难只把共享数据与非共享数据隔离，因为”数据共享”是程序处理逻辑层面的需求。</p><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><ul><li>地址越界保护 </li><li>在页表中设置保护位（定义操作权限：只读、读写、执行等）</li></ul><h1 id="段式内存管理"><a href="#段式内存管理" class="headerlink" title="段式内存管理"></a>段式内存管理</h1><p>一个段可定义为一组逻辑信息，每个作业的地址空间是由一些分段构成的。每个段都有自己的段名（一般为段号）且是一段连续的地址空间，其大小不定。</p><p><strong>段表：</strong>保存在内存中，记录了段与内存位置的对应关系。</p><p><strong>地址结构：</strong>逻辑地址由段和段内地址组成。</p><h2 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h2><p>多用户同时使用一个程序时，我们可以将代码共享而将数据分别保存，这要求代码是可重入的。<br><strong>可重入代码：</strong>也称纯代码，是指在多次并发调用时能安全运行的代码。(不能使用全局/静态变量，不能修改代码本身，不能调用其他不可重入代码）</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li>段是逻辑单位，易于实现信息共享与保护</li><li>能够更好的支持动态的内存需求（如编译器、动态链接）<br>缺点：</li><li>辅存中管理不定长度的分段比较困难<h2 id="地址空间的一维与二维"><a href="#地址空间的一维与二维" class="headerlink" title="地址空间的一维与二维"></a>地址空间的一维与二维</h2></li></ul><p>段式存储管理的作业地址空间是二维的，页式存储管理的作业地址空间是一维的。</p><p>因为段号是程序员自己定义的，要想找到某个数据或指令，需要指定段号和位移两个变量，因此是二维的。而页号是系统自动生成的，本身地址是线性连续的，当要访问特定地址时，只需要提供地址即可。系统会自动将地址划分为页号和页内位移，页号对于程序员来说是没有实际意义的，因此是一维的。</p><h1 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h1><p>将用户程序分为若干段，再将每个段分成若干页。</p><p><strong>地址结构：</strong>段号+段内页号+页内偏移量。因此访问一次数据或指令需访问内存 3 次。</p><h2 id="段表与页表"><a href="#段表与页表" class="headerlink" title="段表与页表"></a>段表与页表</h2><p>每个进程有一张段表，每个段有一张页表。<br>段表包含段号、页表始址和页表长度（每个段的页面数不同）。页表包含页号和页框号。</p><h2 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h2><ul><li>首先从 PCB 中取出段表始址和段表长度，装入段表寄存器。</li><li>利用段表始址与段号得到该段表项在段表中的位置，取出该段的页表始址和页表长度</li><li>利用页表始址和页号得到该页表项在页表中的位置。</li><li>取出该页的物理块号，与页内地址拼接得到物理地址<br>（段表长度和页表长度用于发现并产生越界中断）<h2 id="Intel-X86"><a href="#Intel-X86" class="headerlink" title="Intel X86"></a>Intel X86</h2>X86 的地址映射机制分为：</li><li>段映射机制：将逻辑地址映射到线性地址</li><li>页映射机制：将先行地址映射到物理地址</li></ul><h1 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h1><p>覆盖与交换技术虽部分解决了扩大存储空间的问题，但引入了很多额外的开销。引起这些问题的主要原因是一个作业必须存放在一个连续的内存中。</p><p>虚拟内存是计算机系统存储管理的一种技术，它为每个进程提供了一个一致的、连续完整的私有地址空间。采用虚拟存储技术的操作系统只需将当前所需执行的部分页或段读入内存，将内存与外存统一管理，达到扩充内存的目的。局部性原理使得这一技术有了良好的支撑。</p><h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="进程的逻辑空间"><a href="#进程的逻辑空间" class="headerlink" title="进程的逻辑空间"></a>进程的逻辑空间</h3><p>一个进程的逻辑空间的建立是通过链接器（Linker），将构成进程所需要的所有程序及运行所需环境，按照某种规则装配链接而形成的一种规范格式（布局），按字节从0开始编址。也称为进程的虚拟地址空间。</p><h3 id="交换分区"><a href="#交换分区" class="headerlink" title="交换分区"></a>交换分区</h3><p>交换分区是一段连续的磁盘空间（按页划分的），对用户不可见。它的功能是在物理内存不够的情况下，操作系统把内存中暂时不用的数据，存到硬盘的交换空间，留出物理内存让别的程序运行。<br>在 Linux系统中，交换分区为<code>Swap</code>；在 Windows系统中则以文件的形式存在（<code>pagefile.sys</code>）</p><h2 id="虚拟页式存储管理"><a href="#虚拟页式存储管理" class="headerlink" title="虚拟页式存储管理"></a>虚拟页式存储管理</h2><p>需要在页表中增加：驻留位（标识该页在内存中还是外存中）、外存地址。</p><h3 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h3><p>若从页表中查出该页的信息不在主存而在磁盘上时，发生缺页中断。缺页中断流程如下：</p><ol><li>现场保护：陷入内核态，保存必要的信息（OS及用户进程状态相关的信息）</li><li>页面定位：查找出发生缺页中断的虚拟页面（进程地址空间中的页面）。这个虚拟页面的信息通常会保存在一个硬件寄存器中，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析该指令，通过分析找出发生页面中断的虚拟页面。</li><li>权限检查：检查虚拟地址的有效性及安全保护位。如果发生保护错误，则杀死该进程</li><li>新页面调入 1 ：查找一个空闲的页框（物理内存中的页面），如果没有空闲页框则需要通过页面置换算法找到一个需要换出的页框</li><li>旧页面写回：如果找到的页框中的内容被修改了，则需要将修改的内容保存到磁盘上。（注：此时需要将页框置为忙状态，以防页框被其它进程抢占掉）</li><li>新页面调入 2 ：页框“干净”后，操作系统将保持在磁盘上的页面内容复制到该页框中</li><li>更新页表：当磁盘中的页面内容全部装入页框后，向CPU发送一个中断。操作系统更新内存中的页表项，将虚拟页面映的页框号更新为写入的页框，并将页框标记为正常状态</li><li>恢复现场：恢复缺页中断发生前的状态，将 PC 重新指向引起缺页中断的指令，继续执行</li></ol><h3 id="页面调度策略"><a href="#页面调度策略" class="headerlink" title="页面调度策略"></a>页面调度策略</h3><p>虚拟存储器系统通常定义三种策略来规定如何进行页面调度：调入策略、置页策略和置换策略。</p><h4 id="调入策略"><a href="#调入策略" class="headerlink" title="调入策略"></a>调入策略</h4><p>调入策略决定什么时候将一个页由外存调入内存之中。</p><h5 id="请求调页（demand-paging）"><a href="#请求调页（demand-paging）" class="headerlink" title="请求调页（demand paging）"></a>请求调页（demand paging）</h5><p>只调入发生缺页时所需的页面。这种调入策略实现简单，但容易产生较多的缺页中断，造成对外存I/O次数多，时间开销过大，容易产生抖动现象。</p><h5 id="预调页（prepaging）"><a href="#预调页（prepaging）" class="headerlink" title="预调页（prepaging）"></a>预调页（prepaging）</h5><p>在发生缺页需要调入某页时，一次调入该页以及相邻的几个页。这种策略提高了调页的I/O效率，减少了I/O次数。但由于这是一种基于局部性原理的预测，若调入的页在以后很少被访问，则造成浪费。这种方式常在程序装入时使用。</p><h4 id="置页策略"><a href="#置页策略" class="headerlink" title="置页策略"></a>置页策略</h4><p>当线程产生缺页中断时，内存管理器还必须确定将调入的虚拟页放在物理内存的何处。用于确定最佳位置的一组规则称为“<strong>置页策略</strong>”。<br>选择页框应使CPU内存高速缓存不必要的震荡最小。</p><h4 id="置换策略"><a href="#置换策略" class="headerlink" title="置换策略"></a>置换策略</h4><p>如果缺页中断发生时物理内存已满，“置换策略”被用于确定哪个虚页面必须从内存中移出，为新的页面腾出空位，即调整驻留集的大小。</p><h5 id="固定分配局部置换"><a href="#固定分配局部置换" class="headerlink" title="固定分配局部置换"></a>固定分配局部置换</h5><p>为每一进程分配固定的页数的内存空间，在整个运行期间都不再改变。如果进程在运行中出现缺页，则只能从该进程的N个页面中选出一个换出，再调入一页，以保证分配给该进程的内存空间不变。</p><h5 id="可变分配全局置换"><a href="#可变分配全局置换" class="headerlink" title="可变分配全局置换"></a>可变分配全局置换</h5><p>先为系统中的每一进程分配一定数量的物理块，操作系统本身也保持一个空闲物理块队列。当某进程发生缺页时，由系统的空闲物理块队列中取出一物理块分配给该进程。但当空闲物理块队列中的物理块用完时，操作系统才从内存中选择一块调出。该块可能是系统中任意一个进程的页。</p><h5 id="可变分配局部置换"><a href="#可变分配局部置换" class="headerlink" title="可变分配局部置换"></a>可变分配局部置换</h5><p>为每一进程分配一定数目的内存空间。如果进程在运行的过程中，频繁地发生缺页中断，则系统再为该进程分配若干物理块，直到进程的缺页率降低到适当程度为止。</p><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>当主存空间已被装满而又需调入新页，就需要根据算法将已在主存中的一些页淘汰</p><ul><li>最优置换 OPT</li></ul><p>置换掉未来最久不被使用的页。但它需要页面访问序列的先验知识，是无法实现的。通常用于比较性研究。</p><ul><li>先进先出 FIFO</li></ul><p>置换最久的页。性能差，可能会出现 Belady 异常。<br>注：Belady 异常：随着分配的页框增多，缺页率反而上升。</p><ul><li>second chance</li></ul><p>如果被淘汰的页之前被访问过，则给其第二次机会。每个页面会增加一个访问标志位，用于标识此数据装入内存后是否被再次访问过。</p><ul><li> clock</li></ul><p>改进的 second chance。将数据组织成环形队列。</p><p>1）如果没有缺页错误，将所访问页的访问位置1，指针不动；</p><p>2）如果产生缺页错误：</p><p>如果当前页面的访问位是 1 ，首先将当前页面的访问位置0，将指针向前移一个位置；重复这个过程，直到找到访问位为0的页面，然后转下一步。</p><p>如果当前页面的访问位是 0 ，替换当前页面，并将其访问位置为1，并将指针向前移动一个位置。</p><h4 id="页面清除策略"><a href="#页面清除策略" class="headerlink" title="页面清除策略"></a>页面清除策略</h4><p>页面清除策略决定系统何时把被置换页面写回外存。<br>当正在执行的进程发生缺页中断时，需要阻塞，并等待一个页面的写出和另一个页面的读入，这可能降低处理机的使用效率。<br>一种有效的页面清除策略是结合<strong>页缓冲</strong>（<code>Page Buffering</code>）技术。当发生缺页中断时，不必首先写出置换页，而是将被选中的置换页暂时保留在内存的一个缓冲区，在以后某个合适的时候将被置换页批量写出到外存，减少磁盘I/0的次数，提高处理机的效率。</p><h5 id="最近最少使用-LRU"><a href="#最近最少使用-LRU" class="headerlink" title="最近最少使用 LRU"></a>最近最少使用 LRU</h5><p>是局部性原理的合理近似，性能接近 OPT，但需要记录页面使用的先后关系，实现开销大。</p><h5 id="工作集算法"><a href="#工作集算法" class="headerlink" title="工作集算法"></a>工作集算法</h5><p><strong>工作集</strong>：进程运行正在使用的页面的集合。它会逐渐稳定。</p><p><strong>驻留集</strong>：每个进程驻留在内存的页面集合。</p><p>本算法选择不在工作集中的页面进行替换。</p><h3 id="抖动问题"><a href="#抖动问题" class="headerlink" title="抖动问题"></a>抖动问题</h3><p>随着驻留内存的进程数目增加，即进程并发程度的提高，处理器利用率先上升，然后下降。<br>这里下降的原因通常称为虚拟存储器发生“抖动”，每个进程的驻留集不断减小，当驻留集小于工作集后，缺页率急剧上升，频繁调页使得调页开销增大。<br>因此，OS要选择一个适当的进程数目，以在并发水平和缺页率之间达到一个平衡。</p><h4 id="抖动的消除与预防"><a href="#抖动的消除与预防" class="headerlink" title="抖动的消除与预防"></a>抖动的消除与预防</h4><p><strong>局部置换策略：</strong>如果一个进程出现抖动，它不能从另外的进程那里夺取内存块，从而不会引发其他进程出现抖动，使抖动局限于一个小的范围内</p><p><strong>挂起若干进程：</strong>挂起一个或几个进程，以便腾出内存空间供抖动进程使用，从而消除抖动现象</p><p><strong>引入工作集算法</strong></p><p><strong>预留部分页面</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;地址空间&lt;/strong&gt;：一个进程能够用于访问内存的地址集合&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序&lt;/str</summary>
      
    
    
    
    <category term="OperatingSystem" scheme="http://yoursite.com/categories/OperatingSystem/"/>
    
    
    <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>「C++ 基础」类 &amp; 对象</title>
    <link href="http://yoursite.com/2021/05/01/cpp/1%20-%20%E7%B1%BB%20&amp;%20%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2021/05/01/cpp/1%20-%20%E7%B1%BB%20&amp;%20%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-05-01T01:00:15.000Z</published>
    <updated>2021-05-16T09:35:54.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类-amp-对象"><a href="#类-amp-对象" class="headerlink" title="类 &amp; 对象"></a>类 &amp; 对象</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><table><thead><tr><th align="left">概念</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">类成员函数</td><td align="left">类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。</td></tr><tr><td align="left">类访问修饰符</td><td align="left">类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。</td></tr><tr><td align="left">构造函数 &amp; 析构函数</td><td align="left">类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。</td></tr><tr><td align="left">C++ 拷贝构造函数</td><td align="left">拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。</td></tr><tr><td align="left">C++ 友元函数</td><td align="left"><strong>友元函数</strong>可以访问类的 private 和 protected 成员。</td></tr><tr><td align="left">C++ 内联函数</td><td align="left">通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。</td></tr><tr><td align="left">C++ 中的 this 指针</td><td align="left">每个对象都有一个特殊的指针 <strong>this</strong>，它指向对象本身。</td></tr><tr><td align="left">C++ 中指向类的指针</td><td align="left">指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。</td></tr><tr><td align="left">C++ 类的静态成员</td><td align="left">类的数据成员和函数成员都可以被声明为静态的。</td></tr></tbody></table><h2 id="与-struct-区别"><a href="#与-struct-区别" class="headerlink" title="与 struct 区别"></a>与 struct 区别</h2><ol><li>成员的默认访问权限不同 ：class 默认 private，struct 默认 public</li><li>class 可以用在模板中代替 typename，struct 不能。</li></ol><p>可以看到区别很小 ，c++保留 struct 更多是为了兼容 C。但是语义上一般倾向于把struct当作C时代的struct来用，即只有成员变量，没有逻辑（或只有极其简单的数据存入读取逻辑），用来把多个变量打包成一个类型，而不用struct来做面向对象编程意义上的class。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。</p><h2 id="类成员函数"><a href="#类成员函数" class="headerlink" title="类成员函数"></a>类成员函数</h2><p>成员函数可以定义在类定义内部，或者单独使用<strong>范围解析运算符</strong><code>::</code>来定义。在类定义中定义的成员函数把函数声明为内联的，即便没有使用 inline 标识符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="comment">//  ...</span></span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以在类的外部使用范围解析运算符<code>::</code>定义该函数，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">double</span> length;         <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;        <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> height;         <span class="comment">// 高度</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 成员函数声明</span></span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 成员函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Box::getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类访问修饰符"><a href="#类访问修饰符" class="headerlink" title="类访问修饰符"></a>类访问修饰符</h2><p>数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记 <strong>public、private、protected</strong> 来指定的。</p><p>每个标记区域在下一个标记区域开始之前都是有效的。成员和类的默认访问修饰符是 private。</p><h3 id="公有成员"><a href="#公有成员" class="headerlink" title="公有成员"></a>公有成员</h3><p><strong>公有</strong>成员在类的外部可访问。</p><h3 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h3><p><strong>私有</strong>成员变量或函数在类的外部不可访问，只有类和友元函数可以访问私有成员。 </p><h3 id="保护成员"><a href="#保护成员" class="headerlink" title="保护成员"></a>保护成员</h3><p><strong>保护</strong>成员变量或函数可被派生类中的任何成员函数访问。除此外和私有成员相同。</p><h2 id="类构造函数-amp-析构函数"><a href="#类构造函数-amp-析构函数" class="headerlink" title="类构造函数 &amp; 析构函数"></a>类构造函数 &amp; 析构函数</h2><p>类的<strong>构造函数</strong>是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。</p><p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">( <span class="keyword">double</span> len )</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">      <span class="built_in">Line</span>(<span class="keyword">double</span> len);  <span class="comment">// 这是构造函数</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Line::<span class="built_in">Line</span>( <span class="keyword">double</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Line <span class="title">line</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用初始化列表来初始化字段"><a href="#使用初始化列表来初始化字段" class="headerlink" title="使用初始化列表来初始化字段"></a>使用初始化列表来初始化字段</h3><p>假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化 ，可以：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C::<span class="built_in">C</span>( <span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c): <span class="built_in">X</span>(a), <span class="built_in">Y</span>(b), <span class="built_in">Z</span>(c)<span class="comment">// 最好要按照变量在类声明的顺序一致</span></span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复制控制"><a href="#复制控制" class="headerlink" title="复制控制"></a>复制控制</h2><p>除了成员函数、构造函数定义了类型的对象的操作，类还可以通过特殊的成员函数（复制构造函数、赋值操作符、析构函数）来控制<strong>复制</strong>、<strong>赋值</strong>或<strong>撤销</strong>该类型对象时会发生什么。</p><h3 id="类的析构函数"><a href="#类的析构函数" class="headerlink" title="类的析构函数"></a>类的析构函数</h3><p>类的<strong>析构函数</strong>会在每次删除所创建的对象时执行。当对象的引用或指针超出作用域时，不会运行析构函数。只有删除指向动态分配对象的指针或实际对象超出作用域时，才会执行析构函数。</p><p>一般而言，如果需要析构函数，那么也需要赋值操作符和复制构造函数。</p><p>析构函数的名称与类的名称相同，在前面加<code>~</code>作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">( <span class="keyword">double</span> len )</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">      <span class="built_in">Line</span>();   <span class="comment">// 这是构造函数声明</span></span><br><span class="line">      ~<span class="built_in">Line</span>();  <span class="comment">// 这是析构函数声明</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;</span><br><span class="line">&#125;;</span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being created&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Line::~<span class="built_in">Line</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>拷贝构造函数通常用于： </p><ul><li>通过使用另一个同类型的对象来初始化新创建的对象。</li><li>复制对象把它作为参数传递给函数。</li><li>复制对象，并从函数返回这个对象。</li></ul><p>编译器会默认定义拷贝构造函数。如果类带有指针变量，或者有动态内存分配，则它必须有一个拷贝构造函数。</p><p>因为默认的拷贝构造函数实现的是浅拷贝，即直接将原对象的数据成员值依次复制给新对象中对应的数据成员，并没有为新对象另外分配内存资源。这样，如果对象的数据成员是指针，两个指针对象实际上指向的是同一块内存空间，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。</p><p>所以我们就必须定义一个深拷贝构造函数，为新的对象分配单独的内存资源。</p><p>拷贝构造函数的最常见形式如下： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">classname</span> (<span class="keyword">const</span> classname &amp;obj) &#123;<span class="comment">// obj 是一个对象引用，该对象是用于初始化另一个对象的。</span></span><br><span class="line">   <span class="comment">// 构造函数的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        a = b;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;creat: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">const</span> CExample &amp;C)</span><br><span class="line">    &#123;</span><br><span class="line">        a = C.a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">CExample</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;delete: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数，传入的是对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_Fun</span><span class="params">(CExample C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CExample <span class="title">test</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//传入对象</span></span><br><span class="line">    <span class="built_in">g_Fun</span>(test);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何防止默认拷贝发生</strong></p><p>声明一个私有的拷贝构造函数，这样因为拷贝构造函数是私有的，如果用户试图按值传递或函数返回该类的对象，编译器会报告错误，从而可以避免按值传递或返回对象。</p><p>当出现类的等号赋值时，会调用拷贝函数</p><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>友元机制允许一个类将对其非公有成员的访问权授予指定函数或类。友元不是授予友元关系那个类的成员，所以它们不受其声明出现部分的访问控制影响。</p><p>友元可以是一个函数，该函数被称为友元函数；也可以是一个类，称为友元类，在这种情况下，整个类及其所有成员都是友元。</p><p>如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 <strong>friend</strong></p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> width;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printWidth</span><span class="params">(Box box)</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BigBox</span>;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">double</span> wid)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigBox</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> width, Box &amp;box)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// BigBox是Box的友元类，它可以直接访问Box类的任何成员</span></span><br><span class="line">        box.<span class="built_in">setWidth</span>(width);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注意：printWidth() 不是任何类的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printWidth</span><span class="params">(Box box)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Box box;</span><br><span class="line">    BigBox big;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用成员函数设置宽度</span></span><br><span class="line">    box.<span class="built_in">setWidth</span>(<span class="number">10.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用友元函数输出宽度</span></span><br><span class="line">    <span class="built_in">printWidth</span>(box);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用友元类中的方法设置宽度</span></span><br><span class="line">    big.<span class="built_in">Print</span>(<span class="number">20</span>, box);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>友元声明将已命名的类或非成员函数引入外围作用域中。此外友元函数可以在类内部定义，该函数的作用域扩展到包围该类定义的作用域。</p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>由于一般调用函数需要许多工作：保存寄存器，复制实参，跳转到入口地址，返回时恢复寄存器等等。</p><p>内联函数可以避免函数调用时的开销。在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。函数名前面放置关键字 <strong>inline</strong>就可定义为内联函数。</p><p>对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。</p><p>一般而言，内联机制适用于优化比较小的、经常被调用的函数。绝大多数编译器不支持递归函数的内联。</p><p>在类定义中的定义的函数都是内联函数。</p><h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><p>每一个对象都能通过 <strong>this</strong> 指针来访问自己的地址。<strong>this</strong> 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">Volume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(Box box)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">Volume</span>() &gt; box.<span class="built_in">Volume</span>();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="指向类的指针"><a href="#指向类的指针" class="headerlink" title="指向类的指针"></a>指向类的指针</h2><p>一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 **<code>-&gt;</code>**，就像访问指向结构的指针一样。与所有的指针一样，必须在使用指针之前对指针进行初始化。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">Volume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Box <span class="title">Box1</span><span class="params">(<span class="number">3.3</span>, <span class="number">1.2</span>, <span class="number">1.5</span>)</span></span>;    <span class="comment">// Declare box1</span></span><br><span class="line">   Box *ptrBox;                <span class="comment">// Declare pointer to a class.</span></span><br><span class="line">   ptrBox = &amp;Box1;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Volume of Box1: &quot;</span> &lt;&lt; ptrBox-&gt;<span class="built_in">Volume</span>() &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 <strong>::</strong> 来重新声明静态变量从而对它进行初始化 </p><p>静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义，实际上是给静态成员变量分配内存。如果不加定义就会报错，初始化是赋一个初始值，而定义是分配内存。 </p><ul><li>常量变量：必须通过构造函数参数列表进行初始化。</li><li>引用变量：必须通过构造函数参数列表进行初始化。</li><li>普通静态变量：要在类外通过”::”初始化。</li><li>静态整型常量：可以直接在定义的时候初始化。</li><li>静态非整型常量：不能直接在定义的时候初始化。要在类外通过”::”初始化。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span> objectCount;</span><br><span class="line">      <span class="comment">// 构造函数定义</span></span><br><span class="line">      <span class="built_in">Box</span>(<span class="keyword">double</span> l=<span class="number">2.0</span>, <span class="keyword">double</span> b=<span class="number">2.0</span>, <span class="keyword">double</span> h=<span class="number">2.0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         objectCount++;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 初始化类 Box 的静态成员</span></span><br><span class="line"><span class="keyword">int</span> Box::objectCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，<strong>静态函数</strong>只要使用类名加范围解析运算符 <strong>::</strong> 就可以访问。 </p><p>静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。 </p><p>静态成员函数有一个类范围，他们不能访问类的 this 指针。可以使用静态成员函数来判断类的某些对象是否已被创建。 </p><p><strong>静态成员函数与普通成员函数的区别：</strong></p><ul><li>静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</li><li>普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类-amp-对象&quot;&gt;&lt;a href=&quot;#类-amp-对象&quot; class=&quot;headerlink&quot; title=&quot;类 &amp;amp; 对象&quot;&gt;&lt;/a&gt;类 &amp;amp; 对象&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="C++ 基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
    <category term="OOP" scheme="http://yoursite.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>「Algorithmic questions」动态规划</title>
    <link href="http://yoursite.com/2021/04/26/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E3%80%8CAlgorithmic%20questions%E3%80%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2021/04/26/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E3%80%8CAlgorithmic%20questions%E3%80%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-04-26T04:22:16.000Z</published>
    <updated>2021-05-17T03:56:16.344Z</updated>
    
    <content type="html"><![CDATA[<p>开个坑。感觉算法题还是要经常练保持手感，前段时间蓝桥杯，感觉大一时洛谷那么多题白刷了，那么多算法模板白总结了，都忘完了。做算法题还是要尽量自己多想，不思考看题解忘得太快。虽然最近比较忙，但每两天做一点应该还是可以的（吧）。希望不咕。</p><h1 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h1><h2 id="T198-House-Robber"><a href="#T198-House-Robber" class="headerlink" title="T198. House Robber"></a>T198. House Robber</h2><blockquote><p>假如你是一个劫匪，并且决定抢劫一条街上的房子，每个房子内的钱财数量各不相同。如果 你抢了两栋相邻的房子，则会触发警报机关。求在不触发机关的情况下最多可以抢劫多少钱。</p></blockquote><p>输入是一个一维数组，表示每个房子的钱财数量；输出是劫匪可以最多抢劫的钱财数量。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>很基础的dp，<code>dp[i]</code>表示前<code>i</code>个房子劫匪最多抢劫的数量，那么它有两种情况组成：一种是我们选择不抢劫这个房子，此时累计的金额即为 <code>dp[i-1]</code>；另一种是我们选择抢劫这个房子，那么此前累计的最大金额只能是 <code>dp[i-2]</code>。因此本题的状态转移方程为 <code>dp[i] = max(dp[i-1], nums[i-1] + dp[i-2])</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = nums.<span class="built_in">size</span>(); </span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-2</span>]+nums[i<span class="number">-1</span>], dp[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>当然由于递推到<code>dp[i]</code>时，本数组此前有用的值只有<code>dp[i-1]</code>与<code>dp[i-2]</code>，所以可以简单状态压缩：用三个变量来代替这三个数，节省空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(); </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">int</span> pre2 = <span class="number">0</span>, pre1 = <span class="number">0</span>, cur; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; </span><br><span class="line">        cur = <span class="built_in">max</span>(pre2 + nums[i], pre1); pre2 = pre1; pre1 = cur;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> cur; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T413-Arithmetic-Slices"><a href="#T413-Arithmetic-Slices" class="headerlink" title="T413. Arithmetic Slices"></a>T413. Arithmetic Slices</h2><blockquote><p>给定一个数组，求这个数组中连续且等差的子数组一共有多少个。</p></blockquote><p>输入是一个一维数组，输出是满足等差条件的连续字数组个数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4] </span><br><span class="line">Output: 3  &#x2F;&#x2F; 等差数列有 [1,2,3]、[2,3,4] 和 [1,2,3,4]</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>对于<code>[1,2,3,4]</code>，在尾部加一个5，那么原来以4结尾的等差数列，增加了一个元素，它们的数量不变。但同时会形成一个新的数列<code>[3,4,5]</code>。因此设<code>dp[i]</code>表示<strong>以<code>nums[i]</code>结尾的等差数列</strong>的个数。</p><p>递推关系：如果<code>A[i]-A[i-1] = A[i-1]-A[i-2]</code>，则<code>dp[i]=1+dp[i-1]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]-nums[i<span class="number">-1</span>] == nums[i<span class="number">-1</span>]-nums[i<span class="number">-2</span>]) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        ans += dp[i];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h1><h2 id="T64-Minimum-Path-Sum"><a href="#T64-Minimum-Path-Sum" class="headerlink" title="T64. Minimum Path Sum"></a>T64. Minimum Path Sum</h2><blockquote><p>给定一个m × n 大小的非负整数矩阵，求从左上角开始到右下角结束的、经过的数字的和最小的路径。每次只能向右或者向下移动。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3,1], [1,5,1], [4,2,1]] </span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>很基础的二维dp，思路很好想：<code>dp[i][j]</code>表示左上角开始到<code>(i,j)</code>处最小路径的数字和。那么状态转移方程为：</p><p><code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</code>。当然边界要特判一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">dp</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j] + grid[i][j], dp[i][j - <span class="number">1</span>] + grid[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间压缩：因为 dp 数组的值由左边和上边转移而来，对于第 i 行，在遍历到第 j 列的时候，因为第j-1列已经更新过了，所以<code>dp[j-1]</code>代表<code>dp[i][j-1] </code>的值；而 <code>dp[j]</code> 还未更新，此时的值是在第 i-1 行的时候计算的，因此可以代表 <code>dp[i-1][j]</code> 的值。这样就把dp数组压成一维的了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = grid[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = dp[j - <span class="number">1</span>] + grid[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = dp[j] + grid[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T542-01-Matrix"><a href="#T542-01-Matrix" class="headerlink" title="T542. 01 Matrix"></a>T542. 01 Matrix</h2><blockquote><p>给定一个由 0 和 1 组成的二维矩阵，求每个位置到最近的 0 的距离</p></blockquote><p>和上一题主要的区别在于本次矩阵需要四个方向的搜索，我们就不能简单由上方和左方矩阵转移而来。我们可以从左上到右下进行一次 dp ，再从右下到左上进行一次 dp 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3fffffff</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = INF;<span class="comment">// 注意 inf 的设置</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里开始不一样，需要和之前dp所得的成果相比，取最小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp; j == m - <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(INF, dp[i][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == m - <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], <span class="built_in">min</span>(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T221-Maximal-Square"><a href="#T221-Maximal-Square" class="headerlink" title="T221. Maximal Square"></a>T221. Maximal Square</h2><blockquote><p>给定一个二维的 0-1 矩阵，求全由 1 构成的最大正方形面积。</p></blockquote><h3 id="悬线法"><a href="#悬线法" class="headerlink" title="悬线法"></a>悬线法</h3><p>悬线法常用来求解这种给定矩阵中满足条件的最大子矩阵。</p><p>首先我们用<code>left[i][j]</code>表示从<code>(i,j)</code>能到达的最左位置，用<code>right[i][j]</code>表示从<code>(i,j)</code>能到达的最右位置，用<code>up[i][j]</code>表示从<code>(i,j)</code>向上扩展的最长长度。</p><p>那么这道题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(vector &lt;vector&lt;<span class="keyword">char</span>&gt;&gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">left</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">right</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">up</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="comment">// 能到达的最右和最左都初始化为自己开始的横坐标</span></span><br><span class="line">            left[i][j] = j;</span><br><span class="line">            right[i][j] = j;</span><br><span class="line">            up[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;<span class="comment">// 注意 j 是最作坊元素的右边元素位置，因为要递推</span></span><br><span class="line">            <span class="keyword">if</span> ((matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &amp;&amp; (matrix[i][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)) &#123;</span><br><span class="line">                left[i][j] = left[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123;<span class="comment">// 这里 j 类似</span></span><br><span class="line">            <span class="keyword">if</span> ((matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &amp;&amp; (matrix[i][j + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)) &#123;</span><br><span class="line">                right[i][j] = right[i][j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &amp;&amp; (matrix[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>)) &#123; <span class="comment">// i类似</span></span><br><span class="line">                left[i][j] = <span class="built_in">max</span>(left[i][j], left[i - <span class="number">1</span>][j]); </span><br><span class="line">                <span class="comment">// 上下的left取最靠右的，确保满足</span></span><br><span class="line">                right[i][j] = <span class="built_in">min</span>(right[i][j], right[i - <span class="number">1</span>][j]);</span><br><span class="line">                up[i][j] = up[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = right[i][j] - left[i][j] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> height = <span class="built_in">min</span>(len, up[i][j]);</span><br><span class="line">                area = <span class="built_in">max</span>(area, height * height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常规的-dp-转移"><a href="#常规的-dp-转移" class="headerlink" title="常规的 dp 转移"></a>常规的 dp 转移</h3><p><code>dp[i][j] </code>表示满足题目条件的、以 <code>(i, j)</code> 为右下角的正方形或者长方形的属性。对于本题，则表示以 <code>(i, j)</code> 为右下角的全由 1 构成的最大正方形边长。如果当前位置是 0，那么 <code>dp[i][j]</code> 即为 0；如果当前位置是 1，我们假设 $dp[i][j]=k$，其充分条件为 <code>dp[i-1][j-1]</code>、<code>dp[i][j-1]</code> 和 <code>dp[i-1][j]</code> 的值必须 都不小于$(k-1)$，否则 <code>(i, j)</code> 位置不可以构成一个边长为 k 的正方形。同理，如果这三个值中的 的最小值为 k − 1，则 <code>(i, j)</code> 位置一定且最大可以构成一个边长为 k 的正方形。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>(), max_side = <span class="number">0</span>; </span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>)); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123; </span><br><span class="line">            <span class="keyword">if</span> (matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123; </span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            max_side = <span class="built_in">max</span>(max_side, dp[i][j]); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> max_side * max_side;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开个坑。感觉算法题还是要经常练保持手感，前段时间蓝桥杯，感觉大一时洛谷那么多题白刷了，那么多算法模板白总结了，都忘完了。做算法题还是要尽量自己多想，不思考看题解忘得太快。虽然最近比较忙，但每两天做一点应该还是可以的（吧）。希望不咕。&lt;/p&gt;
&lt;h1 id=&quot;一维&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Algorithm problems" scheme="http://yoursite.com/categories/Algorithm-problems/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="algorithmic questions" scheme="http://yoursite.com/tags/algorithmic-questions/"/>
    
    <category term="dp" scheme="http://yoursite.com/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>「OOP」设计模式</title>
    <link href="http://yoursite.com/2021/04/24/ObjectOriented/%E3%80%8COO%E3%80%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2021/04/24/ObjectOriented/%E3%80%8COO%E3%80%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-04-24T12:54:47.000Z</published>
    <updated>2021-04-30T02:53:01.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="肾莫是设计模式"><a href="#肾莫是设计模式" class="headerlink" title="肾莫是设计模式"></a>肾莫是设计模式</h2><p>设计模式（<code>Design pattern</code>）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 </p><p>软件模式是将模式的一般概念应用于软件开发领域，即软件开发的总体指导思路或参照样板。软件模式除了设计模式，还包括架构模式、分析模式和过程模式等。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><strong>创建型模式</strong></li></ul><p>对象实例化的模式，创建型模式用于解耦对象的实例化过程。</p><ul><li><strong>结构型模式</strong></li></ul><p>把类或对象结合在一起形成一个更大的结构。</p><ul><li><strong>行为型模式</strong></li></ul><p>类和对象如何交互，及划分责任和算法。以及对象之间的通信问题。</p><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote><p>确保某一个类只有一个实例，并且提供一个全局访问点。</p></blockquote><p>场景：一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li><strong>饿汉式</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较常用。它基于<code>classloader</code> 机制避免了多线程的同步问题，没有加锁，效率高。但类加载时就初始化，浪费内存。</p><ul><li><strong>双重校验锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用双锁机制，安全且在多线程情况下能保持高性能。</p><ul><li><strong>登记式/静态内部类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。</li><li>允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li></ul><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><blockquote><p>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，也就是说工厂方法模式让实例化推迟到子类。</p></blockquote><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Rectangle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Circle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;CIRCLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><blockquote><p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p></blockquote><p>通俗地讲，就是围绕一个抽象工厂创建具体工厂。这样创建的产品可以使多个维度的。这里以创建“形状”与“颜色”两个维度举例：</p><p>多个产品的接口及其实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shape接口、Rectangle类、Circle类同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 颜色接口及其实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Red::fill() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Green</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Green::fill() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提到的抽象工厂，只要负责定义多个维度的产品的创建接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Color <span class="title">getColor</span><span class="params">(String color)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂的具体实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ShapeFactory 同上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(color == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">&quot;RED&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Red();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">&quot;BLUE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Blue();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryProducer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">getFactory</span><span class="params">(String choice)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">&quot;SHAPE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">&quot;COLOR&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ColorFactory();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取形状工厂</span></span><br><span class="line">AbstractFactory shapeFactory = FactoryProducer.getFactory(<span class="string">&quot;SHAPE&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取形状为 Circle 的对象</span></span><br><span class="line">Shape shape1 = shapeFactory.getShape(<span class="string">&quot;CIRCLE&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</li><li>开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。</li></ul><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><blockquote><p>使用多个简单的对象一步一步构建成一个复杂的对象。将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p></blockquote><p><code>StringBuilder</code>就采用本模式实现。</p><p>本模式包含如下角色：</p><ul><li>Builder：抽象建造者</li><li>ConcreteBuilder：具体建造者，创建和提供实例</li><li>Director：指挥者，管理建造出来的实例的依赖关系</li><li>Product：产品角色</li></ul><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>建造者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPart1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPart2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPart3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的建造者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder1</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> StringBuffer buffer = <span class="keyword">new</span> StringBuffer();<span class="comment">//假设 buffer.toString() 就是最终生成的产品</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart1</span><span class="params">()</span> </span>&#123;<span class="comment">//实现构建最终实例需要的所有方法</span></span><br><span class="line">        buffer.append(<span class="string">&quot;Builder1 : Part1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        buffer.append(<span class="string">&quot;Builder1 : Part2\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        buffer.append(<span class="string">&quot;Builder1 : Part3\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;<span class="comment">//定义获取最终生成实例的方法</span></span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指挥者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;    <span class="comment">// 将一个复杂的构建过程与其表示相分离</span></span><br><span class="line">    <span class="keyword">private</span> Builder builder;    <span class="comment">// 针对接口编程，而不是针对实现编程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBuilder</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span> </span>&#123;   <span class="comment">// 控制（定义）一个复杂的构建过程</span></span><br><span class="line">        builder.buildPart1();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;   <span class="comment">// 提示：如果想在运行过程中替换构建算法，可以考虑结合策略模式。</span></span><br><span class="line">            builder.buildPart2();</span><br><span class="line">        &#125;</span><br><span class="line">        builder.buildPart3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>如果产品之间的差异性很大，则不适合使用建造者模式。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ul><h4 id="与抽象工厂模式对比"><a href="#与抽象工厂模式对比" class="headerlink" title="与抽象工厂模式对比"></a>与抽象工厂模式对比</h4><ul><li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。</li><li>如果将抽象工厂模式看成 汽车配件生产工厂 ，生产一个产品族的产品，那么建造者模式就是一个 汽车组装工厂 ，通过对部件的组装可以返回一辆完整的汽车。</li></ul><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="适配器模式（Adapter）"><a href="#适配器模式（Adapter）" class="headerlink" title="适配器模式（Adapter）"></a>适配器模式（Adapter）</h3><blockquote><p>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p></blockquote><p>我们可能需要将两个不同接口的类来进行通信，在不修改这两个的前提下，我们可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器。所谓适配器模式就是将一个类的接口，转换成客户期望的另一个接口。</p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>例：电脑只有读SD卡的接口，现在要读TF卡：</p><ol><li>先创建一个SD卡与TF卡的接口与其实现类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -- SD card -- */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SDCard</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">readSD</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">writeSD</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SDCardImpl</span> <span class="keyword">implements</span> <span class="title">SDCard</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String msg = <span class="string">&quot;sdcard read a msg :hello word SD&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writeSD</span><span class="params">(String msg)</span> </span>&#123;      </span><br><span class="line">        System.out.println(<span class="string">&quot;sd card write msg : &quot;</span> + msg);    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* -- TF card -- */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TFCard</span> </span>&#123;    </span><br><span class="line">    <span class="function">String <span class="title">readTF</span><span class="params">()</span></span>;    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">writeTF</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TFCardImpl</span> <span class="keyword">implements</span> <span class="title">TFCard</span> </span>&#123;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readTF</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        String msg =<span class="string">&quot;tf card reade msg : hello word tf card&quot;</span>;        </span><br><span class="line">        <span class="keyword">return</span> msg;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writeTF</span><span class="params">(String msg)</span> </span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;tf card write a msg : &quot;</span> + msg);        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建计算机接口与计算机实例，计算机提供读取SD卡方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;    </span><br><span class="line">    <span class="function">String <span class="title">readSD</span><span class="params">(SDCard sdCard)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThinkpadComputer</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">(SDCard sdCard)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span>(sdCard == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;sd card null&quot;</span>);        </span><br><span class="line">        <span class="keyword">return</span> sdCard.readSD();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们希望在不改变计算机读取SD卡接口的情况下，通过适配器模式读取TF卡：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* -- 创建SD适配TF （也可以说是SD兼容TF，相当于读卡器）：  -- */</span></span><br><span class="line"><span class="comment">// 实现SDCard接口，并将要适配的对象作为适配器的属性引入。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SDAdapterTF</span> <span class="keyword">implements</span> <span class="title">SDCard</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> TFCard tfCard;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SDAdapterTF</span><span class="params">(TFCard tfCard)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.tfCard = tfCard;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);        </span><br><span class="line">        <span class="keyword">return</span> tfCard.readTF();    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writeSD</span><span class="params">(String msg)</span> </span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);        </span><br><span class="line">        <span class="keyword">return</span> tfCard.writeTF(msg);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以读取TF卡：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerReadDemo</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">        Computer computer = <span class="keyword">new</span> ThinkpadComputer();            </span><br><span class="line">        TFCard tfCard = <span class="keyword">new</span> TFCardImpl();        </span><br><span class="line">        SDCard tfCardAdapterSD = <span class="keyword">new</span> SDAdapterTF(tfCard);        </span><br><span class="line">        System.out.println(computer.readSD(tfCardAdapterSD));    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合模式（Composite-）"><a href="#组合模式（Composite-）" class="headerlink" title="组合模式（Composite ）"></a>组合模式（Composite ）</h3><blockquote><p>将对象组合成树形结构以表示”部分-整体”的层次结构。</p></blockquote><p>看代码很容易理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String dept;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> salary;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Employee&gt; subordinates;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//构造函数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name,String dept, <span class="keyword">int</span> sal)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.dept = dept;</span><br><span class="line">      <span class="keyword">this</span>.salary = sal;</span><br><span class="line">      subordinates = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">      subordinates.add(e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="外观模式（Facade-）"><a href="#外观模式（Facade-）" class="headerlink" title="外观模式（Facade ）"></a>外观模式（Facade ）</h3><blockquote><p>外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面</p></blockquote><p>我们知道类与类之间的耦合越低，那么可复用性就越好，如果两个类不必彼此通信，那么就不要让这两个类发生直接的相互关系，如果需要调用里面的方法，可以通过第三者来转发调用。外观模式非常好的诠释了这段话。外观模式提供了一个统一的接口，用来访问子系统中的一群接口，实现了客户与子系统之间的松耦合。</p><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>电脑的外观：打开开关按钮，就可以开机（启动CPU，内存，硬盘…）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 电脑接口 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * CPU类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cpu</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;启动CPU&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * 内存类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ddr</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;启动内存&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * 硬盘类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ssd</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;启动硬盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** * 外观类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Computer cpu;</span><br><span class="line">    <span class="keyword">private</span> Computer ddr;</span><br><span class="line">    <span class="keyword">private</span> Computer ssd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Facade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cpu = <span class="keyword">new</span> Cpu();</span><br><span class="line">        ddr = <span class="keyword">new</span> Ddr();</span><br><span class="line">        ssd = <span class="keyword">new</span> Ssd();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 启动电脑 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cpu.open();</span><br><span class="line">        ddr.open();</span><br><span class="line">        ssd.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">        facade.onComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理模式（Proxy-）"><a href="#代理模式（Proxy-）" class="headerlink" title="代理模式（Proxy ）"></a>代理模式（Proxy ）</h3><blockquote><p>创建具有现有对象的对象，以便向外界提供功能接口。</p></blockquote><p>某些情况下，一个客户不想或不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul><li>Subject： 抽象主题角色</li><li>Proxy： 代理主题角色</li><li>RealSubject： 真实主题角色</li></ul><h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  RealSubject  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> String fileName;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RealImage</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">      loadFromDisk(fileName);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Displaying &quot;</span> + fileName);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Loading &quot;</span> + fileName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Proxy  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> RealImage realImage;</span><br><span class="line">   <span class="keyword">private</span> String fileName;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ProxyImage</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(realImage == <span class="keyword">null</span>)&#123;</span><br><span class="line">         realImage = <span class="keyword">new</span> RealImage(fileName);</span><br><span class="line">      &#125;</span><br><span class="line">      realImage.display();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Image image = <span class="keyword">new</span> ProxyImage(<span class="string">&quot;test_10mb.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图像将从磁盘加载</span></span><br><span class="line">    image.display(); </span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// 图像不需要从磁盘加载</span></span><br><span class="line">    image.display();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h4><p>根据代理模式的使用目的，常见的代理模式有以下几种类型：</p><ul><li>远程(Remote)代理：为一个位于不同的地址空间的对象提供一个本地 的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在 另一台主机中，远程代理又叫做大使(Ambassador)。</li><li>虚拟(Virtual)代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li><li>图片代理：一个很常见的代理模式的应用实例就是对大图浏览的控制。用户通过浏览器访问网页时先在代理对象的方法中，使用一个线程向客户端浏览器加载一个小图片，然后在后台使用另一个线程来调用大图加载方法将大图片加载到客户端。当需要浏览大图片时，再将大图片在新网页中显示。如果此时加载工作还没完成，可以再启动一个线程来显示相应的提示信息。通过代理技术结合多线程编程将真实图片的加载放到后台来操作，不影响前台图片的浏览。</li><li>动态代理：在事先不知道真实主题角色的情况下使用代理主题角色。</li></ul><p>对于动态代理，JDK有自带的包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Proxy: 生成动态代理类和对象；</span><br><span class="line">java.lang.reflect.InvocationHandler（处理器接口）：可以通过invoke方法实现</span><br></pre></td></tr></table></figure><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="职责链模式-Chain-of-Responsibility"><a href="#职责链模式-Chain-of-Responsibility" class="headerlink" title="职责链模式(Chain of Responsibility)"></a>职责链模式(Chain of Responsibility)</h3><blockquote><p>它将对象组成一条链，发送者将请求发给链的第一个接收者，并且沿着这条链传递，直到有一个对象来处理它或者直到最后也没有对象处理而留在链末尾端。</p></blockquote><h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><p>消息记录器，判断消息等级小于自己的等级就打印消息，并传递到下一个链节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INFO = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEBUG = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ERROR = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">int</span> level;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//责任链中的下一个元素</span></span><br><span class="line">   <span class="keyword">protected</span> AbstractLogger nextLogger;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextLogger</span><span class="params">(AbstractLogger nextLogger)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.nextLogger = nextLogger;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMessage</span><span class="params">(<span class="keyword">int</span> level, String message)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.level &lt;= level)&#123;</span><br><span class="line">         write(message);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(nextLogger !=<span class="keyword">null</span>)&#123;</span><br><span class="line">         nextLogger.logMessage(level, message);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span></span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实体类：将<code>ConsoleLogger-&gt;FileLogger-&gt;ErrorLogger</code>串联</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsoleLogger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = Level.INFO;</span><br><span class="line">        <span class="comment">//指定nextLogger为FileLogger</span></span><br><span class="line">        setNextLogger(<span class="keyword">new</span> FileLogger());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Console logger: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileLogger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = Level.DEBUG;</span><br><span class="line">        setNextLogger(<span class="keyword">new</span> ErrorLogger());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;File logger: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorLogger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = Level.ERROR;</span><br><span class="line">        <span class="comment">//nextLogger设置为null</span></span><br><span class="line">        <span class="comment">//扩展时将此更改为新的Logger</span></span><br><span class="line">        setNextLogger(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Error logger: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**         </span></span><br><span class="line"><span class="comment">         * 暴露最低等级既可         </span></span><br><span class="line"><span class="comment">         */</span>        </span><br><span class="line">        AbstractLogger consoleLogger = <span class="keyword">new</span> ConsoleLogger();</span><br><span class="line"></span><br><span class="line">        consoleLogger.logMegger(<span class="number">3</span>, <span class="string">&quot;错误信息&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        consoleLogger.logMegger(<span class="number">2</span>, <span class="string">&quot;测试信息&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        consoleLogger.logMegger(<span class="number">1</span>, <span class="string">&quot;控制台信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Console logger: 错误信息</span></span><br><span class="line"><span class="comment">File logger: 错误信息</span></span><br><span class="line"><span class="comment">Error logger: 错误信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Console logger: 测试信息</span></span><br><span class="line"><span class="comment">File logger: 测试信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Console logger: 控制台信息</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>在职责链模式中，使得每一个对象都有可能来处理请求，从而实现了请求的发送者和接收者之间的解耦。</li><li>同时职责链模式简化了对象的结构，它使得每个对象都只需要引用它的后继者即可，而不必了解整条链，这样既提高了系统的灵活性也使得增加新的请求处理类也比较方便。</li><li>但是在职责链中我们不能保证所有的请求都能够被处理，而且不利于观察运行时特征。</li></ul><h3 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式(Command)"></a>命令模式(Command)</h3><h3 id="迭代器模式-Iterator"><a href="#迭代器模式-Iterator" class="headerlink" title="迭代器模式(Iterator)"></a>迭代器模式(Iterator)</h3><h3 id="观察者模式-Observer"><a href="#观察者模式-Observer" class="headerlink" title="观察者模式(Observer)"></a>观察者模式(Observer)</h3><h3 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式(State)"></a>状态模式(State)</h3><h3 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式(Strategy)"></a>策略模式(Strategy)</h3><h3 id="模板方法模式-Template-Method"><a href="#模板方法模式-Template-Method" class="headerlink" title="模板方法模式(Template Method)"></a>模板方法模式(Template Method)</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;肾莫是设计模式&quot;&gt;&lt;a href=&quot;#肾莫是设计模式&quot; class=&quot;headerlink&quot; title=&quot;肾莫是设计模式&quot;&gt;&lt;/a&gt;肾莫是设计模式&lt;/h2&gt;&lt;p&gt;设计模式（&lt;code&gt;Design pattern&lt;/code&gt;）是一套被反复使用、多数人知晓的、经</summary>
      
    
    
    
    <category term="ObjectOriented" scheme="http://yoursite.com/categories/ObjectOriented/"/>
    
    
    <category term="OO" scheme="http://yoursite.com/tags/OO/"/>
    
    <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>「OOP」UML图</title>
    <link href="http://yoursite.com/2021/04/23/ObjectOriented/%E3%80%8COO%E3%80%8D-UML%E5%9B%BE/"/>
    <id>http://yoursite.com/2021/04/23/ObjectOriented/%E3%80%8COO%E3%80%8D-UML%E5%9B%BE/</id>
    <published>2021-04-23T11:18:06.000Z</published>
    <updated>2021-04-27T03:44:39.452Z</updated>
    
    <content type="html"><![CDATA[<p>UML（<code>Unified Modeling Language</code>），统一建模语言。是用来对软件密集系统进行可视化建模的一种语言。</p><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="https://img.imgdb.cn/item/60856100d1a9ae528f8509d9.jpg"></p><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><h4 id="泛化关系-generalization"><a href="#泛化关系-generalization" class="headerlink" title="泛化关系(generalization)"></a>泛化关系(generalization)</h4><p>类的继承结构表现在UML中为：泛化与实现。</p><p>泛化关系表现为继承非抽象类：（A继承自B）</p><p><img src="https://img.imgdb.cn/item/60855e68d1a9ae528f6d19cd.jpg" alt="uml_gen"></p><h4 id="实现关系-realize"><a href="#实现关系-realize" class="headerlink" title="实现关系(realize)"></a>实现关系(realize)</h4><p>实现关系表现为继承抽象类或实现接口：</p><p><img src="https://img.imgdb.cn/item/60855ee4d1a9ae528f713a04.jpg" alt="uml_realize"></p><h4 id="聚合关系-aggregation"><a href="#聚合关系-aggregation" class="headerlink" title="聚合关系(aggregation)"></a>聚合关系(aggregation)</h4><p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义。例如：一个部门由多个员工组成。</p><p>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在。例如， 部门撤销了，人员不会消失，他们依然存在。</p><p>下图表示B由A组成：</p><p><img src="https://img.imgdb.cn/item/60855f55d1a9ae528f7527f8.jpg"></p><h4 id="组合关系-composition"><a href="#组合关系-composition" class="headerlink" title="组合关系(composition)"></a>组合关系(composition)</h4><p>组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在。例如，公司不存在了，部门也将不存在了。</p><p><img src="https://img.imgdb.cn/item/60855fb4d1a9ae528f787e31.jpg"></p><h4 id="关联关系-association"><a href="#关联关系-association" class="headerlink" title="关联关系(association)"></a>关联关系(association)</h4><p>一般用来定义对象之间静态的、天然的结构。关联关系是一种“强关联”的关系。例如：乘车人和车票之间、学生和学校都是一种关联关系。</p><p>用一条直线表示。</p><h4 id="依赖关系-dependency"><a href="#依赖关系-dependency" class="headerlink" title="依赖关系(dependency)"></a>依赖关系(dependency)</h4><p>描述一个对象在运行期间会用到另一个对象的关系。</p><p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变化。</p><p>依赖也有方向，双向依赖是一种非常糟糕的结构，我们应该保持单向依赖，杜绝双向依赖的产生。</p><p>注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还有“使用”对方的方法和属性。</p><p>下图表示A依赖于B：</p><p><img src="https://img.imgdb.cn/item/608560cbd1a9ae528f82fee1.jpg"></p><h2 id="UML时序图（顺序图）"><a href="#UML时序图（顺序图）" class="headerlink" title="UML时序图（顺序图）"></a>UML时序图（顺序图）</h2><p>时序图(<code>Sequence Diagram</code>)，又名序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。</p><p><img src="https://img.imgdb.cn/item/60856504d1a9ae528fad75f5.jpg"></p><h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h3><h4 id="角色-Actor"><a href="#角色-Actor" class="headerlink" title="角色(Actor)"></a>角色(Actor)</h4><p>系统角色，可以是人或者其他系统，子系统。以一个小人图标表示。</p><h4 id="对象-Object"><a href="#对象-Object" class="headerlink" title="对象(Object)"></a>对象(Object)</h4><p>位于时序图的顶部，以一个矩形表示。</p><h4 id="生命线-LifeLine"><a href="#生命线-LifeLine" class="headerlink" title="生命线(LifeLine)"></a>生命线(LifeLine)</h4><p>时序图中每个对象和底部中心都有一条垂直的虚线，即对象的生命线(对象的时间线)。</p><h4 id="消息-Message"><a href="#消息-Message" class="headerlink" title="消息(Message)"></a>消息(Message)</h4><p>表现代表对象之间发送的信息。消息分为三种类型。</p><ul><li><p><strong>同步消息(Synchronous Message)</strong></p><p>消息的发送者把信号传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。以一条实线+实心箭头表示。</p></li><li><p><strong>异步消息(Asynchronous Message)</strong></p><p>消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息。以<code>-&gt;</code>表示。</p></li><li><p><strong>返回消息(Return Message)</strong></p><p>表示从过程调用返回。以<code>&lt;---</code>表示</p></li></ul><h4 id="自关联消息"><a href="#自关联消息" class="headerlink" title="自关联消息"></a>自关联消息</h4><p>表示方法的自身调用或者一个对象内的一个方法调用另外一个方法。以一个半闭合的长方形+下方实心剪头表示。</p><h4 id="组合片段"><a href="#组合片段" class="headerlink" title="组合片段"></a>组合片段</h4><p>组合片段用来解决交互执行的条件和方式，它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。</p><hr><p>附：</p><ul><li><a href="https://plantuml.com/zh/sequence-diagram">https://plantuml.com/zh/sequence-diagram</a> 一个可online根据代码生成时序图的网站</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;UML（&lt;code&gt;Unified Modeling Language&lt;/code&gt;），统一建模语言。是用来对软件密集系统进行可视化建模的一种语言。&lt;/p&gt;
&lt;h2 id=&quot;UML类图&quot;&gt;&lt;a href=&quot;#UML类图&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="ObjectOriented" scheme="http://yoursite.com/categories/ObjectOriented/"/>
    
    
    <category term="OO" scheme="http://yoursite.com/tags/OO/"/>
    
    <category term="UML" scheme="http://yoursite.com/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>「OS」Pre</title>
    <link href="http://yoursite.com/2021/04/20/OperatingSystem/OS-1/"/>
    <id>http://yoursite.com/2021/04/20/OperatingSystem/OS-1/</id>
    <published>2021-04-20T12:54:47.000Z</published>
    <updated>2021-05-06T09:13:57.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>操作系统是一组管理计算机硬件资源的软件集合，它向计算机程序提供共性的服务：</p><ul><li>提供一个计算机用户与计算机硬件系统之间的接口，使计算机系统更易于使用。（使用者）</li><li>有效地控制和管理计算机系统中的各种硬件和软件资源，使之得到更有效的利用。（资源管理者）</li><li>合理地组织计算机系统的工作流程，以改善系统性能（如响应时间、系统吞吐量）。</li></ul><h1 id="历史沿革"><a href="#历史沿革" class="headerlink" title="历史沿革"></a>历史沿革</h1><p>OS 史前阶段 -&gt; 批处理 -&gt; 分时 -&gt; 现代 OS -&gt; 网络化 OS / 分布式 OS</p><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><blockquote><p>把用户提交的作业成批送入计算机，由作业调度程序自动选择作业运行</p></blockquote><h3 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h3><blockquote><p>加载在计算机上的一个系统软件，在它的控制下，计算机能够自动地、成批地处理一个或多个用户的作业（包括程序、数据和命令）<br>它分为：<strong>联机批处理系统</strong>和<strong>脱机批处理系统</strong></p></blockquote><ul><li>首先出现的是联机批处理系统，即作业的输入/输出由CPU来处理。<ul><li>在主机与输入机之间增加一个存储设备——<strong>磁带</strong>，在运行于主机上的监督程序的自动控制下，计算机可自动完成：成批地把输入机上的用户作业读入磁带，依次把磁带上的用户作业读入主机内存并执行，然后把计算结果向输出机输出</li></ul></li><li>为缓解高速主机与慢速外设的矛盾，引入了脱机批处理系统，即输入/输出脱离主机控制。<ul><li>增加一台不与主机直接相连而专门用于与输入/输出设备打交道的<strong>卫星机</strong>。<br>在前述的批处理系统中，引入<strong>多道程序设计技术</strong>后形成<strong>多道批处理系统</strong></li></ul></li><li>多道：系统内可同时容纳多个作业。</li></ul><h2 id="分时"><a href="#分时" class="headerlink" title="分时"></a>分时</h2><blockquote><p>将CPU处理时间分割为多个时间片，将时间片分给不同程序，达到多个程序“同时”运行的效果。从而支持用户、多进程。<br>与批处理相比，增加了管理时间片的系统开销、管理多用户的系统开销、管理硬件的系统开销（引入了虚存）、交互IO的系统开销等等。</p></blockquote><h2 id="网络化-OS"><a href="#网络化-OS" class="headerlink" title="网络化 OS"></a>网络化 OS</h2><blockquote><p>在传统单机OS上增加一个模块——网络通信模块，主要提供联网功能和资源的远程访问，实现多机互联<br>网络操作系统主要指运行在各种服务器上的操作系统，目前主要有 UNIX、LINUX、Winodws。</p></blockquote><h2 id="分布式-OS"><a href="#分布式-OS" class="headerlink" title="分布式 OS"></a>分布式 OS</h2><blockquote><p>区别于集中式操作系统，分布式操作系统负责管理分布式处理系统资源和控制分布式程序运行。它是一个一体化系统，将若干独立的计算机连成网络，有一个全局操作系统负责全系统的资源分配和调度等工作，但整个系统对用户来说如同是一台计算机。<br>计算机网络是分布式操作系统的物理基础。<br>分布式操作系统的特点主要有：</p></blockquote><ul><li>分布性。网络操作系统虽具分布处理功能，但其控制功能却是集中在某个或某些主机或网络服务器中，即集中式。</li><li>透明性。分布式操作系统通常能很好地隐藏系统内部的实现细节。</li><li>并行性。分布式操作系统具有任务分配功能，可将多个任务分配到多个处理单元上，使这些任务并行执行，从而加速了任务的执行。</li><li>共享性。分布式操作系统支持系统中所有用户对分布在各个站点上的软硬件资源的共享和透明方式访问。而网络操作系统所提供的资源共享功能仅局限于主机或网络服务器中资源，对于其它机器上的资源通常仅有使用该机的用户独占。</li><li>健壮性。分布式操作系统由于处理和控制功能的分布性而具有较好的可用性和可靠性，即健壮性。而网络操作系统由于控制功能的集中式特点而使系统重构功能较弱，且具有潜在的不可靠性。</li></ul><h1 id="Boot"><a href="#Boot" class="headerlink" title="Boot"></a>Boot</h1><p>操作系统的启动过程。</p><p>CPU 加电，取指寄存器复位到固定值后，需要 Bootloader 的引导。bootloader 需要将内核镜像文件加载到内存中， 那么它就能选择使用哪一个内核镜像进行加载，即实现多重开机的功能。使用bootloader后，我们就能够在一个硬件上运行多个操作系统了。</p><h2 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h2><p>从操作系统的角度看，boot loader 的总目标就是正确地调用内核来执行。 由于 boot loader 的实现依赖于 cpu 的体系结构，因此大多数 boot loader 都分为 stage1 和 stage2 两大部分。</p><h3 id="stage-1"><a href="#stage-1" class="headerlink" title="stage 1"></a>stage 1</h3><p>由于内存 RAM 尚未初始化完成， stage 1 直接运行在存放 bootloader 的存储设备上（比如FLASH）</p><ul><li>初始化硬件设备，包括watchdog timer、中断、时钟、内存等。</li><li>为加载 stage 2准备RAM空间，然后将stage 2的代码复制到RAM空间</li><li>设置堆栈，并跳转到stage 2的入口函数。</li></ul><h3 id="stage-2"><a href="#stage-2" class="headerlink" title="stage 2"></a>stage 2</h3><p>运行在RAM中。（由于 stage 1 不能在内存 RAM 中运行，其自身运行会受诸多限制， 比如有些 flash 程序不可写，即使程序可写的 flash 也有存储空间限制。这就是为什么需要stage 2的原因）</p><ul><li>初始化这一阶段需要使用的硬件设备以及其他功能</li><li>将内核镜像文件从存储器读到RAM中</li><li>为内核设置启动参数</li><li>将CPU指令寄存器的内容设置为内核入口函数的地址，即可将控制权从bootloader 转交给操作系统内核。</li></ul><p>以上两个工作阶段的具体实现在不同系统、不同硬件环境都会有差别。</p><p>比如 x86 PC 的启动过程中，首先执行的是BIOS中的代码，主要完成硬件初始化相关的工作， 然后BIOS会从MBR（master boot record，开机硬盘的第一个扇区）中读取开机信息。Linux中常说的 Grub 和 Lilo 这两种开机管理程序就是被保存在MBR中的。</p><p><em>注：GRUB(GRand Unified Bootloader)是GNU项目的一个多操作系统启动程序。简单的说，就是可以用于在有多个操作系统的机器上， 在刚开机的时候选择一个操作系统进行引导。</em></p><p>BIOS加载MBR中的Grub代码后就把CPU交给了Grub，Grub的工作就是一步一步的加载自身代码，从而识别文件系统， 然后就能够将文件系统中的内核镜像文件加载到内存中，并将CPU控制权转交给操作系统内核。 这样看来，其实BIOS和Grub的前一部分构成了前述stage 1的工作，而stage 2的工作则是完全在Grub中完成的。</p><p>*注：bootloader有两种操作模式：启动加载模式和下载模式。对于普通用户而言，bootloader只运行在启动加载模式，就是我们之前讲解的过程。 而下载模式仅仅对于开发人员有意义，区别是前者是通过本地设备中的内核镜像文件启动操作系统的，而后者是通过串口或以太网等通信手段将远端的内核镜像上载到内存的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;操作系统是一组管理计算机硬件资源的软件集合，它向计算机程序提供共性的服务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供一个计算机用户与计算机硬件系统之间</summary>
      
    
    
    
    <category term="OperatingSystem" scheme="http://yoursite.com/categories/OperatingSystem/"/>
    
    
    <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>「组合数学」</title>
    <link href="http://yoursite.com/2021/04/20/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88/"/>
    <id>http://yoursite.com/2021/04/20/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88/</id>
    <published>2021-04-20T01:00:15.000Z</published>
    <updated>2021-05-16T08:58:46.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路径数问题"><a href="#路径数问题" class="headerlink" title="路径数问题"></a>路径数问题</h2><p>$C(m+n, n)$，从$(0,0)$到$(m,n)$，那么每一个路径对应一个 xxyx… 这样的排列，选n个位置放y，即 $C(m+n, n)$</p><ul><li>$C(n,r)=C(n-1,r)+C(n-1,r-1)$</li></ul><p>可推出杨辉三角。</p><ul><li>$(_r^{n+r+1})=(^{n+r}<em>r)+(^{n+r-1}</em>{r-1})+…+(^n_0)$</li></ul><p><img src="https://pic.imgdb.cn/item/60a0debe6ae4f77d35d1de66.jpg"></p><ul><li>$(^{m+n}_r)=(^m_0)(^n_r)+…+(^m_r)(^n_0)$</li></ul><p>m+n个球，m个红球，n个蓝球，取出的r个球：0个红球，r个蓝球…..r个红球，0个蓝球</p><h2 id="生成排列"><a href="#生成排列" class="headerlink" title="生成排列"></a>生成排列</h2><p>由 n 个正整数组成的集合<code>&#123;1,2,..,n&#125;</code>有$n!$排列。</p><p>$n!=\sqrt{2\pi n}(\frac{n}{e})^n$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;路径数问题&quot;&gt;&lt;a href=&quot;#路径数问题&quot; class=&quot;headerlink&quot; title=&quot;路径数问题&quot;&gt;&lt;/a&gt;路径数问题&lt;/h2&gt;&lt;p&gt;$C(m+n, n)$，从$(0,0)$到$(m,n)$，那么每一个路径对应一个 xxyx… 这样的排列，选n个位置</summary>
      
    
    
    
    <category term="组合数学" scheme="http://yoursite.com/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>「Linux 基本工具」GCC &amp; make</title>
    <link href="http://yoursite.com/2021/03/15/Linux/Linux%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7-GCC/"/>
    <id>http://yoursite.com/2021/03/15/Linux/Linux%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7-GCC/</id>
    <published>2021-03-15T01:21:15.000Z</published>
    <updated>2021-04-25T07:03:26.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="GCC-amp-Clang"><a href="#GCC-amp-Clang" class="headerlink" title="GCC &amp; Clang"></a>GCC &amp; Clang</h2><p>编译器是翻译代码为计算机语言的一个工具，我们平时写的代码如果想在某个特定的计算机上执行（计算机的<code>cpu</code>构架不同），就需要编译器来对代码进行编译汇编链接，而汇编和链接的过程对于每个不同的平台上过程都不一样。</p><p><code>gcc</code>、<code>clang</code>是两个编译器，用于将高级编程语言，编译汇编链接成机器语言。</p><ul><li><code>GCC</code> → <code>GNU Compiler Collection</code>，也称GNU编译器套件，可编译许多种语言（<code>C/C++</code>, <code>Java</code>等）<ul><li><code>gcc</code>（<code>GUN C Compiler</code>）是GCC中的c编译器</li><li><code>g++</code>（<code>GUN C++ Compiler</code>）是GCC中的c++编译器。（两者都可以编译c和cpp文件，但存在差异）</li></ul></li><li><code>Clang</code> → 一个支持编译<code>C/C++/Objective-C</code>语言的轻量级编译器。</li></ul><h2 id="make-amp-cmake"><a href="#make-amp-cmake" class="headerlink" title="make &amp; cmake"></a>make &amp; cmake</h2><p><code>make</code>和<code>cmake</code>是搭配编译器来方便用户进行多文件编译而发明的工具。<code>IDE</code>的编译功能就包括实现了这些操作。</p><ul><li><code>make</code> → 相当于一个智能的批处理工具，本身没有编译和链接的功能，而是用类似于批处理的方式通过调用<code>Makefile</code>文件中用户指定的命令来进行编译和链接。</li><li><code>cmake</code> → 用于更方便地生成<code>makefile</code>文件给<code>make</code>用，<code>cmake</code>还可以跨平台生成对应平台能用的<code>makefile</code>。</li><li><code>CMakeLists.txt</code> → <code>cmake</code>根据<code>CMakeLists.txt</code>文件（组态档）去生成<code>makefile</code>；我们使用IDE时，会自动生成各种<code>CMakeLists.txt</code>。</li></ul><h2 id="编译器编译流程"><a href="#编译器编译流程" class="headerlink" title="编译器编译流程"></a>编译器编译流程</h2><p><code>gcc/g++</code> 在执行编译工作时，需：</p><ol><li><strong>预处理</strong>，生成 <code>.i </code>的文件 [ 预处理器<code>cpp</code> ]</li><li>将预处理后的文件<strong>转换成汇编</strong>语言, 生成文件 <code>.s</code>  [ 编译器<code>egcs</code> ]</li><li>由汇编变为<strong>机器码</strong>，生成 <code>.o</code> 的文件  [ 汇编器<code>as</code> ]</li><li>链接目标代码, 生成<strong>可执行程序</strong> [ 链接器<code>ld</code> ]</li></ol><hr><h1 id="gcc使用"><a href="#gcc使用" class="headerlink" title="gcc使用"></a>gcc使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法:gcc [选项]... [参数]...</span><br></pre></td></tr></table></figure><h3 id="选项（常用）："><a href="#选项（常用）：" class="headerlink" title="选项（常用）："></a>选项（常用）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-o      指定生成的输出文件</span><br><span class="line">-S      将C代码转换为汇编代码</span><br><span class="line">-Wall   显示警告信息</span><br><span class="line">-c      仅执行编译操作，不进行链接操作</span><br><span class="line">-M      列出依赖        </span><br><span class="line">-include filename   编译时用来包含头文件，功能相当于在代码中使用#include&lt;filename&gt;   </span><br><span class="line">-Ipath   编译时指定头文件目录，使用标准库时不需要指定目录，-I参数可以用相对路径，比如头文件在当前目录，可以用-I.来指定   </span><br></pre></td></tr></table></figure><h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C源文件：指定C语言源代码文件</span><br></pre></td></tr></table></figure><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><ol><li>如果想要同时编译多个文件，可以直接用<code>-o</code>选项将多个文件进行编译连接：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc testfun.c test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>也可以先使用<code>-c</code>选项将每个文件单独编译成<code>.o</code>文件，再用<code>-o</code>选项将多个<code>.o</code>文件进行连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c testfun.c -&gt; gcc -c test.c -&gt; gcc testfun.o test.o -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><ol start="2"><li>其他操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test.c</span><br><span class="line">#默认生成名为a.out的可执行文件</span><br><span class="line">#Windows平台为a.exe</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test.c -o test</span><br><span class="line">#使用-o选项生成名为test的可执行文件</span><br></pre></td></tr></table></figure><hr><h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h1&gt;&lt;h2 id=&quot;GCC-amp-Clang&quot;&gt;&lt;a href=&quot;#GCC-amp-Clang&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Linux 基础" scheme="http://yoursite.com/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
    <category term="GCC" scheme="http://yoursite.com/tags/GCC/"/>
    
    <category term="MakeFile" scheme="http://yoursite.com/tags/MakeFile/"/>
    
  </entry>
  
  <entry>
    <title>「Linux 基本工具」Vim</title>
    <link href="http://yoursite.com/2021/03/10/Linux/Linux%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7-Vim/"/>
    <id>http://yoursite.com/2021/03/10/Linux/Linux%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7-Vim/</id>
    <published>2021-03-10T11:21:15.000Z</published>
    <updated>2021-04-27T04:37:31.333Z</updated>
    
    <content type="html"><![CDATA[<p><strong>常用操作：</strong></p><p><img src="https://img.imgdb.cn/item/608794f5d1a9ae528fb950b8.jpg" alt="屏幕截图 2021-03-15 091327.jpg"></p><p>若想对vim进行永久的格式设置，可修改绝对路径<code>~/.vimrc</code>下的内容。例如想要对vim进行永久的行号显示设置，可在该文件内增添<code>set nu</code>或<code>:set nu</code> </p><h2 id="各种插入模式"><a href="#各种插入模式" class="headerlink" title="各种插入模式"></a>各种插入模式</h2><blockquote><ul><li><code>a</code> → 在光标后插入</li><li><code>o</code> → 在当前行后插入一个新行</li><li><code>O</code> → 在当前行前插入一个新行</li><li><code>cw</code> → 替换从光标所在位置后到一个单词结尾的字符</li></ul></blockquote><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><blockquote><p>除了y可以拷贝，以下也可</p><ul><li><code>d</code> (删除 )</li><li><code>v</code> (可视化，先按v，然后移动光标可以选中文本)</li><li><code>gU</code> (变大写)</li><li><code>gu</code> (变小写)</li></ul></blockquote><h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><blockquote><ul><li><p><code>0</code> → 到行头</p></li><li><p><code>^</code> → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）</p></li><li><p><code>$</code> → 到本行行尾</p></li><li><p><code>g_</code> → 到本行最后一个不是blank字符的位置。</p></li><li><p><code>w/W</code> → 到下一个单词的开头。( 程序变量用小写，程序语句用大写 )</p></li><li><p><code>e/E</code> → 到下一个单词的结尾。</p></li><li><p><code>%</code> : 匹配括号移动，包括 <code>(</code>, <code>&#123;</code>, <code>[</code>. （需要把光标先移到括号上）</p></li><li><p><code>*</code> 和 <code>#</code>:  匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个，<code>2#</code>是上两个）</p></li><li><p><code>fa</code> → 到下一个为a的字符处，你也可以fs到下一个为s的字符。</p></li><li><p><code>t,</code> → 到逗号前的第一个字符。逗号可以变成其它字符。</p></li><li><p><code>3fa</code> → 在当前行查找第三个出现的a。（<code>F</code> 和 <code>T</code> → 和 <code>f</code> 和 <code>t</code> 一样，只不过是相反方向。）</p></li></ul></blockquote><h2 id="打开-保存-退出-改变文件"><a href="#打开-保存-退出-改变文件" class="headerlink" title="打开/保存/退出/改变文件"></a>打开/保存/退出/改变文件</h2><blockquote><ul><li><code>:e &lt;path/to/file&gt;</code> → 打开一个文件</li><li><code>:w</code> → 存盘</li><li><code>:saveas &lt;path/to/file&gt;</code> → 另存为 <code>&lt;path/to/file&gt;</code></li><li><code>:x</code>， <code>ZZ</code> 或 <code>:wq</code> → 保存并退出 (<code>:x</code> 表示仅在需要时保存，ZZ不需要输入冒号并回车)</li><li><code>:q!</code> → 退出不保存 <code>:qa!</code> 强行退出所有的正在编辑的文件，就算别的文件有更改。</li><li><code>:bn</code> 和 <code>:bp</code> → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（陈皓注：我喜欢使用:n到下一个文件）</li></ul></blockquote><h2 id="批量输入"><a href="#批量输入" class="headerlink" title="批量输入"></a>批量输入</h2><blockquote><ul><li><code>100idesu [ESC]</code>  →  100行<code>desu</code></li><li><code>.</code> → 重复上一个命令—— 100 <code>&quot;desu&quot;</code></li><li><code>3.</code> → 重复 3 次 <code>“desu”</code> ( 注意：不是 300 )</li></ul></blockquote><h2 id="连招"><a href="#连招" class="headerlink" title="连招"></a>连招</h2><blockquote><p>很多命令都可以和移动光标的命令连动，<code>&lt;start position&gt;&lt;command&gt;&lt;end position&gt;</code></p><ul><li><code>0y$</code>  →  先到行头，从行头拷贝到本行最后一个字符</li><li><code>ye</code>  →  从当前位置拷贝到本单词最后一个字符</li></ul></blockquote><p>（未完待续 。。。<a href="https://coolshell.cn/articles/5426.html#%E7%AC%AC%E5%9B%9B%E7%BA%A7_%E2%80%93_Vim_%E8%B6%85%E8%83%BD%E5%8A%9B">参考博客</a>）</p><hr><h1 id="Nano"><a href="#Nano" class="headerlink" title="Nano"></a>Nano</h1><p>除Vim外，这款编辑器功能简单，上手较为容易。</p><p><img src="https://i.loli.net/2021/03/15/6mUNwJCxO1EhGsd.jpg" alt="屏幕截图 2021-03-15 102012.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;常用操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.imgdb.cn/item/608794f5d1a9ae528fb950b8.jpg&quot; alt=&quot;屏幕截图 2021-03-15 091327.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="Linux 基础" scheme="http://yoursite.com/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
    <category term="Vim" scheme="http://yoursite.com/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>「Linux 基础」Shell</title>
    <link href="http://yoursite.com/2021/03/09/Linux/linux%20Shell/"/>
    <id>http://yoursite.com/2021/03/09/Linux/linux%20Shell/</id>
    <published>2021-03-09T01:21:15.000Z</published>
    <updated>2021-03-15T09:00:16.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell-前置知识"><a href="#Shell-前置知识" class="headerlink" title="Shell 前置知识"></a>Shell 前置知识</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Shell是一个用C语言编写的程序，用户通过这个界面访问操作系统内核的服务。</p><p>Sell 脚本（shell script）是一种为shell编写的脚本程序，通常也称为shell。</p><h2 id="Shell-环境"><a href="#Shell-环境" class="headerlink" title="Shell 环境"></a>Shell 环境</h2><p>Linux 的 Shell 种类众多，常见的有：</p><ul><li>Bourne Shell（/usr/bin/sh或/bin/sh）</li><li>Bourne Again Shell（/bin/bash）</li><li>C Shell（/usr/bin/csh）</li><li>…</li></ul><p>Bash易用免费，使用广泛，并且也是多数Linux系统默认的Shell</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><code>test.sh</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo “Hello World”</span><br></pre></td></tr></table></figure><ul><li><code>#!</code>表明这个脚本需要什么解释器执行</li></ul><h3 id="1-作为可执行程序"><a href="#1-作为可执行程序" class="headerlink" title="1. 作为可执行程序"></a>1. 作为可执行程序</h3><p>cd到对应目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./test.sh  #使脚本具有执行权限</span><br><span class="line">./test.sh  #执行脚本</span><br></pre></td></tr></table></figure><h3 id="2-作为解释器参数"><a href="#2-作为解释器参数" class="headerlink" title="2. 作为解释器参数"></a>2. 作为解释器参数</h3><p>直接运行解释器，参数即shell脚本的文件名（脚本内无需在第一行指定解释器信息）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh test.sh</span><br></pre></td></tr></table></figure><h1 id="Shell-基础"><a href="#Shell-基础" class="headerlink" title="Shell 基础"></a>Shell 基础</h1><h2 id="1-Shell-变量"><a href="#1-Shell-变量" class="headerlink" title="1. Shell 变量"></a>1. Shell 变量</h2><h3 id="1-1-定义变量"><a href="#1-1-定义变量" class="headerlink" title="1.1 定义变量"></a>1.1 定义变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable_name = “shell”</span><br></pre></td></tr></table></figure><ul><li>变量名和等号之间不能有空格</li></ul><h3 id="1-2-使用变量"><a href="#1-2-使用变量" class="headerlink" title="1.2 使用变量"></a>1.2 使用变量</h3><p>使用一个定义过的变量，在变量名前加<code>$</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $variable_name</span><br><span class="line">Echo $&#123;variable_name&#125;</span><br></pre></td></tr></table></figure><ul><li><code>&#123;&#125;</code>帮助解释器识别变量边界</li></ul><h2 id="2-Shell-字符串"><a href="#2-Shell-字符串" class="headerlink" title="2. Shell 字符串"></a>2. Shell 字符串</h2><p><strong>单引号：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = ‘string’</span><br></pre></td></tr></table></figure><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li><li>单引号字串中不能出现单引号</li></ul><p><strong>双引号：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">your_name=&#x27;dhy&#x27;</span><br><span class="line">str=&quot;Hello, I know your are \&quot;$your_name\&quot;! \n&quot;</span><br></pre></td></tr></table></figure><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul><p><strong>拼接字符串</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">your_name=&quot;dhy&quot;</span><br><span class="line">greeting=&quot;hello, &quot;$your_name&quot; !&quot;</span><br><span class="line">greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;</span><br><span class="line">echo $greeting $greeting_1</span><br></pre></td></tr></table></figure><p><strong>获取字符串长度</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;abcd&quot;</span><br><span class="line">echo $&#123;#string&#125; #输出 4</span><br></pre></td></tr></table></figure><p><strong>提取子字符串</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;alibaba is a great company&quot;</span><br><span class="line">echo $&#123;string:1:4&#125; #输出liba</span><br></pre></td></tr></table></figure><p><strong>查找子字符串</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;alibaba is a great company&quot;</span><br><span class="line">echo `expr index &quot;$string&quot; is`</span><br></pre></td></tr></table></figure><h2 id="3-Shell-数组"><a href="#3-Shell-数组" class="headerlink" title="3. Shell 数组"></a>3. Shell 数组</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Shell-前置知识&quot;&gt;&lt;a href=&quot;#Shell-前置知识&quot; class=&quot;headerlink&quot; title=&quot;Shell 前置知识&quot;&gt;&lt;/a&gt;Shell 前置知识&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Linux 基础" scheme="http://yoursite.com/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
    <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>「Linux 基础」基本操作命令</title>
    <link href="http://yoursite.com/2021/03/08/Linux/Linux%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2021/03/08/Linux/Linux%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</id>
    <published>2021-03-08T01:00:15.000Z</published>
    <updated>2021-03-16T05:12:20.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录-文件"><a href="#目录-文件" class="headerlink" title="目录/文件"></a>目录/文件</h2><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ul><li><p><code>ls - list directory contents</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls [选项]... [文件]...</span><br><span class="line">选项（常用）：</span><br><span class="line">        -a      不隐藏任何以<span class="string">&quot;.&quot;</span>开始的项目</span><br><span class="line">        -l      每行只列出一个文件</span><br></pre></td></tr></table></figure></li><li><p><code>tree</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tree [选项] [目录名]</span><br><span class="line">    选项(常用)：</span><br><span class="line">        -a 列出全部文件</span><br><span class="line">        -d 只列出目录</span><br></pre></td></tr></table></figure></li><li><p><code>cat - concatenate files and print</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat [选项]... [文件]...</span><br><span class="line">选项（常用）：</span><br><span class="line">-n      对输出的所有行编号</span><br></pre></td></tr></table></figure></li></ul><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ul><li><code>mkdir - make directories</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [选项]... 目录...</span><br></pre></td></tr></table></figure></li></ul><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ul><li><p><code>rmdir - remove empty directories</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir [选项]... 目录...</span><br></pre></td></tr></table></figure><p>只有空目录才可以使用 <code>rmdir</code> 命令删除。</p></li><li><p><code>rm - remove files or directories</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm [选项]... 文件...</span><br><span class="line">选项（常用）：</span><br><span class="line">-r      递归删除目录及其内容</span><br><span class="line">-f      强制删除。忽略不存在的文件，不提示确认</span><br><span class="line">-i    需要确认，在使用文件扩展名删除多文件时有用</span><br></pre></td></tr></table></figure></li></ul><h3 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h3><ul><li><code>sed</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sed [选项] 命令 输入文本      </span><br><span class="line">    选项(常用):</span><br><span class="line">        -n:使用安静模式。在一般sed的用法中，输入文本的所有内容都会被输出。加上-n参数后，则只有经过sed 处理的内容才会被显示。</span><br><span class="line">        -e: 进行多项编辑，即对输入行应用多条sed命令时使用。</span><br><span class="line">        -i:直接修改读取的档案内容，而不是输出到屏幕。使用时应小心。       </span><br><span class="line">        </span><br><span class="line">    命令(常用)：</span><br><span class="line">        a :新增，a后紧接着\，在当前行的后面添加一行文本</span><br><span class="line">        c :取代，c后紧接着\，用新的文本取代本行的文本</span><br><span class="line">        i :插入，i后紧接着\，在当前行的上面插入一行文本</span><br><span class="line">        d :删除，删除当前行的内容</span><br><span class="line">        p :显示，把选择的内容输出。通常 p 会与参数 sed -n 一起使用。</span><br><span class="line">        s :取代，格式为s/re/string，re表示正则表达式，string为字符串，功能为将正则表达式替换为字符串。</span><br></pre></td></tr></table></figure><p>例：</p><p>输出my.txt的第三行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;3p&#x27;</span> my.txt </span><br></pre></td></tr></table></figure><p>删除my.txt文件的第二行到最后一行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;2,$d&#x27;</span> my.txt </span><br></pre></td></tr></table></figure><p>在整行范围内把str1替换为str2。如果没有g标记，则只有每行第一个匹配的str1被替换成str2。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/str1/str2/g&#x27;</span> my.txt</span><br></pre></td></tr></table></figure><p><code> -e</code>选项允许在同一行里执行多条命令。例子的第一条是第四行后添加一个<code>str</code>，第二个命令是将<code>str</code>替换为<code>aaa</code>。命令的执行顺序对结果有影响。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e <span class="string">&#x27;4a\str &#x27;</span> -e <span class="string">&#x27;s/str/aaa/&#x27;</span> my.txt </span><br></pre></td></tr></table></figure><p>双引号内可以使用变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!bin/bash</span></span><br><span class="line">sed -i <span class="string">&quot;s/<span class="variable">$2</span>/<span class="variable">$3</span>/g&quot;</span> <span class="variable">$1</span></span><br></pre></td></tr></table></figure><ul><li><code>awk</code> : 文本分析工具</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;pattern action&#x27;</span> file</span><br><span class="line">- pattern为条件，action为命令</span><br><span class="line">- <span class="variable">$n</span>代表每一行中用分隔符分隔后的第n项，默认分隔符为<span class="string">&#x27; &#x27;</span></span><br></pre></td></tr></table></figure><p>例：</p><p>所有第一项大于2的行，输出第一项和第三项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;$1&gt;2 &#123;print $1,$3&#125;&#x27;</span> my.txt</span><br></pre></td></tr></table></figure><p><code>-F指定分割的字符</code>，则输出用<code>,</code>分隔的第二项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F, <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>  my.txt</span><br></pre></td></tr></table></figure><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul><li><code>cp - copy files and directories</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp [选项]... 源文件... 目录</span><br><span class="line">选项（常用）：</span><br><span class="line">        -r      递归复制目录及其子目录内的所有内容</span><br></pre></td></tr></table></figure></li></ul><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><ul><li><code>mv - move/rename file</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [选项]... 源文件... 目录</span><br></pre></td></tr></table></figure><code>mv file ../file_mv</code> → 移动至上一层并重命名。因此重命名文件也可使用<code>mv</code>操作</li></ul><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul><li><code>diff</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">diff [选项] 文件1 文件2</span><br><span class="line">    常用选项:</span><br><span class="line">        -b 不检查空格字符的不同</span><br><span class="line">        -B 不检查空行</span><br><span class="line">        -q 仅显示有无差异，不显示详细信息</span><br></pre></td></tr></table></figure><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>Linux的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 <code>chmod</code> 可以藉以控制文件如何被他人所调</p><ul><li><code>chmod</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod 权限设定字串 文件...</span><br><span class="line">    权限设定字串格式 :</span><br><span class="line">    [ugoa...][[+-=][rwxX]...][,...]</span><br></pre></td></tr></table></figure><p>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群组，o 表示其他以外的人，a 表示这三者皆是。</p><p>+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。</p><p>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</p><p>此外<code>chmod</code>也可以用数字来表示权限，格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod abc 文件</span><br></pre></td></tr></table></figure><p>abc为三个数字，分别表示拥有者，群组，其他人的权限。<code>r=4，w=2，x=1</code>，用这些数字的加和来表示权限。例如：<code>chmod 777 file</code>和<code>chmod a=rwx file</code>效果相同。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>shell使用三种流：</p><ul><li>标准输入：stdin ，由0表示</li><li>标准输出：stdout，由1表示</li><li>标准错误：stderr，由2表示</li></ul><p>重定向和管道可以重定向以上的流。</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><ul><li><code>&gt;</code></li></ul><p>改变送出的数据信道，使<code>&gt;</code>前命令的输出数据输出到<code>&gt;</code>后指定的文件中去。</p><ul><li><code>&gt;&gt;</code></li></ul><p>重定向追加输出，将<code>&gt;&gt;</code>前命令的输出数据追加输出到<code>&gt;&gt;</code>后指定的文件中去</p><ul><li><code>&lt;</code></li></ul><p>重定向输入，将<code>&lt;</code>后指定的文件中的数据输入到<code>&lt;</code>前的命令中</p><ul><li>三种流可同时重定向</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &lt; input.txt 1&gt;output.txt 2&gt;err.txt</span><br></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul><li><code>|</code></li></ul><p>可以连接命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 | command2 | command3 | ...</span><br></pre></td></tr></table></figure><p>以上内容是将<code>command1</code>的<code>stdout</code>发给<code>command2</code>的<code>stdin</code>，<code>command2</code>的<code>stdout</code>发给<code>command3</code>的<code>stdin</code>，依此类推。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &lt; my.sh | grep <span class="string">&quot;Hello&quot;</span> &gt; output.txt<span class="string">&quot; </span></span><br></pre></td></tr></table></figure><p>上述命令将my.sh的内容作为cat指令标准输入，cat指令stdout发给grep指令的stdin，grep在其中查找字符串，最后将结果输出到output.txt。</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul><li><p><code>find - search for files in a directory hierarchy</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find -name 文件名</span><br><span class="line">-name 选项可以在当前目录下递归地查找符合参数所示文件名的文件，并将文件的路径输出至屏幕上。</span><br><span class="line">find -name <span class="string">&quot;*.py&quot;</span></span><br><span class="line">find . -name <span class="string">&quot;test*&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>locate</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate [选项] 文件名</span><br></pre></td></tr></table></figure></li></ul><p>locate也是查找文件的指令，与find的不同之处在于: find 是去硬盘找，locate 只在<code>/var/lib/slocate</code>资料库中找。locate的速度比find快，它并不是真的查找文件，而是查数据库，所以locate的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护，也可以手工升级数据库。</p><ul><li><code>grep - print lines matching a pattern</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grep [选项]... PATTERN [FILE]...</span><br><span class="line">选项（常用）：</span><br><span class="line">        -a      不忽略二进制数据进行搜索</span><br><span class="line">        -i      忽略文件大小写差异</span><br><span class="line">        -r      从文件夹递归查找</span><br><span class="line">        -n      显示行号</span><br><span class="line">grep -n <span class="built_in">echo</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li><code>Ctrl+C</code> 终止当前程序的执行。</li><li><code>Ctrl+Z</code> 挂起当前程序（挂起程序后会显示该程序挂起编号，若想要恢复该程序可以使用 <code>fg [job_spec]</code> 即可，<code>job_spec</code>即为挂起编号，不输入时默认为最近挂起进程）</li><li><code>Ctrl+D</code> 终止输入（若正在使用Shell，则退出当前Shell）</li><li><code>Ctrl+I</code> 清屏</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;目录-文件&quot;&gt;&lt;a href=&quot;#目录-文件&quot; class=&quot;headerlink&quot; title=&quot;目录/文件&quot;&gt;&lt;/a&gt;目录/文件&lt;/h2&gt;&lt;h3 id=&quot;查&quot;&gt;&lt;a href=&quot;#查&quot; class=&quot;headerlink&quot; title=&quot;查&quot;&gt;&lt;/a&gt;查&lt;/h</summary>
      
    
    
    
    <category term="Linux 基础" scheme="http://yoursite.com/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>「Linux 基础」背景</title>
    <link href="http://yoursite.com/2021/03/08/Linux/linux%E8%83%8C%E6%99%AF/"/>
    <id>http://yoursite.com/2021/03/08/Linux/linux%E8%83%8C%E6%99%AF/</id>
    <published>2021-03-08T00:21:15.000Z</published>
    <updated>2021-03-15T08:56:48.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UNIX和Linux的关系"><a href="#UNIX和Linux的关系" class="headerlink" title="UNIX和Linux的关系"></a>UNIX和Linux的关系</h2><p>Linux 是一个类 Unix 的操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。Unix 要早于 Linux。</p><p>两者之间的区别：</p><ul><li><p>UNIX 系统大多是与硬件配套的，也就是说，大多数 UNIX 系统如 AIX、HP-UX 等是无法安装在 x86 服务器和个人计算机上的，而 Linux 则可以运行在多种硬件平台上</p></li><li><p>UNIX 是商业软件，而 Linux 是开源软件，是免费、公开源代码的</p></li></ul><h2 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h2><p>UNIX/Linux系统可以粗糙地抽象为三个层次：</p><p>硬件 -&gt; [ 内核层 -&gt; Shell层 -&gt; 应用层 ] -&gt; 用户</p><h3 id="1）内核层（Kernel）"><a href="#1）内核层（Kernel）" class="headerlink" title="1）内核层（Kernel）"></a>1）内核层（Kernel）</h3><p>内核层是 UNIX/Linux 系统的核心和基础，它直接附着在硬件平台之上，控制和管理系统内各种资源（硬件资源和软件资源），有效地组织进程的运行，从而扩展硬件的功能，提高资源的利用效率，为用户提供方便、高效、安全、可靠的应用环境。</p><h3 id="2）shell层"><a href="#2）shell层" class="headerlink" title="2）shell层"></a>2）shell层</h3><p>命令解释层。用户输入的命令行由shell解释执行并输出相应结果。</p><h3 id="3）应用层"><a href="#3）应用层" class="headerlink" title="3）应用层"></a>3）应用层</h3><p>应用层提供基于 X Window 协议的图形环境。X Window 协议定义了一个系统所必须具备的功能（就如同 TCP/IP 是一个协议，定义软件所应具备的功能）</p><p>现在大多数的 UNIX 系统上（包括 Solaris、HP-UX、AIX 等）都可以运行 CDE （Common Desktop Environment，通用桌面环境，是运行于 UNIX 的商业桌面环境）的用户界面；而在 Linux 上广泛应用的有 Gnome、KDE 等。</p><p>X Window 与微软的 Windows 图形环境有很大的区别：</p><ul><li>UNIX/Linux 系统与 X Window 没有必然捆绑的关系，也就是说，UNIX/Linux 可以安装 X Window，也可以不安装；而微软的 Windows 图形环境与内核捆绑密切。</li><li>UNIX/Linux 系统不依赖图形环境，依然可以通过命令行完成 100% 的功能，而且因为不使用图形环境还会节省大量的系统资源。作为服务器部署，绝大多数 Linux 并不安装或并不启用图形环境</li></ul><h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><p>Linux命令在系统中有两种类型：内置Shell（外壳）命令和Linux命令。</p><h2 id="Linux的发行版"><a href="#Linux的发行版" class="headerlink" title="Linux的发行版"></a>Linux的发行版</h2><p>即将Linux内核与应用软件进行打包。目前市面上较知名的有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、TurboLinux、BluePoint、RedFlag、Xterm、SlackWare等。</p><h2 id="Linux应用领域"><a href="#Linux应用领域" class="headerlink" title="Linux应用领域"></a>Linux应用领域</h2><p>在服务器领域应用广泛。通常服务器使用LAMP（Linux + Apache + MySQL + PHP）或LNMP（Linux + Nginx+ MySQL + PHP）组合。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;UNIX和Linux的关系&quot;&gt;&lt;a href=&quot;#UNIX和Linux的关系&quot; class=&quot;headerlink&quot; title=&quot;UNIX和Linux的关系&quot;&gt;&lt;/a&gt;UNIX和Linux的关系&lt;/h2&gt;&lt;p&gt;Linux 是一个类 Unix 的操作系统，是一个基</summary>
      
    
    
    
    <category term="Linux 基础" scheme="http://yoursite.com/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>「OO Lab」自动评测机的搭建</title>
    <link href="http://yoursite.com/2021/03/06/ObjectOriented/%E3%80%8COO%E3%80%8D-%E8%87%AA%E5%8A%A8%E8%AF%84%E6%B5%8B%E6%9C%BA%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2021/03/06/ObjectOriented/%E3%80%8COO%E3%80%8D-%E8%87%AA%E5%8A%A8%E8%AF%84%E6%B5%8B%E6%9C%BA%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2021-03-06T11:18:06.000Z</published>
    <updated>2021-04-25T12:12:16.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="sympy库"><a href="#sympy库" class="headerlink" title="sympy库"></a><code>sympy</code>库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置自变量为x</span></span><br><span class="line">x = sympy.Symbol(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="comment"># 解析表达式</span></span><br><span class="line">f1 = sympy.sympify(<span class="string">&#x27;1-sin(x)**2&#x27;</span>)</span><br><span class="line">f2 = sympy.sympify(<span class="string">&#x27;cos(x)**2&#x27;</span>)</span><br><span class="line"><span class="comment"># 判等， == 有时会出错</span></span><br><span class="line"><span class="built_in">print</span>(f1.equals(f2))</span><br><span class="line"><span class="comment"># 表达式求导</span></span><br><span class="line"><span class="built_in">print</span>(sympy.diff(f1, x))</span><br><span class="line"><span class="built_in">print</span>(sympy.diff(f2, x))</span><br><span class="line"><span class="comment"># 表达式单点求值</span></span><br><span class="line"><span class="built_in">print</span>( f1.evalf(subs=&#123;x:math.pi&#125;) )</span><br></pre></td></tr></table></figure><h3 id="xeger库"><a href="#xeger库" class="headerlink" title="xeger库"></a><code>xeger</code>库</h3><p>根据正则表达式随机生成字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xeger <span class="keyword">import</span> Xeger</span><br><span class="line">target = Xeger().xeger(<span class="string">&quot;正则表达式&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="subprocess库"><a href="#subprocess库" class="headerlink" title="subprocess库"></a><code>subprocess</code>库</h3><p>创建子进程。<a href="https://blog.csdn.net/wanzheng_96/article/details/102470745?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">参考</a></p><ol><li><code>Popen</code> → 创建一个新的进程执行命令，返回一个实例，进行后续操作</li></ol><ul><li><p><code>Popen.poll()</code></p><p>用于检查子进程是否已经结束。</p></li><li><p><code>Popen.wait(timeout=None)</code></p><p>在规定时间内等待进程结束，设置 timeout=None，则一直等待直到结束</p><p>返回：<code>returncode</code></p></li><li><p><code>Popen.communicate(input=None)</code></p><ul><li>与子进程进行交互。向stdin发送数据并关闭它。可选参数input指定发送到子进程的数据，注意 <code>Popen</code>对象的<strong>encoding或者text参数</strong>决定传入字符串还是字节流。</li><li>从<code>stdout</code>和<code>stderr</code>中读取数据, 并关闭。如果没有数据发送到子进程（stdin），则返回一个元组：<code>(stdoutdata, stderrdata)</code>。</li><li>注：如果希望通过进程的<code>stdin</code>向其发送数据，在创建<code>Popen</code>对象的时候，参数<code>stdin</code>必须被设置为<code>PIPE</code>。同样，如果希望从<code>stdout</code>和<code>stderr</code>获取数据，必须将<code>stdout</code>和<code>stderr</code>设置为<code>PIPE</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">subp = subprocess.Popen(command, shell=<span class="literal">True</span>, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE,</span><br><span class="line">                            encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">subp.communicate(data)</span><br><span class="line"><span class="keyword">if</span> subp.poll() == <span class="number">0</span>:</span><br><span class="line">    res = subp.communicate()[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    res = <span class="string">&quot;失败&quot;</span></span><br><span class="line">subp.kill()</span><br></pre></td></tr></table></figure></li><li><p><code>Popen.kill()</code></p><p>在 Posix 操作系统上，此函数给子进程发送 <code>SIGKILL</code> 信号。在 Windows 上， <code>kill()</code> 是 <code>terminate()</code> 的别名。</p></li></ul><h3 id="递归下降语法分析"><a href="#递归下降语法分析" class="headerlink" title="递归下降语法分析"></a>递归下降语法分析</h3><ul><li>形式化表述：<ul><li>表达式 → 空白项 [加减 空白项] 项 空白项 | 表达式 加减 空白项 项 空白项</li><li>项 → [加减 空白项] 因子 | 项 空白项 * 空白项 因子</li><li>因子 → 变量因子 | 常数因子 | 表达式因子</li><li>变量因子 → 幂函数 | 三角函数</li><li>常数因子 → 带符号的整数</li><li>表达式因子 → ‘(‘ 表达式 ‘)’</li><li>三角函数 → sin 空白项 ‘(‘ 空白项 因子 空白项 ‘)’ [空白项 指数] | cos 空白项 ‘(‘ 空白项 因子 空白项 ‘)’ [空白项 指数]</li><li>幂函数 → x [空白项 指数]</li><li>指数 → ** 空白项 带符号的整数</li><li>带符号的整数 → [加减] 允许前导零的整数</li><li>允许前导零的整数 → (0|1|2|…|9){0|1|2|…|9}</li><li>空白字符 → <code>（空格）</code> | <code>\t</code>（水平制表符）</li><li>空白项 → {空白字符}</li><li>加减 → + | -</li></ul></li><li>构建与法分析树：</li></ul><p><img src="https://i.loli.net/2021/03/07/cdqCSgjaXTpMD4F.png" alt="_  1.png"></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="数据构造"><a href="#数据构造" class="headerlink" title="数据构造"></a>数据构造</h3><ul><li>常量池机制：</li></ul><p>即提前设计好需要使用的常数，存在数组里面，每次需要随机生成常数的时候，随机的不是数而是数组下标。</p><ul><li>构造数据用途分类</li></ul><p><code>sympy</code>库的解析式中前导零被判定为不合法的，我们构造数据时可以生成相等的两组分别含与不含前导零的数据来用作测试和得到正确答案</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>打<code>jar</code>包</li></ul><p>step1：</p><p>准备<code>MANIFEST.MF</code>，并在其中写入如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Main-Class: MainClass</span><br></pre></td></tr></table></figure><p>其中<code>Main-Class</code>后面是主类，后面需要加个回车，否则容易出奇怪的bug</p><p>step2：</p><p>编译<code>.java</code>文件，<code>cd</code>到那一堆<code>.java</code>文件夹里面，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar cvfm MainClass.jar MANIFEST.MF *.class</span><br></pre></td></tr></table></figure><p>step3：</p><p>把所有<code>.class</code>和<code>.MF</code>放在一个文件夹里，终端执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar cvfm MainClass.jar MANIFEST.MF *.class</span><br></pre></td></tr></table></figure><p>step4：</p><p>验证打包是否成功，可以终端执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar MainClass.jar</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>有时IDEA打开别人的项目时，突然飘红，出现红色的波浪下划线，错误提示：<code>cannot access com.xx......xx.class</code>，无法访问同一个包下的类，根本原因是IDEA缓存出现问题，可以强制删除缓存。</p><p><code>File -&gt; Invalidate Caches /Restart</code> </p><hr><p>评测姬：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> xeger <span class="keyword">import</span> Xeger</span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">DATE_FOR_SDTIN = <span class="number">0</span></span><br><span class="line">DATE_FOR_EVALUATION = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">MANUAL = <span class="number">0</span></span><br><span class="line">MACHINE = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataGenerator</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.FACTOR_MAX_PER_TERM = <span class="number">6</span></span><br><span class="line">        self.TERM_MAX_PER_POLY = <span class="number">10</span></span><br><span class="line">        self.constant_pool = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">2147483647</span>,</span><br><span class="line">                              <span class="number">5219260817</span>, <span class="number">5419260817</span>, <span class="number">9223372036854775807</span>,</span><br><span class="line">                              <span class="number">19260817192608172333</span>, <span class="number">19260817192608174666</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addsub</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> random.randint(<span class="number">0</span>, <span class="number">1</span>) &amp; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;+&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;-&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">self</span>):</span></span><br><span class="line">        index = self.signedInt()</span><br><span class="line">        blank = self.blankFactor()</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&quot;**&quot;</span> + blank + <span class="built_in">str</span>(index[<span class="number">0</span>]), <span class="string">&quot;**&quot;</span> + blank + <span class="built_in">str</span>(index[<span class="number">1</span>])]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">blankFactor</span>(<span class="params">self</span>):</span></span><br><span class="line">        blank_factor = Xeger().xeger(<span class="string">&quot;[\t ]&#123;0,4&#125;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> blank_factor</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">signedInt</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> random.randint(<span class="number">0</span>, <span class="number">2</span>) == <span class="number">0</span>:</span><br><span class="line">            char = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            char = self.addsub()</span><br><span class="line">        index = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(self.constant_pool) - <span class="number">1</span>)</span><br><span class="line">        constant = self.constant_pool[index]</span><br><span class="line">        pre_zero = Xeger().xeger(<span class="string">&quot;0&#123;0,4&#125;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> [char + <span class="built_in">str</span>(pre_zero) + <span class="built_in">str</span>(constant), char + <span class="built_in">str</span>(constant)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">powerFunction</span>(<span class="params">self</span>):</span></span><br><span class="line">        blank = self.blankFactor()</span><br><span class="line">        <span class="keyword">if</span> random.randint(<span class="number">0</span>, <span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">            index = self.index()</span><br><span class="line">            index_list = [blank + index[<span class="number">0</span>], blank + index[<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            index_list = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>]</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&quot;x&quot;</span> + blank + index_list[<span class="number">0</span>], <span class="string">&quot;x&quot;</span> + blank + index_list[<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">triangleFactor</span>(<span class="params">self</span>):</span></span><br><span class="line">        blank = self.blankFactor()</span><br><span class="line">        index = self.index()</span><br><span class="line">        <span class="keyword">if</span> random.randint(<span class="number">0</span>, <span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> random.randint(<span class="number">0</span>, <span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> [<span class="string">&quot;sin&quot;</span> + blank + <span class="string">&quot;(&quot;</span> + blank + <span class="string">&quot;x&quot;</span> + blank + <span class="string">&quot;)&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;sin&quot;</span> + blank + <span class="string">&quot;(&quot;</span> + blank + <span class="string">&quot;x&quot;</span> + blank + <span class="string">&quot;)&quot;</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [<span class="string">&quot;sin&quot;</span> + blank + <span class="string">&quot;(&quot;</span> + blank + <span class="string">&quot;x&quot;</span> + blank + <span class="string">&quot;)&quot;</span> + blank + index[<span class="number">0</span>],</span><br><span class="line">                        <span class="string">&quot;sin&quot;</span> + blank + <span class="string">&quot;(&quot;</span> + blank + <span class="string">&quot;x&quot;</span> + blank + <span class="string">&quot;)&quot;</span> + blank + index[<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> random.randint(<span class="number">0</span>, <span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> [<span class="string">&quot;cos&quot;</span> + blank + <span class="string">&quot;(&quot;</span> + blank + <span class="string">&quot;x&quot;</span> + blank + <span class="string">&quot;)&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;cos&quot;</span> + blank + <span class="string">&quot;(&quot;</span> + blank + <span class="string">&quot;x&quot;</span> + blank + <span class="string">&quot;)&quot;</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [<span class="string">&quot;cos&quot;</span> + blank + <span class="string">&quot;(&quot;</span> + blank + <span class="string">&quot;x&quot;</span> + blank + <span class="string">&quot;)&quot;</span> + blank + index[<span class="number">0</span>],</span><br><span class="line">                        <span class="string">&quot;cos&quot;</span> + blank + <span class="string">&quot;(&quot;</span> + blank + <span class="string">&quot;x&quot;</span> + blank + <span class="string">&quot;)&quot;</span> + blank + index[<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expFactor</span>(<span class="params">self</span>):</span></span><br><span class="line">        exp = self.getPolynome()</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&quot;(&quot;</span> + exp[<span class="number">0</span>] + <span class="string">&quot;)&quot;</span>, <span class="string">&quot;(&quot;</span> + exp[<span class="number">1</span>] + <span class="string">&quot;)&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getFactor</span>(<span class="params">self</span>):</span></span><br><span class="line">        select = random.randint(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">if</span> select == <span class="number">0</span>:</span><br><span class="line">            factor = self.powerFunction()</span><br><span class="line">        <span class="keyword">elif</span> select == <span class="number">1</span>:</span><br><span class="line">            factor = self.signedInt()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            factor = self.triangleFactor()</span><br><span class="line">        <span class="keyword">return</span> factor</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getTerm</span>(<span class="params">self, term_depth=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> term_depth &gt; self.FACTOR_MAX_PER_TERM:</span><br><span class="line">            pre_char = Xeger().xeger(<span class="string">&quot;[&quot;</span> + self.addsub() + self.blankFactor() + <span class="string">&quot;]?&quot;</span>)</span><br><span class="line">            factor = self.getFactor()</span><br><span class="line">            <span class="keyword">return</span> [pre_char + factor[<span class="number">0</span>], pre_char + factor[<span class="number">1</span>]]</span><br><span class="line">        term = self.getTerm(term_depth=term_depth + <span class="number">1</span>)</span><br><span class="line">        multiply_char = self.blankFactor() + <span class="string">&quot;*&quot;</span> + self.blankFactor()</span><br><span class="line">        factor = self.getFactor()</span><br><span class="line">        <span class="keyword">return</span> [term[<span class="number">0</span>] + multiply_char + factor[<span class="number">0</span>], term[<span class="number">1</span>] + multiply_char + factor[<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPolynome</span>(<span class="params">self, poly_depth=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> poly_depth &gt; self.TERM_MAX_PER_POLY:</span><br><span class="line">            pre_char = self.blankFactor() + Xeger().xeger(<span class="string">&quot;[&quot;</span> + self.addsub() + self.blankFactor() + <span class="string">&quot;]?&quot;</span>)</span><br><span class="line">            term = self.getTerm()</span><br><span class="line">            blank = self.blankFactor()</span><br><span class="line">            <span class="keyword">return</span> [pre_char + term[<span class="number">0</span>] + blank, pre_char + term[<span class="number">1</span>] + blank]</span><br><span class="line">        poly = self.getPolynome(poly_depth + <span class="number">1</span>)</span><br><span class="line">        pre_char = self.addsub() + self.blankFactor()</span><br><span class="line">        blank = self.blankFactor()</span><br><span class="line">        term = self.getTerm()</span><br><span class="line">        <span class="keyword">return</span> [poly[<span class="number">0</span>] + pre_char + term[<span class="number">0</span>] + blank, poly[<span class="number">1</span>] + pre_char + term[<span class="number">1</span>] + blank]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.getPolynome()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPolyDiff</span>(<span class="params">poly</span>):</span></span><br><span class="line">    x = sympy.Symbol(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    f = sympy.sympify(poly)</span><br><span class="line">    <span class="keyword">return</span> sympy.diff(f, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span>(<span class="params">command, data</span>):</span></span><br><span class="line">    subp = subprocess.Popen(command, shell=<span class="literal">True</span>, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE,</span><br><span class="line">                            encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    subp.communicate(data)</span><br><span class="line">    <span class="keyword">if</span> subp.poll() == <span class="number">0</span>:</span><br><span class="line">        res = subp.communicate()[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res = <span class="string">&quot;失败&quot;</span></span><br><span class="line">    subp.kill()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judgeSingleDate</span>(<span class="params">judge_object, mode, manual_data=<span class="string">&quot;&quot;</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> mode == MACHINE:</span><br><span class="line">        poly_list = DataGenerator().getPolynome()</span><br><span class="line">        poly_for_evaluation = poly_list[DATE_FOR_EVALUATION]</span><br><span class="line">        poly_for_test = poly_list[DATE_FOR_SDTIN]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;data: &quot;</span>, poly_for_evaluation)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;data_for_test: &quot;</span>, poly_for_test)</span><br><span class="line">        diff_ans = getPolyDiff(poly_for_evaluation)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;correct answer: &quot;</span>, diff_ans)</span><br><span class="line">        jar_ans = cmd(<span class="string">&quot;java -jar &quot;</span> + judge_object, poly_for_test)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;your answer: &quot;</span>, jar_ans)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;your identity: &quot;</span>, judge_object)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s is right: &quot;</span> % judge_object, diff_ans.equals(jar_ans))</span><br><span class="line">        <span class="keyword">return</span> diff_ans.equals(jar_ans)</span><br><span class="line">    <span class="keyword">if</span> mode == MANUAL:</span><br><span class="line">        expData = manual_data</span><br><span class="line">        diff_ans = getPolyDiff(expData)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;correct answer: &quot;</span>, diff_ans)</span><br><span class="line">        jar_ans = cmd(<span class="string">&quot;java -jar &quot;</span> + judge_object, expData)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;your answer: &quot;</span>, jar_ans)</span><br><span class="line">        <span class="keyword">if</span> jar_ans.strip() != <span class="string">&quot;WRONG FORMAT!&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s is right: &quot;</span> % judge_object, diff_ans.equals(jar_ans))</span><br><span class="line">            <span class="keyword">return</span> diff_ans.equals(jar_ans)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judge</span>(<span class="params">judge_list, mode, count=<span class="number">200</span></span>):</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; count:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;----------------------------------&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;data &quot;</span>, index, <span class="string">&quot; :&quot;</span>)</span><br><span class="line">        error_name_list = []</span><br><span class="line">        <span class="keyword">if</span> mode == MANUAL:</span><br><span class="line">            expData = <span class="built_in">input</span>(<span class="string">&quot;your data: &quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> judge_object <span class="keyword">in</span> judge_list:</span><br><span class="line">            right = judgeSingleDate(judge_object, mode=mode, manual_data=expData)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> right:</span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">                error_name_list.append(judge_object)</span><br><span class="line">        <span class="keyword">if</span> found:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;ERROR!!!!!!!!!!!!!&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error person: &quot;</span>, error_name_list)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        index = index + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Congratulations! you all killed!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    judgelist = [<span class="string">&quot;Alterego.jar&quot;</span>, <span class="string">&quot;Archer.jar&quot;</span>, <span class="string">&quot;Assassin.jar&quot;</span>, <span class="string">&quot;Berserker.jar&quot;</span>, <span class="string">&quot;Caster.jar&quot;</span>, <span class="string">&quot;Rider.jar&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;oo_hw_3.jar&quot;</span>, <span class="string">&quot;saber.jar&quot;</span>]</span><br><span class="line">    judge(judgelist, MANUAL)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h2&gt;&lt;h3 id=&quot;sympy库&quot;&gt;&lt;a href=&quot;#sympy库&quot; class=&quot;headerlink&quot; title=&quot;sympy</summary>
      
    
    
    
    <category term="ObjectOriented" scheme="http://yoursite.com/categories/ObjectOriented/"/>
    
    
    <category term="OO" scheme="http://yoursite.com/tags/OO/"/>
    
    <category term="评测机" scheme="http://yoursite.com/tags/%E8%AF%84%E6%B5%8B%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥-往届省赛</title>
    <link href="http://yoursite.com/2021/03/01/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E8%93%9D%E6%A1%A5-%E7%AC%AC9%E5%B1%8A%E7%9C%81%E8%B5%9B/"/>
    <id>http://yoursite.com/2021/03/01/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E8%93%9D%E6%A1%A5-%E7%AC%AC9%E5%B1%8A%E7%9C%81%E8%B5%9B/</id>
    <published>2021-03-01T04:22:16.000Z</published>
    <updated>2021-04-27T03:46:44.304Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三体攻击"><a href="#三体攻击" class="headerlink" title="三体攻击"></a>三体攻击</h2><p>三体人将对地球发起攻击。为了抵御攻击，地球人派出了 A × B × C 艘战舰，在太空中排成一个 A 层 B 行 C 列的立方体。其中，第 i 层第 j 行第 k 列的战舰（记为战舰 (i, j, k)）的生命值为 d(i, j, k)。</p><p>三体人将会对地球发起 m 轮“立方体攻击”，每次攻击会对一个小立方体中的所有战舰都造成相同的伤害。具体地，第 t 轮攻击用 7 个参数 lat, rat, lbt, rbt, lct, rct, ht 描述：所有满足 i ∈ [lat, rat],j ∈ [lbt, rbt],k ∈ [lct, rct] 的战舰 (i, j, k) 会受到 ht 的伤害。如果一个战舰累计受到的总伤害超过其防御力，那么这个战舰会爆炸。地球指挥官希望你能告诉他，第一艘爆炸的战舰是在哪一轮攻击后爆炸的。</p><p>输入格式： 从标准输入读入数据。第一行包括 4 个正整数 A, B, C, m；</p><p>第二行包含 A × B × C 个整数，其中第 (i − 1) × B × C + (j − 1) × C + k个数为 d(i, j, k)；</p><p>第 3 到第 m + 2 行中，第 (t + 2) 行包含 7 个正整数 lat, rat, lbt, rbt, lct, rct, ht。</p><p>输出格式： 输出到标准输出。输出第一个爆炸的战舰是在哪一轮攻击后爆炸的。保证一定存在这样的战舰。</p><p>样例输入：</p><blockquote><p>2 2 2 3<br>1 1 1 1 1 1 1 1<br>1 2 1 2 1 1 1<br>1 1 1 2 1 2 1<br>1 1 1 1 1 1 2</p></blockquote><p>样例输出： 2</p><p>样例解释： 在第 2 轮攻击后，战舰 (1,1,1) 总共受到了 2 点伤害，超出其防御力导致爆炸。</p><p>数据约定： 对于 10% 的数据，B = C = 1； 对于 20% 的数据，C = 1； 对于 40% 的数据，A × B × C, m ≤ 10, 000； 对于 70% 的数据，A, B, C ≤ 200； 对于所有数据，A × B × C ≤ 10^6, m ≤ 10^6, 0 ≤ d(i, j, k), ht ≤ 10^9。</p><h2 id="正则问题"><a href="#正则问题" class="headerlink" title="正则问题"></a>正则问题</h2><p>考虑一种简单的正则表达式：只由 x、( )、| 组成。求出这个正则表达式能接受的最长字符串的长度。</p><p>例如， ((xx|xxx)x|(x|xx))xx 能接受的最长字符串是： xxxxxx，长度是6。</p><p>输入：</p><blockquote><p>一个由x、()、 |组成的正则表达式。输入长度不超过100，保证合法。</p></blockquote><p>输出：</p><blockquote><p>这个正则表达式能接受的最长字符串的长度。</p></blockquote><p>输入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((xx|xxx)x|(x|xx))xx</span><br></pre></td></tr></table></figure><p>程序应该输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><hr><p>把正则表达式分为两部分：</p><ul><li>一部分是原表达式中由括号组成的一个更小的子表达式。</li><li>另一部分则为原表达式中非括号部分。</li></ul><p>例如样例中的<code>((xx|xxx)x|(x|xx))xx</code>这个表达式分为：</p><ul><li><code>((xx|xxx)x|(x|xx))</code>即原式括号内的子表达式。当然，这个子表达式中还有更小的子表达式。</li><li><code>XX</code>即原式中的非括号部分。</li></ul><p>我们循环遍历每个字符，计数所能接受的最长字符串的长度，同时，每遇到一个子表达式，我们递归地去求解这个表达式接受的最大长度。也就是说，每层递归中，我们遍历当前子表达式，每个字符有4种可能：</p><ul><li>(，说明即将遇到一个子表达式，递归求解该子表达式的长度，累加到当前结果cur。</li><li>)，递归边界，说明一个子表达式结束，返回结果<code>Math.max(cur, pre)</code>，其中，pre用于记录当前表达式中|符号前面的最大长度。</li><li>|，说明该符号前后两侧均有一个长度，我们要取两者中较大者，因此需要用变量pre记录之前的结果。</li><li>X，增加当前X字符的数量。</li></ul><p>最后，指针p遍历完表达式返回结果<code>Math.max(cur, pre)</code>。</p><hr><h1 id="第七届"><a href="#第七届" class="headerlink" title="第七届"></a>第七届</h1><h2 id="8-取球博弈"><a href="#8-取球博弈" class="headerlink" title="8 取球博弈"></a>8 取球博弈</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>两个人玩取球的游戏。一共有N个球，每人轮流取球，每次可取集合{n1,n2,n3}中的任何一个数目。如果无法继续取球，则游戏结束。此时，持有奇数个球的一方获胜。如果两人都是奇数，则为平局。假设双方都采用最聪明的取法，第一个取球的人一定能赢吗？试编程解决这个问题。</p><p>输入格式：</p><blockquote><p>第一行3个正整数n1 n2 n3，空格分开，表示每次可取的数目 (0&lt;n1,n2,n3&lt;100)<br>第二行5个正整数x1 x2 … x5，空格分开，表示5局的初始球数(0&lt;xi&lt;1000)</p></blockquote><p>输出格式：</p><blockquote><p>一行5个字符，空格分开。分别表示每局先取球的人能否获胜。能获胜则输出+，次之，如有办法逼平对手，输出0，无论如何都会输，则输出-</p></blockquote><p>例如，输入：</p><blockquote><p>1 2 3<br>1 2 3 4 5</p></blockquote><p>程序应该输出：</p><blockquote><p>+ 0 + 0 -</p></blockquote><p>再例如，输入：</p><blockquote><p>1 4 5<br>10 11 12 13 15</p></blockquote><p>程序应该输出：</p><blockquote><p>0 - 0 + +</p></blockquote><p>再例如，输入：</p><blockquote><p>2 3 5<br>7 8 9 10 11</p></blockquote><p>程序应该输出：</p><blockquote><p>+ 0 0 0 0</p></blockquote><p>再例如，输入：</p><blockquote><p>1 7 8<br>900 901 903 905 907</p></blockquote><p>程序应该输出：</p><blockquote><p>0 + - - +</p></blockquote><p>资源约定：</p><blockquote><p>峰值内存消耗（含虚拟机） &lt; 256M<br>CPU消耗 &lt; 3000ms</p></blockquote><p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。注意：主类的名字必须是：Main，否则按无效代码处理。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>形如这样的博弈题，我们都可以递归去枚举所有局面然后得出胜负。但本题需要注意的是球数比较多，而可取的球数又可能比较少，这样递归的深度会很大，导致无法通过所有测试样例，因此我们需要使用记忆化递归。</p><p>此外，还需要注意到，博弈局面与两方所持球数无关，而与所持球数的奇偶有关，因此我们可以只记录奇偶（1和0）而不记录具体球数。</p><p>递归过程中，我们首先去判断是否曾经记录过当前局面，若记录过则直接返回记录的结果，否则枚举所有可取球数的情况（共3种），这里要注意，当前人取球后，便成为下个取球人，而另一个人则在下次递归中成为当前取球人，因此要注意方法中参数的变化。当无法继续取球时，直接根据奇偶判定结果。返回当前局面的胜负之前，要先记录。</p><p>其他实现细节请参考代码中的详细注释。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] take = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];<span class="comment">// 记录可取的球数</span></span><br><span class="line">    <span class="comment">// 三维字符数组map用于记忆化递归</span></span><br><span class="line">    <span class="comment">// 剩余cnt个球时，当前取球人有cur个球，下个取球人有next个球</span></span><br><span class="line">    <span class="comment">// map[cnt][cur][next]记录上局面下当前取球人取球得到的结果</span></span><br><span class="line">    <span class="comment">// 又由于博弈结果只与奇偶有关，因此cur与next不记录具体球数，而用0表示偶数，1表示奇数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Character[][][] map = <span class="keyword">new</span> Character[<span class="number">1000</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            take[i] = sc.nextInt();</span><br><span class="line">        Arrays.sort(take);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            System.out.print(play(sc.nextInt(), <span class="number">0</span>, <span class="number">0</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记忆化递归得到博弈结果，由于结果只与奇偶有关，因此参数不记录具体球数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cnt  剩余球数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cur  当前取球人球数的奇偶</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 下个取球人球数的奇偶</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">play</span><span class="params">(<span class="keyword">int</span> cnt, <span class="keyword">int</span> cur, <span class="keyword">int</span> next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map[cnt][cur][next] != <span class="keyword">null</span>) <span class="comment">// 当前局面曾经记录过则直接返回</span></span><br><span class="line">            <span class="keyword">return</span> map[cnt][cur][next];</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; take[<span class="number">0</span>]) &#123;<span class="comment">// 无法继续取球则直接判定结果</span></span><br><span class="line">            <span class="keyword">if</span> ((cur &amp; <span class="number">1</span>) == <span class="number">1</span> &amp;&amp; (next &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> ((cur &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (next &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> tie = <span class="keyword">false</span>;<span class="comment">// 记录是否能平局</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (take[i] &gt; cnt)<span class="comment">// 不够取</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 注意play方法后两个参数的变化</span></span><br><span class="line">            <span class="comment">// 当前取球人取完后，便成为下个取球人，另一个人则成为新的当前取球人</span></span><br><span class="line">            <span class="comment">// 当前取球人取完，下个取球人成为当前取球人去取球</span></span><br><span class="line">            <span class="keyword">char</span> res = play(cnt - take[i], next, cur + take[i] &amp; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="string">&#x27;-&#x27;</span>) &#123;<span class="comment">// 新的取球人输了，说明旧的取球人能赢</span></span><br><span class="line">                map[cnt][cur][next] = <span class="string">&#x27;+&#x27;</span>;<span class="comment">// 记录结果</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="string">&#x27;0&#x27;</span>) &#123;<span class="comment">// 出现过平局</span></span><br><span class="line">                tie = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tie) &#123;<span class="comment">// 不能赢，能平则平</span></span><br><span class="line">            map[cnt][cur][next] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map[cnt][cur][next] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-压缩变换"><a href="#10-压缩变换" class="headerlink" title="10 压缩变换"></a>10 压缩变换</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>小明最近在研究压缩算法。他知道，压缩的时候如果能够使得数值很小，就能通过熵编码得到较高的压缩比。然而，要使数值很小是一个挑战。最近，小明需要压缩一些正整数的序列，这些序列的特点是，后面出现的数字很大可能是刚出现过不久的数字。对于这种特殊的序列，小明准备对序列做一个变换来减小数字的值。变换的过程如下： 从左到右枚举序列，每枚举到一个数字，如果这个数字没有出现过，则将数字变换成它的相反数，如果数字出现过，则看它在原序列中最后的一次出现后面（且在当前数前面）出现了几种数字，用这个种类数替换原来的数字。比如，序列(a1, a2, a3, a4, a5)=(1, 2, 2, 1, 2)在变换过程为： a1: 1未出现过，所以a1变为-1； a2: 2未出现过，所以a2变为-2； a3: 2出现过，最后一次为原序列的a2，在a2后、a3前有0种数字，所以a3变为0； a4: 1出现过，最后一次为原序列的a1，在a1后、a4前有1种数字，所以a4变为1； a5: 2出现过，最后一次为原序列的a3，在a3后、a5前有1种数字，所以a5变为1。 现在，给出原序列，请问，按这种变换规则变换后的序列是什么。</p><p>输入格式：</p><blockquote><p>输入第一行包含一个整数n，表示序列的长度。<br>第二行包含n个正整数，表示输入序列。</p></blockquote><p>输出格式：</p><blockquote><p>输出一行，包含n个数，表示变换后的序列。</p></blockquote><p>例如，输入：</p><blockquote><p>5<br>1 2 2 1 2</p></blockquote><p>程序应该输出：</p><blockquote><p>-1 -2 0 1 1</p></blockquote><p>再例如，输入：</p><blockquote><p>12<br>1 1 2 3 2 3 1 2 2 2 3 1</p></blockquote><p>程序应该输出：</p><blockquote><p>-1 0 -2 -3 1 1 2 2 0 0 2 2</p></blockquote><p>数据规模与约定：</p><blockquote><p>对于30%的数据，n&lt;=1000； 对于50%的数据，n&lt;=30000； 对于100%的数据，1 &lt;=n&lt;=100000，1&lt;=ai&lt;=10^9</p></blockquote><p>资源约定：</p><blockquote><p>峰值内存消耗（含虚拟机） &lt; 256M<br>CPU消耗 &lt; 3000ms</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>题意不难，我们在得到一个重复出现的数字后，需要查询该位置和它上一次出现的位置之间含有的不重复数的个数，暴力求解是会超时的。我们不妨尝试线段树这种适合多次区间查询的数据结构，同时搭配使用哈希表，记录每个数最后一次出现的位置。</p><p>接下来的问题在于线段树的结点要维护什么？我们建立一个表示下标0到n-1区间的线段树，每个结点维护一个值，用于表示该区间内有几个不重复数。这样一来，我们遇到一个重复出现的数后，就在线段树中查询对应区间，得到不重复数的个数，作为压缩结果；遇到一个未出现过的数，就用相反数作为压缩结果。我们用哈希表来判断一个数是否出现过，以上就是解题的主要思路。</p><p>由于线段树结点中记录的是区间内不重复数的个数，所以我们要在线段树内去重。具体来说，若得到一个未出现过的数，用相反数作为压缩结果后，将其存入哈希表，同时存入线段树，即令树中所有包含它的区间的结点值加一，表示该区间内多了这个不重复数；若得到一个出现过的数，我们查询哈希表得到上一次出现的位置，由此得到一个查询区间，我们要在线段树中查询这个区间内有多少个不重复的数，要注意，我们此后必须更新哈希表，更新线段树（两次）。具体做法：由于线段树维护的是区间中不重复数的个数，而当前数又是重复出现过的，所以我们需要在该数上一次出现的所有区间内删除它，表示这些区间少了这个数，这个数将出现在新的区间中，表示新区间多了这个不重复数（因为之前的区间已做了删除，所以它目前就是不重复数），这一减一增是对线段树的两次更新。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线段树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L, R;<span class="comment">// 所维护的区间的左右端点</span></span><br><span class="line">        <span class="keyword">int</span> cnt;<span class="comment">// 结点值，即某数最后一次出现的位置是否在此，是则为1，否则为0</span></span><br><span class="line">        SegmentTree left, right;<span class="comment">// 左右子树</span></span><br><span class="line"></span><br><span class="line">        SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">            L = l;</span><br><span class="line">            R = r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            a[i] = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">// 哈希表记录各数最后一次出现的下标</span></span><br><span class="line">        SegmentTree root = buildST(<span class="number">0</span>, n - <span class="number">1</span>);<span class="comment">// 线段树维护0至n-1这个下标区间，记录有几个不重复数在此区间内最后一次出现</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(a[i])) &#123;<span class="comment">// 第一次出现</span></span><br><span class="line">                ans[i] = -a[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 得到最后一次出现的位置</span></span><br><span class="line">                <span class="keyword">int</span> lastidx = map.get(a[i]);</span><br><span class="line">                <span class="comment">// 查询这个区间内有几个不重复数最后一次出现</span></span><br><span class="line">                <span class="comment">// 之所以统计的是最后一次出现的数的个数是为了不重复</span></span><br><span class="line">                <span class="comment">// 所以接下来要将该数上次出现的位置置0，因为现在有新的最后一次出现的位置</span></span><br><span class="line">                <span class="comment">// 若不置0，同样的数会被重复计算，得到的就不是该区间内不重复数的个数</span></span><br><span class="line">                ans[i] = query(root, lastidx + <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">                update(root, lastidx, -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(a[i], i);<span class="comment">// 更新最后一次出现的位置</span></span><br><span class="line">            update(root, i, <span class="number">1</span>);<span class="comment">// 在新的位置处置1，表示在该区间内最后一次出现，上次出现的位置已置0，防止重复统计</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : ans)</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> L 线段树左端点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> R 线段树右端点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SegmentTree <span class="title">buildST</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R)<span class="comment">// 到达叶子结点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SegmentTree(L, R);</span><br><span class="line">        SegmentTree root = <span class="keyword">new</span> SegmentTree(L, R);</span><br><span class="line">        <span class="keyword">int</span> mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 递归构建左右子树</span></span><br><span class="line">        root.left = buildST(L, mid);</span><br><span class="line">        root.right = buildST(mid + <span class="number">1</span>, R);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对结点进行更新，自底向上更新区间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 需要更新的子树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> idx  要更新的叶子结点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val  增量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(SegmentTree root, <span class="keyword">int</span> idx, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.L == root.R) &#123;<span class="comment">// 到达叶子结点</span></span><br><span class="line">            root.cnt += val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = root.L + root.R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (idx &lt;= mid)<span class="comment">// 需要更新左子树</span></span><br><span class="line">            update(root.left, idx, val);</span><br><span class="line">        <span class="keyword">else</span><span class="comment">// 需要更新右子树</span></span><br><span class="line">            update(root.right, idx, val);</span><br><span class="line">        root.cnt = root.left.cnt + root.right.cnt;<span class="comment">// 更新根结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 区间查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root  查询的子树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> begin 查询区间的起点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   查询区间的终点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(SegmentTree root, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt; end) <span class="comment">// 可能存在不合法区间，则该区间查询结果为0，表示这没有不重复的数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.L == begin &amp;&amp; root.R == end)<span class="comment">// 结点与查询区间吻合，直接返回结点值</span></span><br><span class="line">            <span class="keyword">return</span> root.cnt;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = root.L + root.R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (begin &lt;= mid) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end &lt;= mid)<span class="comment">// 整个区间在左子树</span></span><br><span class="line">                res = query(root.left, begin, end);</span><br><span class="line">            <span class="keyword">else</span><span class="comment">// 区间横跨左右子树</span></span><br><span class="line">                res = query(root.left, begin, mid) + query(root.right, mid + <span class="number">1</span>, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 整个区间在右子树</span></span><br><span class="line">            res = query(root.right, begin, end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;三体攻击&quot;&gt;&lt;a href=&quot;#三体攻击&quot; class=&quot;headerlink&quot; title=&quot;三体攻击&quot;&gt;&lt;/a&gt;三体攻击&lt;/h2&gt;&lt;p&gt;三体人将对地球发起攻击。为了抵御攻击，地球人派出了 A × B × C 艘战舰，在太空中排成一个 A 层 B 行 C 列的立</summary>
      
    
    
    
    <category term="Algorithm problems" scheme="http://yoursite.com/categories/Algorithm-problems/"/>
    
    
    <category term="algorithmic questions" scheme="http://yoursite.com/tags/algorithmic-questions/"/>
    
    <category term="蓝桥杯" scheme="http://yoursite.com/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="差分" scheme="http://yoursite.com/tags/%E5%B7%AE%E5%88%86/"/>
    
    <category term="前缀和" scheme="http://yoursite.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>「Java」容器</title>
    <link href="http://yoursite.com/2021/03/01/Java/5-java%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2021/03/01/Java/5-java%E5%AE%B9%E5%99%A8/</id>
    <published>2021-03-01T02:44:17.000Z</published>
    <updated>2021-05-01T09:18:42.654Z</updated>
    
    <content type="html"><![CDATA[<p>常见的各个容器的继承关系：</p><p><img src="https://i.loli.net/2021/03/01/rl4tPN1WsqybxdK.jpg" alt="屏幕截图 2021-03-01 103049.jpg"></p><h1 id="Iterable-接口"><a href="#Iterable-接口" class="headerlink" title="Iterable 接口"></a>Iterable 接口</h1><p><code>Iterable</code>是一个超级接口，被Collection所继承。它只有一个方法：<code>Iterator&lt;T&gt; iterator()</code>，返回一个迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; l = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    l.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    l.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">    Iterator iter = l.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">        System.out.println((String)iter.next());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//for循环的版本</span></span><br><span class="line"><span class="comment">//for(Iterator&lt;String&gt; iter=l.iterator();iter.hasNext();)&#123;</span></span><br><span class="line"><span class="comment">//String str = (String)iter.next();</span></span><br><span class="line"><span class="comment">//System.out.println(str);</span></span><br><span class="line"><span class="comment">//&#125;  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h1><p>JDK 不提供此接口的任何直接实现：它提供更具体的子接口（如 Set 和 List）实现。不同的Collection子类对于有序性、重复性、null、线程同步都有不同的策略。</p><h2 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h2><p>List是有序的 collection（也称为序列）。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。与Set不同，List允许插入重复的值。</p><p>List 接口提供了特殊的迭代器，称为 <code>ListIterator</code>，该迭代器还允许元素插入和替换以及双向访问。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>List接口的排序可以通过<code>Collections.sort()</code>来进行<strong>定制排序</strong>。只需要<strong>继承Comparable接口</strong>后，重写<code>compareTo()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;   </span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">        list.add(stu3);</span><br><span class="line">            ...</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">&#125;        </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用当前对象的年龄和其他对象的年龄比较，如果&lt;0返回负数，&gt;0返回正数，=0返回0</span></span><br><span class="line">        <span class="keyword">int</span> z = <span class="keyword">this</span>.age - ((Student)o).getAge();</span><br><span class="line">        <span class="keyword">if</span>(z&lt;<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="List的子类"><a href="#List的子类" class="headerlink" title="List的子类"></a>List的子类</h3><h4 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1. ArrayList"></a>1. ArrayList</h4><ul><li>基于数组实现的List类，它封装了一个<strong>动态的、增长的、允许再分配的</strong><code>Object[ ]</code>数组，允许对元素进行快速随机访问</li><li>当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此它<strong>适合随机查找和遍历</strong>，不适合插入和删除。</li></ul><h4 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2. LinkedList"></a>2. LinkedList</h4><ul><li>LinkedList是用<strong>链表结构</strong>存储数据的，很适合数据的<strong>动态插入和删除</strong>，随机访问和遍历速度比较慢。</li><li>实现了Deque接口，专门用于操作表头和表尾元素，可以当作堆栈、队列和<strong>双向队列</strong>使用。</li></ul><h4 id="3-Vector"><a href="#3-Vector" class="headerlink" title="3. Vector"></a>3. Vector</h4><ul><li>与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，避免多线程同时写而引起的不一致性，但要慢很多，现在块被淘汰了。</li></ul><h2 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h2><p>集合，是无序、不可重复的。</p><p>Set判断两个对象相同不用<code>&quot;==&quot;</code>而是根据<code>equals</code>方法。在使用Set集合的时候，应该注意：</p><ul><li>为Set集合里的元素的实现类实现一个有效的<code>equals(Object)</code>方法；</li><li>对Set的构造函数，传入的Collection参数不能包含重复的元素。</li></ul><h3 id="Set-的子类"><a href="#Set-的子类" class="headerlink" title="Set 的子类"></a>Set 的子类</h3><h4 id="1-HashSet"><a href="#1-HashSet" class="headerlink" title="1. HashSet"></a>1. HashSet</h4><ul><li>使用HASH算法来存储集合中的元素，集合判断两个元素相等的标准是两个对象通过<code>equals()</code>方法比较相等，并且两个对象的<code>hashCode()</code>方法的返回值相等</li></ul><h5 id="1-1-LinkedHashSet"><a href="#1-1-LinkedHashSet" class="headerlink" title="1.1 LinkedHashSet"></a>1.1 LinkedHashSet</h5><ul><li>也是根据元素的hashCode值来决定元素的存储位置，但同时使用链表维护元素的次序，当遍历集合里的元素时，LinkedHashSet将会按元素的添加顺序来访问集合里的元素</li></ul><h4 id="2-SortedSet"><a href="#2-SortedSet" class="headerlink" title="2. SortedSet"></a>2. SortedSet</h4><p>此接口主要用于<strong>排序</strong>操作，实现了此接口的子类都属于排序的子类</p><h5 id="2-1TreeSet"><a href="#2-1TreeSet" class="headerlink" title="2.1TreeSet"></a>2.1TreeSet</h5><ul><li>TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态</li></ul><h4 id="3-EnumSet"><a href="#3-EnumSet" class="headerlink" title="3. EnumSet"></a>3. EnumSet</h4><ul><li>EnumSet是一个专门为<strong>枚举类</strong>设计的集合类，EnumSet中所有元素都必须是<strong>指定枚举类型</strong>的枚举值，该枚举类型在创建EnumSet时显式、或隐式地指定。EnumSet的集合元素也是有序的，</li></ul><h2 id="Queue-接口"><a href="#Queue-接口" class="headerlink" title="Queue 接口"></a>Queue 接口</h2><p>用于模拟队列</p><h4 id="1-PriorityQueue"><a href="#1-PriorityQueue" class="headerlink" title="1. PriorityQueue"></a>1. PriorityQueue</h4><ul><li>按照队列中某个属性的大小来排列的，因此称作优先队列。</li></ul><h4 id="2-Deque"><a href="#2-Deque" class="headerlink" title="2. Deque"></a>2. Deque</h4><ul><li>双端队列</li></ul><h5 id="2-1-ArrayDeque"><a href="#2-1-ArrayDeque" class="headerlink" title="2.1  ArrayDeque"></a>2.1  ArrayDeque</h5><ul><li>基于数组的双端队列。</li></ul><h5 id="2-2-LinkedList"><a href="#2-2-LinkedList" class="headerlink" title="2.2 LinkedList"></a>2.2 LinkedList</h5><ul><li>如上</li></ul><h1 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h1><p>Map用于保存具有“映射关系”的数据。每个Entry都持有<code>键-值</code>两个对象。其中，Value可能重复，但Key不可重复</p><p>操作：</p><ul><li><code>merge</code>：将新的值赋值到 <code>key</code> （如果不存在）或更新给定的 <code>key</code> 值对应的 <code>value</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">idCount.merge(id, <span class="number">1</span>, Integer::sum);</span><br><span class="line"><span class="comment">// &lt;--- 等价于 ---&gt;</span></span><br><span class="line">Integer prev = idCount.get(id);</span><br><span class="line"><span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">    idCount.put(id, <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    idCount.put(id, prev + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1. HashMap"></a>1. HashMap</h2><p>HashMap也不能保证<code>key-value</code>对的顺序。类似于HashSet判断两个key是否相等的标准: 两个key通过<code>equals()</code>方法比较返回true、 同时两个key的<code>hashCode</code>值也必须相等</p><h3 id="1-1-LinkedHashMap"><a href="#1-1-LinkedHashMap" class="headerlink" title="1.1 LinkedHashMap"></a>1.1 LinkedHashMap</h3><ul><li>LinkedHashMap也使用<strong>双向链表</strong>来维护key-value对的次序，该链表负责维护Map的迭代顺序，与key-value对的插入顺序一致（注意和TreeMap对所有的key-value进行排序区分）</li></ul><h2 id="2-HashTable"><a href="#2-HashTable" class="headerlink" title="2. HashTable"></a>2. HashTable</h2><p>一个古老的Map实现类。</p><h3 id="2-1-Properties"><a href="#2-1-Properties" class="headerlink" title="2.1 Properties"></a>2.1 Properties</h3><ul><li>Properties对象在处理属性文件时特别方便（windows平台的.ini文件）。Properties类可以把Map对象和属性文件关联，从而把Map对象的<code>key - value</code>对写入到属性文件中，也可把属性文件中的“属性名-属性值”加载进Map对象中。</li></ul><h2 id="3-SortedMap"><a href="#3-SortedMap" class="headerlink" title="3. SortedMap"></a>3. SortedMap</h2><p>如同<code>Set-&gt;SortedSet-&gt;TreeSet</code>一样，Map也有<code>Map-&gt;SortedMap-&gt;TreeMap</code>的继承关系。</p><h3 id="3-1-TreeMap"><a href="#3-1-TreeMap" class="headerlink" title="3.1 TreeMap"></a>3.1 TreeMap</h3><ul><li>是一个红黑树结构，每个键值对都作为红黑树的一个节点。TreeMap存储键值对时，需要根据key对节点进行排序，TreeMap可以保证所有的<code>key-value</code>对处于有序状态。 </li><li>TreeMap也有两种排序方式：自然排序、定制排序（类似于上面List的重写<code>CompareTo()</code>方法）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;常见的各个容器的继承关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/01/rl4tPN1WsqybxdK.jpg&quot; alt=&quot;屏幕截图 2021-03-01 103049.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Iterable-</summary>
      
    
    
    
    <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
</feed>
