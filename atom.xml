<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>烟湮燕眼&#39;s Notes</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-03T08:30:04.891Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>烟湮燕眼</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2021/06/03/DeepLearning/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-pre/"/>
    <id>http://yoursite.com/2021/06/03/DeepLearning/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-pre/</id>
    <published>2021-06-03T08:26:49.789Z</published>
    <updated>2021-06-03T08:30:04.891Z</updated>
    
    <content type="html"><![CDATA[<p>目前基于《<code>Deep Learning with Python</code>》学习</p><p>机器学习的技术定义：在预先定义好的可能性空间中，利用反馈信号的指引来寻找</p><p>输入数据的有用表示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目前基于《&lt;code&gt;Deep Learning with Python&lt;/code&gt;》学习&lt;/p&gt;
&lt;p&gt;机器学习的技术定义：在预先定义好的可能性空间中，利用反馈信号的指引来寻找&lt;/p&gt;
&lt;p&gt;输入数据的有用表示。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>「selenium」基础</title>
    <link href="http://yoursite.com/2021/06/02/Selenium/Selenium-0/"/>
    <id>http://yoursite.com/2021/06/02/Selenium/Selenium-0/</id>
    <published>2021-06-01T16:21:22.000Z</published>
    <updated>2021-06-02T15:07:26.553Z</updated>
    
    <content type="html"><![CDATA[<p>Selenium是一个用于Web应用程序测试的工具。</p><p>Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE（7, 8, 9, 10, 11），Firefox，Safari，Chrome，Opera等。</p><p>这个工具的主要功能包括：测试与浏览器的兼容性——测试你的应用程序看是否能够很好得工作在不同浏览器和操作系统之上。测试系统功能——创建回归测试检验软件功能和用户需求。</p><p>而用在爬虫上则是模拟正常用户访问网页并获取数据。</p><p>这里记录<code>Selenium2</code>的基础知识。</p><h1 id="Pre"><a href="#Pre" class="headerlink" title="Pre"></a>Pre</h1><p>安装chromedriver &amp;&amp; selenium 库</p><p>一个简单的实例：</p><p>打开百度首页，在输入框中输入python，点击搜索</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开一个Chrome浏览器</span></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 请求百度首页</span></span><br><span class="line">browser.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="comment"># 找到输入框位置</span></span><br><span class="line"><span class="built_in">input</span> = WebDriverWait(browser, <span class="number">10</span>).until(</span><br><span class="line">                EC.presence_of_element_located((By.XPATH, <span class="string">&#x27;//*[@id=&quot;kw&quot;]&#x27;</span>))</span><br><span class="line">            )</span><br><span class="line"><span class="comment"># 在输入框中输入Python</span></span><br><span class="line"><span class="built_in">input</span>.send_keys(<span class="string">&#x27;Python&#x27;</span>)</span><br><span class="line"><span class="comment"># 找到输入按钮</span></span><br><span class="line">button = WebDriverWait(browser, <span class="number">10</span>).until(</span><br><span class="line">                EC.element_to_be_clickable(</span><br><span class="line">                    (By.XPATH, <span class="string">&#x27;//*[@id=&quot;su&quot;]&#x27;</span>))</span><br><span class="line">            )</span><br><span class="line"><span class="comment"># 点击一次输入按钮</span></span><br><span class="line">button.click()</span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure><h1 id="Chrome启动选项"><a href="#Chrome启动选项" class="headerlink" title="Chrome启动选项"></a>Chrome启动选项</h1><p>在<code>Selenium</code>中使用不同的<code>Webdriver</code>可能会有不一样的方法，有些相同的操作会得到不一样的结果，这里记录的是<code>Chrome()</code>的使用方法。</p><h2 id="Chrome-Options"><a href="#Chrome-Options" class="headerlink" title="Chrome Options"></a>Chrome Options</h2><p>一个Chrome的参数对象，在此对象中使用<code>add_argument()</code>方法可以添加启动参数，添加完毕后可以在初始化Webdriver对象时将此Options对象传入，则可以实现以特定参数启动Chrome。</p><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个启动参数对象</span></span><br><span class="line">chrome_options = Options()</span><br><span class="line"><span class="comment"># 添加启动参数</span></span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--window-size=1366,768&#x27;</span>)</span><br><span class="line"><span class="comment"># 将参数对象传入Chrome，则启动了一个设置了窗口大小的Chrome</span></span><br><span class="line">browser = webdriver.Chrome(chrome_options=chrome_options)</span><br></pre></td></tr></table></figure><p><strong>常用启动参数：</strong></p><table><thead><tr><th align="center">启动参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">–user-agent=””</td><td align="center">设置请求头的User-Agent</td></tr><tr><td align="center">–window-size=1366,768</td><td align="center">设置浏览器分辨率</td></tr><tr><td align="center">–headless</td><td align="center">无界面运行</td></tr><tr><td align="center">–start-maximized</td><td align="center">最大化运行</td></tr><tr><td align="center">–incognito</td><td align="center">隐身模式</td></tr><tr><td align="center">–disable-javascript</td><td align="center">禁用javascript</td></tr><tr><td align="center">–disable-infobars</td><td align="center">禁用浏览器正在被自动化程序控制的提示</td></tr></tbody></table><p><a href="https://peter.sh/experiments/chromium-command-line-switches/">https://peter.sh/experiments/chromium-command-line-switches/</a></p><p><strong>禁用图片加载</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prefs = &#123;</span><br><span class="line">    <span class="string">&#x27;profile.default_content_setting_values&#x27;</span> : &#123;</span><br><span class="line">        <span class="string">&#x27;images&#x27;</span> : <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;prefs&#x27;</span>,prefs)</span><br></pre></td></tr></table></figure><p><strong>禁用浏览器弹窗</strong></p><p>使用浏览器时常常会有弹窗弹出，以下选项可以禁止弹窗：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prefs = &#123;  </span><br><span class="line">    <span class="string">&#x27;profile.default_content_setting_values&#x27;</span> :  &#123;  </span><br><span class="line">        <span class="string">&#x27;notifications&#x27;</span> : <span class="number">2</span>  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;prefs&#x27;</span>,prefs)</span><br></pre></td></tr></table></figure><h2 id="Chrome-WebDriver"><a href="#Chrome-WebDriver" class="headerlink" title="Chrome WebDriver"></a>Chrome WebDriver</h2><h3 id="指定chromedriver-exe的位置"><a href="#指定chromedriver-exe的位置" class="headerlink" title="指定chromedriver.exe的位置"></a>指定chromedriver.exe的位置</h3><p>chromedriver.exe一般可以放在环境文件中，但是有时候为了方便部署项目，或者为了容易打包，我们可以将chromedriver.exe放到我们的项目目录中，然后在初始化Chrome Webdriver对象时，传入chromedriver.exe的路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome(executable_path=<span class="string">&#x27;chromedriver.exe&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="Remote-Webdriver"><a href="#Remote-Webdriver" class="headerlink" title="Remote Webdriver"></a>Remote Webdriver</h1><p><code>selenium.webdriver.remote.webdriver.WebDriver</code> 这个类其实是所有其他Webdriver的父类，例如<code>Chrome Webdriver</code>，<code>Firefox Webdriver</code>都是继承自这个类。这个类中实现了每个Webdriver间相通的方法。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Selenium是一个用于Web应用程序测试的工具。&lt;/p&gt;
&lt;p&gt;Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE（7, 8, 9, 10, 11），Firefox，Safari，Chrome，Opera等。&lt;/p&gt;
&lt;p&gt;这个工具的</summary>
      
    
    
    
    <category term="selenium" scheme="http://yoursite.com/categories/selenium/"/>
    
    
    <category term="selenium" scheme="http://yoursite.com/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>「OS」文件管理（磁盘组织与管理）</title>
    <link href="http://yoursite.com/2021/06/01/OperatingSystem/OS-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86-%E7%A3%81%E7%9B%98/"/>
    <id>http://yoursite.com/2021/06/01/OperatingSystem/OS-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86-%E7%A3%81%E7%9B%98/</id>
    <published>2021-06-01T07:07:00.000Z</published>
    <updated>2021-06-03T15:55:44.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h1><h2 id="磁盘-磁道-扇区"><a href="#磁盘-磁道-扇区" class="headerlink" title="磁盘/磁道/扇区"></a>磁盘/磁道/扇区</h2><p><img src="https://pic.imgdb.cn/item/60b7aaea39f6859bc2a5e0d7.png"></p><h2 id="盘面-柱面-物理地址"><a href="#盘面-柱面-物理地址" class="headerlink" title="盘面/柱面/物理地址"></a>盘面/柱面/物理地址</h2><p><img src="https://pic.imgdb.cn/item/60b7ab3039f6859bc2a99ef1.png"></p><h2 id="磁盘分类"><a href="#磁盘分类" class="headerlink" title="磁盘分类"></a>磁盘分类</h2><p><img src="https://pic.imgdb.cn/item/60b7ab4039f6859bc2aa5a6d.png"></p><p><img src="https://pic.imgdb.cn/item/60b7ab4d39f6859bc2aae476.png"></p><h1 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h1><h2 id="读写时间"><a href="#读写时间" class="headerlink" title="读写时间"></a>读写时间</h2><p><img src="https://pic.imgdb.cn/item/60b8eed78355f7f718dbe59e.png"></p><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p><strong>先来先服务(FCFS)</strong></p><p>根据进程请求访问磁盘的先后顺序调度 </p><p>公平；如果大量进程访问的磁道很分散，效率会很差</p><p><strong>最短寻道时间优先(SSTF)</strong></p><p>优先处理当前磁头最近的磁道，保证寻道时间最短（眼前最优，未必整体最优） </p><p>性能较好，但是可能产生饥饿现象（离磁头远的请求长时间得不到满足）</p><p><strong>扫描算法(SCAN)</strong></p><p>又叫电梯算法，在SSTF算法的基础上，规定磁头只有移动到磁道尽头（最外侧或者最内侧）才能往回移动 </p><p>性能较好，不会饥饿；但是只能扫描到最边上的磁道才能改变磁头方向，越外侧的的磁道，响应频率越高</p><p><strong>LOOK调度算法</strong></p><p>改进SCAN算法，磁头边移动边观察(LOOK)，如果移动方向没有请求了，就不必继续扫描，直接调头</p><p><strong>循环扫描算法(C-SCAN)</strong></p><p>只有磁头朝着某个方向移动（比如磁道号增大方向）时才处理访问请求，移动到最边上后直接返回到另一边（0号磁道），返回途中不处理请求 </p><p>相比SACN算法，各个位置的磁道响应频率很平均</p><p><strong>C-LOOK算法</strong></p><p>改进C-SCAN算法，磁头移动方向上如果没有请求了，就直接返回到最靠近另一侧边缘的请求磁道即可</p><h1 id="减少磁盘延时"><a href="#减少磁盘延时" class="headerlink" title="减少磁盘延时"></a>减少磁盘延时</h1><p><strong>交替编号</strong></p><p>一个盘面上，让逻辑相邻的扇区在物理上有一定间隔，使读取连续逻辑扇区所需的延迟时间更小 </p><p>（如果没有间隔，读入N号扇区时数据时需要一些时间处理，导致错过N+1号扇区，磁盘需要再转一圈才能读到N+1）</p><p><strong>磁盘物理地址设计</strong></p><p><img src="https://pic.imgdb.cn/item/60b8f0788355f7f7180705b4.png"></p><p><img src="https://pic.imgdb.cn/item/60b8f0848355f7f71808065e.png"></p><p><strong>错位命名</strong></p><p><img src="https://pic.imgdb.cn/item/60b8f0b88355f7f7180d23b2.png"></p><p><img src="https://pic.imgdb.cn/item/60b8f0c18355f7f7180e1551.png"></p><h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><h2 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h2><p><img src="https://pic.imgdb.cn/item/60b8fb268355f7f718eac3dc.png"></p><h2 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h2><p><img src="https://pic.imgdb.cn/item/60b8fb578355f7f718edea89.png"></p><h2 id="坏块管理"><a href="#坏块管理" class="headerlink" title="坏块管理"></a>坏块管理</h2><p><img src="https://pic.imgdb.cn/item/60b8fb7c8355f7f718f0325a.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;磁盘结构&quot;&gt;&lt;a href=&quot;#磁盘结构&quot; class=&quot;headerlink&quot; title=&quot;磁盘结构&quot;&gt;&lt;/a&gt;磁盘结构&lt;/h1&gt;&lt;h2 id=&quot;磁盘-磁道-扇区&quot;&gt;&lt;a href=&quot;#磁盘-磁道-扇区&quot; class=&quot;headerlink&quot; title=&quot;磁</summary>
      
    
    
    
    <category term="OperatingSystem" scheme="http://yoursite.com/categories/OperatingSystem/"/>
    
    
    <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>「OS」文件管理（文件系统）</title>
    <link href="http://yoursite.com/2021/05/26/OperatingSystem/OS_%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2021/05/26/OperatingSystem/OS_%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</id>
    <published>2021-05-26T07:07:00.000Z</published>
    <updated>2021-06-02T05:53:57.569Z</updated>
    
    <content type="html"><![CDATA[<p>文件就是一组有意义的信息/数据的集合</p><h1 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h1><ul><li>文件名<br>  主要是给用户看，同一个目录下不允许重名文件</li><li>标识符<br>  一个系统内各文件标识符唯一，对用户毫无可读性，给操作系统看的</li><li>类型<br>  文件扩展名</li><li>位置<br>  文件存放路径，给用户看的；外存中的存放地址，操作系统可见</li><li>大小</li><li>创建时间</li><li>上次修改/访问时间</li><li>所有者信息</li><li>保护信息</li></ul><h1 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h1><h2 id="什么是逻辑结构"><a href="#什么是逻辑结构" class="headerlink" title="什么是逻辑结构"></a>什么是逻辑结构</h2><p>逻辑结构：在用户看来，文件内部的数据是如何组织起来</p><p>物理结构：操作系统看来，文件的数据如何存放在外存中</p><h2 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h2><p>又叫流式文件，比如<code>.txt</code>，文件内部的数据由一些二进制或者字符流组成</p><h2 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h2><p>又叫记录式文件，比如数据库表，由一组相似的记录组成<br>​记录是一组相关数据项的集合，每条记录有一个数据项可作为关键字<br>根据各条记录的长度是否相等，分为：定长记录，可变长记录</p><h3 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h3><p>文件中的记录顺序排列（逻辑上），记录可以定长或可变长。各记录在物理上可以顺序存储或链式存储</p><p><strong>链式存储</strong>：</p><p>逻辑上相邻的记录，在物理上离散存储。<br>​无论是定长/可变长记录，都无法实现随机存取，只能从链头开始遍历</p><p><strong>顺序存储</strong>：</p><p>逻辑上相邻的记录，在物理上也相邻。<br>没有说明的情况下，顺序文件指采用顺序存储的顺序文件</p><ul><li><p>可变长记录</p><p>  无法实现随机存取</p></li><li><p>定长记录</p><p>  可以实现随机存储。</p><p>  如果采用串结构(记录顺序与关键字无关)，无法快速找到某个关键字对应的记录，如果采用顺序结构(记录按关键字排序的)，可以使用折半查找等方法快速找到记录</p></li></ul><h3 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h3><p>索引表本身是定长记录的顺序文件，索引表项包含索引号，长度，指针，真正的记录可以在物理上离散存储。<br>可以用不同的数据项建立多个索引表</p><h3 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h3><p>将记录分组，每一个组对应一个索引表项<br>检索记录时先顺序检索索引表，找到分组，再顺序查找分组查找记录<br>记录过多时，可以建立多级索引表。<small>例如，对于一个含$10^6$个记录的文件，可先为该文件建立一张低级索引表，每100个记录为一组，故低级索引表中共有10000个表项（即10000个定长记录），再把这10000个定长记录分组，每组100个，为其建立顶级索引表，故顶级索引表中共有100个表项。平均查找 150 次</small></p><h1 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h1><p><img src="https://pic.imgdb.cn/item/60af0ae608f74bc1590e63c3.jpg"><br>目录文件中的一条记录就是一个文件控制块（FCB），一个文件对应一个 FCB，一个FCB就是一个目录项，FCB的有序集合叫“文件目录”<br>FCB包含了文件的基本信息，存取控制信息，使用信息等等。<br> FCB 实现了文件名和文件之间的映射。<br>对目录的操作:搜索、创建文件、删除文件、显示文件、修改文件</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><strong>单级目录结构</strong>：<br><img src="https://pic.imgdb.cn/item/60af0ccd08f74bc15920f962.png"><br><strong>二级目录结构</strong>：<br><img src="https://pic.imgdb.cn/item/60af13ba08f74bc159620f16.png"><br><strong>多级（树形）目录结构</strong>：<br><img src="https://pic.imgdb.cn/item/60af14d408f74bc1596be485.png"><br>通过引入”当前目录”和”相对路径”，可以减少磁盘的 I/O 次数，提升访问文件的效率。<br><strong>无环图目录结构</strong>：<br><img src="https://pic.imgdb.cn/item/60af167708f74bc1597aaf92.png"></p><h2 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h2><p>索引节点是对 FCB 的改进，使每个目录项长度减小，从而每个磁盘块可以存放更多目录项，减少检索文件时的磁盘 I/O 次数。<br><img src="https://pic.imgdb.cn/item/60af17cf08f74bc159863f5f.png"></p><h1 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h1><h2 id="文件块-物理块"><a href="#文件块-物理块" class="headerlink" title="文件块/物理块"></a>文件块/物理块</h2><p><img src="https://pic.imgdb.cn/item/60b22fa808f74bc159d56027.png"></p><h2 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h2><p>优点：支持随机访问；顺序访问时速度最快（移动磁头所需的时间短）<br>缺点：不方便文件扩展，每次扩展都得迁移到一段连续的空间，代价大；存储空间利用率低，产生磁盘碎片</p><h2 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h2><p>链接分配采取离散分配方式，可以为文件分配离散的磁盘块。</p><h3 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h3><p>除文件最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块指针和最后一块指针。</p><p>方便拓展，磁盘利用率高</p><p>不支持随机访问，查找效率低</p><h3 id="显式链接"><a href="#显式链接" class="headerlink" title="显式链接"></a>显式链接</h3><p>把用于链接文件各物理块的指针显式存在一张表中，即文件分配表（FAT）。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。</p><p><img src="https://pic.imgdb.cn/item/60b24c6708f74bc15945d68e.png"></p><p>方便拓展，磁盘利用率高。支持随机访问，相比隐式链接，地址转换无需访问磁盘，文件访问效率更高。</p><p>文件分配表需要占用存储空间。</p><h2 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h2><p>每一个文件建立一张索引表，其中记录文件的逻辑块对应的物理块。存放索引表的磁盘块叫索引块，存放文件数据的磁盘块叫数据块。</p><p>注：文件分配表是一个磁盘对应一张，而索引表是一个文件对应一张。</p><p><img src="https://pic.imgdb.cn/item/60b25cbe08f74bc15966ca02.jpg"></p><p>如果索引表太大，一个索引块装不下，我们可以：</p><ol><li>链接方案：在前一个块中存指向下一个块的指针。</li><li>多层索引：类似多级页表</li></ol><p><img src="https://pic.imgdb.cn/item/60b261d708f74bc159b92997.jpg"></p><ol start="3"><li>混合索引：多种索引分配方式的结合</li></ol><p><img src="https://pic.imgdb.cn/item/60b262b708f74bc159c74767.jpg"></p><h1 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h1><h2 id="存储空间划分与初始化"><a href="#存储空间划分与初始化" class="headerlink" title="存储空间划分与初始化"></a>存储空间划分与初始化</h2><p><img src="https://pic.imgdb.cn/item/60b317d408f74bc159d1d76b.jpg"></p><h2 id="存储空间管理"><a href="#存储空间管理" class="headerlink" title="存储空间管理"></a>存储空间管理</h2><h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><p><img src="https://pic.imgdb.cn/item/60b319f408f74bc159f0a1e6.jpg"></p><h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><p><strong>空闲盘块链</strong></p><p><img src="https://pic.imgdb.cn/item/60b32bac39f6859bc21086a6.png"></p><p><strong>空闲盘区链</strong></p><p><img src="https://pic.imgdb.cn/item/60b32bef39f6859bc213b23b.png"></p><h3 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h3><p>(字号, 位号) = (行号, 列号) -&gt; 盘块号 </p><p>字长16 = 一行有 16 个磁盘块，注意 0 开始 还是 1 开始 </p><p>盘块号 = 字长*字号 + 位号</p><p><img src="https://pic.imgdb.cn/item/60b369f739f6859bc21b2e48.png"></p><h3 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h3><p>UNIX系统采用。适用于大型文件系统。</p><p>文件卷的目录区中，专门用一个磁盘块作为超级块，系统启动时读入内存，并且保持内外存超级块数据同步</p><p><strong>超级块的作用</strong></p><p><img src="https://pic.imgdb.cn/item/60b36a9439f6859bc2215964.png"></p><p><strong>分配</strong></p><ol><li>若需要 1 个空闲磁盘块</li></ol><p><img src="https://pic.imgdb.cn/item/60b36b8339f6859bc22a3ad0.png"></p><ol start="2"><li>若需要 100 个空闲磁盘块</li></ol><p><img src="https://pic.imgdb.cn/item/60b36c0439f6859bc22f0aa7.png"></p><p><strong>回收</strong></p><p>第一个分组没有达到上限，加到其末尾即可</p><p>达到上限：</p><p><img src="https://pic.imgdb.cn/item/60b36c6b39f6859bc232813b.png"></p><p><img src="https://pic.imgdb.cn/item/60b36c7e39f6859bc2331f43.png"></p><h1 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h1><p><strong>创建文件</strong></p><ol><li><p>在外存中找到文件所需的空间 </p></li><li><p>根据文件路径找到对应目录文件，在目录中创建文件对应的目录项</p></li></ol><p><strong>删除文件</strong></p><ol><li><p>根据路径找到目录文件，找到文件名对应的目录项 </p></li><li><p>回收文件占用的磁盘块 </p></li><li><p>从目录表中删除文件对应的目录项</p></li></ol><p><strong>打开文件</strong></p><ol><li><p>根据路径找到目录文件，找到文件名对应的目录项，检测用户权限 </p></li><li><p>将目录项复制到该进程在内存中的打开文件表中，返回表目编号(索引号/文件描述符)。之后用户使用打开文件表的编号来指明要操作的文件。</p></li></ol><p>打开文件表有：进程的打开文件表，系统的打开文件表</p><p><img src="https://pic.imgdb.cn/item/60b37a8e39f6859bc2b85ed1.png"></p><p><strong>关闭文件</strong></p><ol><li>删除进程的打开文件表中对应项 </li><li>回收分配给该文件的内存空间等资源 </li><li>系统打开文件表的打开计数器count-=1(归零时删除该项)</li></ol><p><strong>读文件</strong></p><p>进程使用read系统调用完成读操作。需要指明是哪个文件(在支持“打开文件”操作的系统中,只需要提供文件在打开文件表中的索引号即可)，还需要指明要读入多少数据、指明读入的数据要放在内存中的什么位置。</p><p>操作系统在处理read系统调用时,会从读指针指向的外存中,将用户指定大小的数据读入用户指定的内存区域中</p><p><strong>写文件</strong></p><p>需要提供打开文件表中的索引号，写出的数据量，写回外存的数据位置(写指针指向)</p><h1 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h1><h2 id="基于索引结点的共享-硬链接"><a href="#基于索引结点的共享-硬链接" class="headerlink" title="基于索引结点的共享(硬链接)"></a>基于索引结点的共享(硬链接)</h2><p><img src="https://pic.imgdb.cn/item/60b65a5639f6859bc2529632.png"></p><h2 id="基于符号链的共享-软链接"><a href="#基于符号链的共享-软链接" class="headerlink" title="基于符号链的共享(软链接)"></a>基于符号链的共享(软链接)</h2><p><img src="https://pic.imgdb.cn/item/60b65a7539f6859bc2545a0c.png"></p><h1 id="文件共享-1"><a href="#文件共享-1" class="headerlink" title="文件共享"></a>文件共享</h1><h2 id="口令保护"><a href="#口令保护" class="headerlink" title="口令保护"></a>口令保护</h2><p>FCB中保存口令，访问时与用户提供的口令对比</p><p>开销小，但是不够安全</p><h2 id="加密保护"><a href="#加密保护" class="headerlink" title="加密保护"></a>加密保护</h2><p>用密码对文件数据流加密，访问时用密码解密，比如异或加密 </p><p>保密性强，不需要存储密码，但是加密/解密要花费一定的时间</p><p><img src="https://pic.imgdb.cn/item/60b716d939f6859bc2517587.jpg"></p><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>每一个文件的FCB（或索引结点）中增加一个访问控制表(ACL)，控制各用户的访问权限 </p><p>精简的访问列表：以组为单位，标记其访问权限。</p><p><img src="https://pic.imgdb.cn/item/60b717b939f6859bc262b2ff.jpg"></p><h1 id="文件系统层次结构"><a href="#文件系统层次结构" class="headerlink" title="文件系统层次结构"></a>文件系统层次结构</h1><p><img src="https://pic.imgdb.cn/item/60b71c0e39f6859bc2a45772.png"></p><p>eg：</p><p><img src="https://pic.imgdb.cn/item/60b71c6539f6859bc2a90a70.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文件就是一组有意义的信息/数据的集合&lt;/p&gt;
&lt;h1 id=&quot;文件的属性&quot;&gt;&lt;a href=&quot;#文件的属性&quot; class=&quot;headerlink&quot; title=&quot;文件的属性&quot;&gt;&lt;/a&gt;文件的属性&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;文件名&lt;br&gt;  主要是给用户看，同一个目录下不允许</summary>
      
    
    
    
    <category term="OperatingSystem" scheme="http://yoursite.com/categories/OperatingSystem/"/>
    
    
    <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>「OOP」JML</title>
    <link href="http://yoursite.com/2021/05/25/ObjectOriented/%E3%80%8COO%E3%80%8D-JML/"/>
    <id>http://yoursite.com/2021/05/25/ObjectOriented/%E3%80%8COO%E3%80%8D-JML/</id>
    <published>2021-05-25T11:18:06.000Z</published>
    <updated>2021-05-30T11:59:36.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="规格"><a href="#规格" class="headerlink" title="规格"></a>规格</h1><h2 id="什么是规格"><a href="#什么是规格" class="headerlink" title="什么是规格"></a>什么是规格</h2><p>对一个方法/类/程序的外部<strong>可感知</strong>行为的抽象表示 </p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><ul><li>规格把设计与实现有效分离</li><li>准确理解一个方法的行为，是多人协同开发时的交互基础</li><li>可以以逻辑方式来验证代码实现的正确性</li><li>作为开展测试设计的依据。我们不能只在黑盒层次开展测试，也需要对类、方法和接口进行测试</li></ul><h2 id="如何表示规格"><a href="#如何表示规格" class="headerlink" title="如何表示规格"></a>如何表示规格</h2><p>由许多研究，比如形式化语言。<br>要表示规格，需要实现：</p><ul><li>方法规格抽象<ul><li>执行前对输入的要求—-前置条件(precondition)</li><li>执行过程中对于环境(参数、所在this)的改变描述—-副作用(Side-Effects)</li><li>执行后返回结果应该满足的约束—-后置条件(postcondition)</li></ul></li><li>数据规格抽象(类型抽象)<ul><li>数据状态应该满足的要求—-不变式(invariant)</li><li>数据状态变化应该满足的要求—-约束(constraint)</li></ul></li></ul><h2 id="类型层次下的规格关系"><a href="#类型层次下的规格关系" class="headerlink" title="类型层次下的规格关系"></a>类型层次下的规格关系</h2><p>子类重写方法可以减弱父类方法规定的Requires,或者加强父类方法规定的Ensures</p><p>子类可以对父类进行扩充，但需要保持父类的规格仍然成立</p><p>LSP替换原则：在任何父类型对象出现的地方使用子类对象都不会破坏user程序的行为</p><h1 id="JML"><a href="#JML" class="headerlink" title="JML"></a>JML</h1><p>JML (Java Modeling Language) 是一种行为接口规格语言（Behavior Interface Specification Language，BISL），基于 Larch 方法构建。通过 JML 及其支持工具，不仅可以基于规格自动构造测试用例，并整合了 SMT Solver 等工具以静态方式来检查代码实现对规格的满足情况。</p><p>一般而言，JML 有两种主要的用法：</p><p>（1）开展规格化设计。这样交给代码实现人员的将不是可能带有内在模糊性的自然语言描述，而是逻辑严格的规格。</p><p>（2）针对已有的代码实现，书写其对应的规格，从而提高代码的可维护性。这在遗留代码的维护方面具有特别重要的意义。</p><p>JML 的设计考虑到了未来扩展需要，把语言分成了几个层次。其中 level 0 是最核心的语言特征，要求所有的 JML 工具都要支持。这里记录 level 0 中最核心和最常用的一些要素。</p><h2 id="1-注释结构"><a href="#1-注释结构" class="headerlink" title="1. 注释结构"></a>1. 注释结构</h2><p>JML 以 javadoc 注释的方式来表示规格，每行都以 @ 起头。有两种注释方式，行注释和块注释。其中行注释的表示方式为 <code>//@annotation</code>，块注释的方式为 <code>/* @ annotation @*/</code>。按照 Javadoc 习惯， JML 注释一般放在被注释成分的紧邻上部，如下面的例子所示。其中有效的 Java 代码为 line1，line 3，line 15，line18 和 line19。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jmlspecs.samples.jmlrefman;               <span class="comment">// line 1</span></span><br><span class="line">                                                      <span class="comment">// line 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntHeap</span> </span>&#123;                       <span class="comment">// line 3</span></span><br><span class="line">                                                      <span class="comment">// line 4</span></span><br><span class="line">    <span class="comment">//@ public model non_null int [] elements;        // line 5</span></span><br><span class="line">                                                      <span class="comment">// line 6</span></span><br><span class="line">    <span class="comment">/*@ public normal_behavior                        // line 7</span></span><br><span class="line"><span class="comment">      @   requires elements.length &gt;= 1;              // line 8</span></span><br><span class="line"><span class="comment">      @   assignable \nothing;                        // line 9</span></span><br><span class="line"><span class="comment">      @   ensures \result                             // line 10</span></span><br><span class="line"><span class="comment">      @        == (\max int j;                        // line 11</span></span><br><span class="line"><span class="comment">      @               0 &lt;= j &amp;&amp; j &lt; elements.length;  // line 12</span></span><br><span class="line"><span class="comment">      @               elements[j]);                   // line 13</span></span><br><span class="line"><span class="comment">      @*/</span>                                             <span class="comment">// line 14</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="comment">/*@ pure @*/</span> <span class="function"><span class="keyword">int</span> <span class="title">largest</span><span class="params">()</span></span>;       <span class="comment">// line 15</span></span><br><span class="line">                                                      <span class="comment">// line 16</span></span><br><span class="line">    <span class="comment">//@ ensures \result == elements.length;           // line 17</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="comment">/*@ pure @*/</span> <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;          <span class="comment">// line 18</span></span><br><span class="line">&#125;;                                                    <span class="comment">// line 19 </span></span><br></pre></td></tr></table></figure><p>在上面的例子中，定义了一个抽象类 <code>IntHeap</code> 。该类提供了两个抽象方法，<code>largest()</code> 和 <code>size()</code>。第 15 行和第 18 行的 JML 规格表示这两个方法都是纯粹查询方法（<code>/*@ pure @ */</code>），即方法的执行不会有任何副作用。这两个方法的规格必须建立在 <code>IntHeap</code> 所管理的数据规格上，因此为了准确说明这两个方面的规格，首先给出了 <code>IntHeap</code> 所管理的数据规格，如第 5 行所示。其中的 <code>model</code> 表示后面的 <code>int[] elements</code> 仅仅是规格层次的描述，并不是这个类的声明组成部分，此外也不意味该类的实现人员必须提供这样的属性定义，<code>non_null</code> 的意义是 <code>elements</code> 这个数组对象引用不能为 <code>null</code>。有了这个基础， 第 17 行给出了 <code>size</code> 方法的后置条件 (post-condition)，即任何时候该方法的执行都会返回 <code>IntHeap</code> 中存储的元素个数(<code>elements.length</code>)，其中的 <code>\result</code> 是 JML 的关键词，表示方法的执行返回结果。<code>largest</code> 的规格通过从第 7 行到第 14 行的注释块来定义，包括三个部分：</p><p>（1）<code>requires</code> 子句定义该方法的前置条件(pre-condition)，<code>elements.length&gt;=1</code>，即 <code>IntHeap</code> 中管理着至少一个元素；</p><p>（2）副作用范围限定，<code>assignable</code> 列出这个方法能够修改的类成员属性，<code>\nothing</code> 是个关键词，表示这个方法不对任何成员属性进行修改，所以是一个 <code>pure</code> 方法。</p><p>（3）<code>ensures</code> 子句定义了后置条件，即 <code>largest</code> 方法的返回结果等于 <code>elements</code> 中存储的所有整数中的最大的那个(<code>\max</code> 也是一个关键词)。</p><p>需要注意的是，规格中的每个子句都必须以分号结尾，否则会导致 JML 工具无法解析。相比较而言，largest 方法的规格复杂，而<code>size</code>方法的规格则相对简略。在 JML 中对应着两类规格写法，前者适用于前置条件不是恒真的场景，后者则适用于无需描述其前置条件的场景。</p><p>最后还要补充说明一下规格变量的声明。按照 JML 的语法，可以区分两类规格变量，静态或实例。如果是在 Interface 中声明规格变量，则要求明确变量的类别。针对上面的例子，如果是静态规格变量，则声明为 <code>//@public static model non_null int []elements</code>；如果是实例规格变量，则可声明为 <code>//@public instance model non_null int []elements</code>。</p><h2 id="2-JML表达式"><a href="#2-JML表达式" class="headerlink" title="2. JML表达式"></a>2. JML表达式</h2><p>JML 的表达式是对 Java 表达式的扩展，新增了一些操作符和原子表达式。同样 JML 表达式中的操作符也有优先级的概念。请参见 JML 语言手册 12.3 节 (Expression) 获得完整的优先级列表。需要提醒的是，JML 相对于 Java 新增的表达式成分仅用于 JML 中的断言 (assertion) 语句和其他相关的注释体。特别需要提醒，在 JML 断言中，不可以使用带有赋值语义的操作符，如 <code>++，--，+=</code> 等操作符，因为这样的操作符会对被限制的相关变量的状态进行修改，产生副作用。</p><h3 id="2-1-原子表达式"><a href="#2-1-原子表达式" class="headerlink" title="2.1 原子表达式"></a>2.1 原子表达式</h3><p><code>\result</code> 表达式：表示一个非 <code>void</code> 类型的方法执行所获得的结果，即方法执行后的返回值。<code>\result</code> 表达式的类型就是方法声明中定义的返回值类型。如针对方法：<code>public boolean equals (Object o)</code>，<code>\result</code> 的类型是 <code>boolean</code>，任意传递一个 <code>Object</code> 类型的对象来调用该方法，可以使用 <code>\result</code> 来表示 <code>equals</code> 的执行结果（<code>true </code>表示 <code>this</code> 和 <code>o</code> 相等；<code>false </code>表示不相等）。</p><p><code>\old(expr)</code> 表达式：用来表示一个表达式 <code>expr</code> 在相应方法执行前的取值。该表达式涉及到评估 <code>expr</code> 中的对象是否发生变化，遵从 Java 的引用规则，即针对一个对象引用而言，只能判断引用本身是否发生变化，而不能判断引用所指向的对象实体内容是否发生变化。假设一个类有属性 <code>v</code> 为 <code>HashMap</code>，假设在方法执行前 <code>v</code> 的取值为 <code>0x952ab340</code>，即指向了存储在该地址的具体 <code>HashMap</code> 对象，则 <code>\old(v)</code> 的值就是这个引用地址。如果方法执行过程中没有改变 <code>v</code> 指向的对象，则 <code>v</code> 和 <code>\old(v)</code> 有相同的取值，即使方法在执行过程中对 <code>v</code> 指向的 <code>HashMap</code> 执行了插入或删除操作。因此 <code>v.size()</code> 和 <code>\old(v).size()</code> 也有相同的结果。很多情况下，我们希望获得 <code>v</code> 在方法执行前所管理的对象个数，这时应使用 <code>\old(v.size()</code>)。作为一般规则，任何情况下，都应该使用 <code>\old</code> 把关心的表达式取值整体括起来。</p><p><code>\not_assigned(x,y,...)</code> 表达式：用来表示括号中的变量是否在方法执行过程中被赋值。如果没有被赋值，返回为 <code>true</code>，否则返回 <code>false</code>。实际上，该表达式主要用于后置条件的约束表示上，即限制一个方法的实现不能对列表中的变量进行赋值。</p><p><code>\not_modified(x,y,...)</code> 表达式：与上面的 <code>\not_assigned</code> 表达式类似，该表达式限制括号中的变量在方法执行期间的取值未发生变化。</p><p><code>\nonnullelements(container)</code> 表达式：表示 <code>container</code> 对象中存储的对象不会有 <code>null</code>，等价于下面的断言，其中 <code>\forall</code> 是 JML 的关键词，表示针对所有 <code>i</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">container != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">(\forall <span class="keyword">int</span> i; <span class="number">0</span> &lt;= i &amp;&amp; i &lt; container.length;</span><br><span class="line">                container[i] != <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure><p><code>\type(type)</code> 表达式：返回类型 <code>type</code> 对应的类型 (Class)，如 <code>type(boolean)</code> 为 <code>Boolean.TYPE</code>。<code>TYPE</code> 是 JML 采用的缩略表示，等同于 Java 中的<code>java.lang.Class</code>。</p><p><code>\typeof(expr)</code> 表达式：该表达式返回 <code>expr</code> 对应的准确类型。如 <code>\typeof(false)</code> 为 <code>Boolean.TYPE</code>。</p><h3 id="2-2-量化表达式"><a href="#2-2-量化表达式" class="headerlink" title="2.2 量化表达式"></a>2.2 量化表达式</h3><p><code>\forall</code> 表达式：全称量词修饰的表达式，表示对于给定范围内的元素，每个元素都满足相应的约束。<code>(\forall int i,j; 0 &lt;= i &amp;&amp; i &lt; j &amp;&amp; j &lt; 10; a[i] &lt; a[j])</code>，意思是针对任意 <code>0 &lt;= i &lt; j &lt; 10，a[i] &lt; a[j]</code>。这个表达式如果为真 (<code>true</code>)，则表明数组 <code>a</code> 实际是升序排列的数组。</p><p><code>\exists</code> 表达式：存在量词修饰的表达式，表示对于给定范围内的元素，存在某个元素满足相应的约束。<code>(\exists int i; 0 &lt;= i &amp;&amp; i &lt; 10; a[i] &lt; 0)</code>，表示针对 <code>0 &lt;= i &lt; 10</code>，至少存在一个 <code>a[i]&lt;0</code>。</p><p><code>\sum</code> 表达式：返回给定范围内的表达式的和。<code>(\sum int i; 0 &lt;= i &amp;&amp; i &lt; 5; i)</code>，这个表达式的意思计算 <code>[0,5)</code> 范围内的整数 <code>i</code> 的和，即 <code>0 + 1 + 2 + 3 + 4 = 10</code>。注意中间的 <code>0 &lt;= i &amp;&amp; i &lt; 5</code> 是对 <code>i</code> 范围的限制，求和表达式为最后面的那个 <code>i</code>。同理，我们构造表达式 <code>(\sum int i; 0 &lt;= i &amp;&amp; i &lt; 5; i*i)</code>，则返回的结果为 <code>1 + 4 + 9 + 16</code>。</p><p><code>\product</code> 表达式：返回给定范围内的表达式的连乘结果。<code>(\product int i; 0 &lt; i &amp;&amp; i &lt; 5; i)</code>，这个表达式的意思是针对 <code>(0,5)</code> 范围的整数的连乘结果，即 <code>1* 2* 3 * 4</code> 。</p><p><code>\max</code> 表达式：返回给定范围内的表达式的最大值。<code>(\max int i; 0 &lt;= i &amp;&amp; i &lt; 5; i)</code>，这个表达式返回 <code>[0,5)</code> 中的最大的整数，即 <code>4</code>。</p><p><code>\min</code> 表达式：返回给定范围内的表达式的最小值。<code>(\min int i; 0 &lt;= i &amp;&amp; i &lt; 5; i)</code>，这个表达式返回 <code>[0,5)</code> 中的最小的整数，即 <code>0</code>。</p><p><code>\num_of</code> 表达式：返回指定变量中满足相应条件的取值个数。<code>(\num_of int x; 0 &lt; x &amp;&amp; x &lt;= 20; x % 2 == 0)</code>，这个表达式给出 <code>(0,20]</code> 以内能够被 <code>2</code> 整除的整数个数，得到的数目为 <code>10</code>。一般的，<code>\num_of</code> 表达式可以写成 <code>(\num_of T x; R(x);P(x))</code>，其中 <code>T</code> 为变量 <code>x</code> 的类型，<code>R(x)</code> 为 <code>x</code> 的取值范围；<code>P(x)</code> 定义了 <code>x</code> 需要满足的约束条件。从逻辑上来看，该表达式也等价于 <code>(\sum T x; R(x) &amp;&amp; P(x); 1)</code>。</p><h3 id="2-3-集合表达式"><a href="#2-3-集合表达式" class="headerlink" title="2.3 集合表达式"></a>2.3 集合表达式</h3><p>集合构造表达式：可以在 JML 规格中构造一个局部的集合（容器），明确集合中可以包含的元素。<code>new JMLObjectSet &#123;Integer i | s.contains(i) &amp;&amp; 0 &lt; i.intValue() &#125; </code>表示构造一个 <code>JMLObjectSet</code> 对象，其中包含的元素类型为 <code>Integer</code>，该集合中的所有元素都在容器集合 <code>s</code> 中出现（注：该容器集合指 Java 程序中构建的容器，比如 <code>ArrayList</code>），且整数值大于 <code>0</code> 。集合构造表达式的一般形式为：<code>new ST &#123;T x | R(x) &amp;&amp; P(x)&#125;</code>，其中的 <code>R(x)</code> 对应集合中 <code>x</code> 的范围，通常是来自于某个既有集合中的元素，如 <code>s.has(x)</code> ，<code>P(x)</code> 对应 <code>x</code> 取值的约束。</p><h3 id="2-4-操作符"><a href="#2-4-操作符" class="headerlink" title="2.4 操作符"></a>2.4 操作符</h3><p>JML 表达式中可以正常使用 Java 语言所定义的操作符，包括算术操作符、逻辑预算操作符等。此外，JML 专门又定义了如下四类操作符。</p><p>(1) 子类型关系操作符：<code>E1&lt;:E2</code>，如果类型 <code>E1</code> 是类型 <code>E2</code> 的子类型 (sub type)，则该表达式的结果为真，否则为假。如果 <code>E1</code> 和 <code>E2</code> 是相同的类型，该表达式的结果也为真，如 <code>Integer.TYPE&lt;:Integer.TYPE </code>为真；但<code>Integer.TYPE&lt;:ArrayList.TYPE </code>为假。需要指出的是，任意一个类 <code>X</code> ，都必然满足 <code>X.TYPE&lt;:Object.TYPE</code>。</p><p>(2) 等价关系操作符：<code>b_expr1&lt;==&gt;b_expr2</code>或者<code>b_expr1&lt;=!=&gt;b_expr2</code>，其中 <code>b_expr1</code> 和 <code>b_expr2</code> 都是布尔表达式，这两个表达式的意思是 <code>b_expr1==b_expr2</code> 或者 <code>b_expr1!=b_expr2</code> 。可以看出，这两个操作符和 Java 中的 <code>==</code> 和 <code>!=</code> 具有相同的效果，按照 JML 语言定义，<code>&lt;==&gt;</code> 比 <code>==</code> 的优先级要低，同样 <code>&lt;=!=&gt;</code> 比 <code>!=</code> 的优先级低。</p><p>(3) 推理操作符：<code>b_expr1==&gt;b_expr2</code> 或者 <code>b_expr2&lt;==b_expr1</code>。对于表达式 <code>b_expr1==&gt;b_expr2</code> 而言，当 <code>b_expr1==false</code>，或者 <code>b_expr1==true</code> 且 <code>b_expr2==true</code> 时，整个表达式的值为 <code>true</code>。</p><p>(4) 变量引用操作符：除了可以直接引用 Java 代码或者 JML 规格中定义的变量外，JML 还提供了几个概括性的关键词来引用相关的变量。<code>\nothing</code> 指示一个空集；<code>\everything</code> 指示一个全集，即包括当前作用域下能够访问到的所有变量。变量引用操作符经常在assignable句子中使用，如 <code>assignable \nothing</code> 表示当前作用域下每个变量都不可以在方法执行过程中被赋值。</p><h2 id="3-方法规格"><a href="#3-方法规格" class="headerlink" title="3. 方法规格"></a>3. 方法规格</h2><p>方法规格是 JML 的重要内容，本手册仅涉及最基础的部分，而不引述 JML 扩展部分的内容。方法规格的核心内容包括三个方面，前置条件、后置条件和副作用约定。其中前置条件是对方法输入参数的限制，如果不满足前置条件，方法执行结果不可预测，或者说不保证方法执行结果的正确性；后置条件是对方法执行结果的限制，如果执行结果满足后置条件，则表示方法执行正确，否则执行错误。副作用指方法在执行过程中对输入对象或 <code>this</code> 对象进行了修改（对其成员变量进行了赋值，或者调用其修改方法）。课程区分两类方法：全部过程和局部过程。前者对应着前置条件恒为真，即可以适应于任意调用场景；后者则提供了非恒真的前置条件，要求调用者必须确保调用时满足相应的前置条件。从设计角度，软件需要适应用户的所有可能输入，因此也需要对不符合前置条件的输入情况进行处理，往往对应着异常处理。从规格的角度，JML 区分这两种场景，分别对应正常行为规格 (normal_behavior) 和异常行为规格 (expcetional_behavior)。</p><ul><li>前置条件 (pre-condition)</li></ul><p>前置条件通过 <code>requires</code> 子句来表示：<code>requires P;</code>。其中 <code>requires</code> 是 JML 关键词，表达的意思是“要求调用者确保P为真”。注意，方法规格中可以有多个 <code>requires</code> 子句，是并列关系，即调用者必须同时满足所有的并列子句要求。如果设计者想要表达或的逻辑，则应该使用一个 <code>requires</code> 子句，在其中的谓词 <code>P</code> 中使用逻辑或操作符来表示相应的约束场景：<code>requires P1||P2;</code>。</p><ul><li>后置条件 (post-condition)</li></ul><p>后置条件通过 <code>ensures</code> 子句来表示：<code>ensures P;</code>。其中 <code>ensures</code> 是 JML 关键词，表达的意思是“方法实现者确保方法执行返回结果一定满足谓词P的要求，即确保 <code>P</code> 为真”。同样，方法规格中可以有多个 <code>ensures</code> 子句，是并列关系，即方法实现者必须同时满足有所并列 <code>ensures</code> 子句的要求。如果设计者想要表达或的逻辑，这应该在在一个 <code>ensures</code> 子句中使用逻辑或 （<code>||</code>）操作符来表示相应的约束场景：<code>ensures P1||P2;</code>。</p><ul><li>副作用范围限定 (side-effects)</li></ul><p>副作用指方法在执行过程中会修改对象的属性数据或者类的静态成员数据，从而给后续方法的执行带来影响。从方法规格的角度，必须要明确给出副作用范围。JML 提供了副作用约束子句，使用关键词 <code>assignable</code> 或者 <code>modifiable</code>。从语法上来看，副作用约束子句共有两种形态，一种不指明具体的变量，而是用JML关键词来概括；另一种则是指明具体的变量列表。下面是几种经常出现的副作用约束子句形态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerSet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> ArrayList&lt;Integer&gt; elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> Integer max;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> Integer min;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*@</span></span><br><span class="line"><span class="comment">    @ ...</span></span><br><span class="line"><span class="comment">    @ assignable \nothing;</span></span><br><span class="line"><span class="comment">    @ assignable \everything;</span></span><br><span class="line"><span class="comment">    @ modifiable \nothing;</span></span><br><span class="line"><span class="comment">    @ modifiable \everthing;</span></span><br><span class="line"><span class="comment">    @ assignable elements;</span></span><br><span class="line"><span class="comment">    @ modifiable elements;</span></span><br><span class="line"><span class="comment">    @ assignable elements, max, min;</span></span><br><span class="line"><span class="comment">    @ modifiable elements, max, min;</span></span><br><span class="line"><span class="comment">    @*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如该例子所述，<code>assignble </code>表示可赋值，而 <code>modifiable</code> 则表示可修改。虽然二者有细微的差异，在大部分情况下，二者可交换使用。其中 <code>\nothing</code> 和 <code>\everything</code> 是两个关键词，前者表示当前作用域内可见的所有类成员变量和方法输入对象都不可以赋值或者修改；后者表示当前作用域内可见的所有类成员变量和方法输入对象都可以赋值或者修改。也可以指明具体可修改的变量列表，一个变量或多个变量，如果是多个则通过逗号分隔，如 <code>@ assignable elements, max, min;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注<span class="number">1</span>：JML不允许在副作用约束子句中指定规格声明的变量数据，因为这样的声明只是为了描述规格，并不意味实现者一定要实现这样的数据。</span><br><span class="line">注<span class="number">2</span>：默认情况下，方法的规格对调用者可见，但是方法所在类的成员变量一般都声明为 <span class="keyword">private</span> ,对调用者不可见。有时方法规格不得不使用类的成员变量来限制方法的行为，比如上面例子中的副作用范围限定，这就和类对相应成员变量的私有化保护产生了冲突。为了解决这个问题，JML提供了 <span class="comment">/*@spec_public@*/</span> 来注释一个类的私有成员变量，表示在规格中可以直接使用，从而调用者可见。</span><br></pre></td></tr></table></figure><p>设计中会出现某些纯粹访问性的方法，即不会对对象的状态进行任何改变，也不需要提供输入参数，这样的方法无需描述前置条件，也不会有任何副作用，且执行一定会正常结束。对于这类方法，可以使用简单的（轻量级）方式来描述其规格，即使用 <code>pure</code> 关键词：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//@ ensures \result == bachelor || \result == master;</span></span><br><span class="line"><span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="function"><span class="keyword">int</span> <span class="title">getStatus</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//@ ensures \result &gt;= 0;</span></span><br><span class="line"><span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="function"><span class="keyword">int</span> <span class="title">getCredits</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>针对上面的三个例子，<code>getName</code> 甚至不需要做任何限定，是一种极简的场景；<code>getStatus</code> 例子则限定了返回值 <code>\result</code> 要么 <code>==bachelor</code>，要么 <code>==master</code>；<code>getCredits</code> 的例子则限定了返回值必须大于等于 <code>0</code> ：<code>\result &gt;=0</code>。</p><p>在方法规格中，有些前置条件可以引用 <code>pure</code> 方法返回的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ requires c &gt;= 0;</span></span><br><span class="line"><span class="comment">@ ensures getCredits() == \old(getCredits()) + c;</span></span><br><span class="line"><span class="comment">@*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCredits</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure><p>有时候，前置条件或后置条件需要对不止一个变量进行约束，往往是需要对一个容器中的所有元素进行约束，这时就需要使用 <code>\forall</code> 或者 <code>\exists</code> 表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ requires size &lt; limit &amp;&amp; !contains(elem);</span></span><br><span class="line"><span class="comment">@ ensures \result == true;</span></span><br><span class="line"><span class="comment">@ ensures contains(elem);</span></span><br><span class="line"><span class="comment">@ ensures (\forall int e;</span></span><br><span class="line"><span class="comment">@ e != elem;</span></span><br><span class="line"><span class="comment">@ contains(e) &lt;==&gt; \old(contains(e)));</span></span><br><span class="line"><span class="comment">@ ensures size == \old(size) + 1;</span></span><br><span class="line"><span class="comment">@*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> elem)</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br></pre></td></tr></table></figure><p>上面的这个例子要求调用 <code>add</code> 方法之前，调用者必须确保当前对象管理的元素（整数）数目不能超过限制(<code>limit</code>)，同时不能重复加入相同的整数（<code>!contains(elem)</code>）。该方法的规格有三个并列的后置条件，<code>ensures contains(elem)</code> 要求 <code>add</code> 方法一定要把参数 <code>elem</code> 对应的整数加入到容器中；<code>ensures size == \old(size) + 1 </code>要求容器中管理的整数数目增加一个；中间的那个后置条件要求原来容器中包含的整数仍然在容器中，使用 <code>\forall </code>表达式来表示。</p><p>更进一步，假设带有规模限制的整数容器还提供了一个 <code>remove</code> 方法，这个方法要求：（1）如果输入参数在容器中，则移除该整数；（2）任何情况下，都不能移除容器中不等于输入参数的任何整数。要对这个方法的后置条件进行设计，需要从两个方面进行限制，一个是方法运行结果中不包含输入的整数，同时容器原来不等于输入参数的整数仍然还在容器中；另一方面需要对象容器的规模进行限制，如果输入参数在容器中，则容器存储的整数数目减少一个，否则保持不变。按照这个设计，可以得到如下完整的方法规格：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ ensures !contains(elem);</span></span><br><span class="line"><span class="comment">@ ensures (\forall int e;</span></span><br><span class="line"><span class="comment">@ e != elem;</span></span><br><span class="line"><span class="comment">@ contains(e) &lt;==&gt; \old(contains(e)));</span></span><br><span class="line"><span class="comment">@ ensures \old(contains(elem)) ==&gt; size == \old(size) - 1;</span></span><br><span class="line"><span class="comment">@ ensures !\old(contains(elem)) ==&gt; size == \old(size);</span></span><br><span class="line"><span class="comment">@*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> elem)</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br></pre></td></tr></table></figure><p>如前所述，为了有效的区分方法的正常功能行为和异常行为，JML 提供了这两类行为的区分机制，可以明确按照这两类行为来分别描述方法的规格，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">@ requires z &lt;= 99;</span></span><br><span class="line"><span class="comment">@ assignable \nothing;</span></span><br><span class="line"><span class="comment">@ ensures \result &gt; z;</span></span><br><span class="line"><span class="comment">@ also</span></span><br><span class="line"><span class="comment">@ public exceptional_behavior</span></span><br><span class="line"><span class="comment">@ requires z &lt; 0;</span></span><br><span class="line"><span class="comment">@ assignable \nothing;</span></span><br><span class="line"><span class="comment">@ signals (IllegalArgumentException e) true;</span></span><br><span class="line"><span class="comment">@*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">cantBeSatisfied</span><span class="params">(<span class="keyword">int</span> z)</span> <span class="keyword">throws</span> IllegalArgumentException；</span></span><br></pre></td></tr></table></figure><p>其中 <code>public normal_behavior </code>表示接下来的部分对 <code>cantBeSatisfied(int z)</code> 方法的正常功能给出规格。所谓正常功能，一般指输入或方法关联this对象的状态在正常范围内时所指向的功能。与正常功能相对应的是异常功能，即 <code>public exceptional_behavior</code> 下面所定义的规格。其中的 <code>public</code> 指相应的规格在所在包范围内的所有其他规格处都可见。需要说明的是，如果一个方法没有异常处理行为，则无需区分正常功能规格和异常功能规格，因而也就不必使用这两个关键词。</p><p>上面例子中出现了一个关键词 <code>also</code>，它的意思是除了正常功能规格外，还有一个异常功能规格。需要说明的是，按照JML语言规范定义，有两种使用 <code>also</code> 的场景：（1）父类中对相应方法定义了规格，子类重写了该方法，需要补充规格，这时应该在补充的规格之前使用 <code>also</code> ；（2）一个方法规格中涉及多个功能规格描述，正常功能规格或者异常功能规格，需要使用 <code>also</code> 来分隔。</p><p>我们仔细看上面的例子，实际上存在逻辑矛盾，即正常功能的前置条件蕴含了异常功能的前置条件（<code>&#123;z &lt;= 99&#125; </code>与 <code>&#123;z &lt; 0&#125;</code> 有交集），因此对于这个例子的规格而言，任何实现都不可能满足该规格。这样的矛盾规格是严重的设计错误，要避免。作为一种重要的设计检查原则，同一个方法的正常功能前置条件和异常功能前置条件一定不重叠。对于上面的例子而言，如果正常功能前置条件修改为 <code>z &gt;= 0</code> 就能满足这个要求。可以看出不论是正常功能规格，或者是异常功能规格，都包括前置条件、后置条件和副作用声明。不同的是，异常功能规格中，后置条件常常表示为抛出异常，使用 <code>signals</code> 子句来表示。</p><ul><li>signals 子句</li></ul><p>signals 子句的结构为 <code>signals (***Exception e) b_expr;</code>，意思是当 <code>b_expr</code> 为 <code>true</code> 时，方法会抛出括号中给出的相应异常 <code>e</code>。对于上面的例子而言，只要输入满足 <code>z &lt; 0</code>，就一定会抛出异常 <code>IllegalArgumentException</code>。需要注意的是，所抛出的既可以是 Java 预先定义的异常类型，也可以是用户自定义的异常类型。此外，还有一个注意事项，如果一个方法在运行时会抛出异常，一定要在方法声明中明确指出（使用 Java 的 <code>throws</code> 表达式），且必须确保 signals 子句中给出的异常类型一定等同于方法声明中给出的异常类型，或者是后者的子类型。</p><p>还有一个简化的 signals 子句，即 signals_only 子句，后面跟着一个异常类型。signals 子句强调在对象状态满足某个条件时会抛出符合相应类型的异常；而 signals_only 则不强调对象状态条件，强调满足前置条件时抛出相应的异常。</p><p>有时候，为了更加明确的区分异常，会针对输入参数的取值范围抛出不同的异常，从而提醒调用者进行不同的处理。这时可以使用多个 exceptional_behavior：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="comment">/** A specification that can&#x27;t be satisfied. */</span></span><br><span class="line">  <span class="comment">//@ public model non_null int[] credits; </span></span><br><span class="line">  <span class="comment">/*@ normal_behavior</span></span><br><span class="line"><span class="comment">    @ requires z &gt;=0 &amp;&amp; z &lt;= 100;</span></span><br><span class="line"><span class="comment">    @ assignable \nothing;</span></span><br><span class="line"><span class="comment">    @ ensures \result == credits.length;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    @ also</span></span><br><span class="line"><span class="comment">    @ exceptional_behavior</span></span><br><span class="line"><span class="comment">@ requires z &lt; 0;</span></span><br><span class="line"><span class="comment">@ assignable \nothing;</span></span><br><span class="line"><span class="comment">@ signals_only IllegalArgumentException;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@ also</span></span><br><span class="line"><span class="comment">    @ exceptional_behavior</span></span><br><span class="line"><span class="comment">@ requires z &gt; 100;</span></span><br><span class="line"><span class="comment">@ assignable \nothing;</span></span><br><span class="line"><span class="comment">@ signals_only OverFlowException;</span></span><br><span class="line"><span class="comment">    @*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">recordCredit</span><span class="params">(<span class="keyword">int</span> z)</span> <span class="keyword">throws</span> IllegalArgumentException, OverFlowException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子是针对 <code>Student</code> 类提供的 <code>recordCredit(int z)</code> 方法，从规格角度定义了一个规格数据 <code>int[] credits</code>，并提供了三个功能规格，使用两个 <code>also</code> 进行了分隔。注意看三个功能规格的 <code>requires</code> 子句，在一起覆盖了方法输入参数的所有看取值范围，而且彼此没有交叉。这是功能规格设计的基本要求，同学们一定要小心这一点。其中两个异常功能规格使用 signals_only 子句分别抛出相应的异常。需要指出的是，在异常功能规格中，除了抛出异常，也一样可以正常使用 ensures 子句来描述方法执行产生的其他结果。</p><h2 id="4-类型规格"><a href="#4-类型规格" class="headerlink" title="4. 类型规格"></a>4. 类型规格</h2><p>类型规格指针对 Java 程序中定义的数据类型所设计的限制规则，一般而言，就是指针对类或接口所设计的约束规则。从面向对象角度来看，类或接口包含数据成员和方法成员的声明及或实现。不失一般性，一个类型的成员要么是静态成员 (static member)，要么是实例成员 (instance member)。一个类的静态方法不可以访问这个类的非静态成员变量（即实例变量）。静态成员可以直接通过类型来引用，而实例成员只能通过类型的实例化对象来引用。因此，在设计和表示类型规格时需要加以区分。</p><p>JML 针对类型规格定义了多种限制规则，从课程的角度，我们主要涉及两类，不变式限制 (invariant) 和约束限制 (constraints)。无论哪一种，类型规格都是针对类型中定义的数据成员所定义的限制规则，一旦违反限制规则，就称相应的状态有错。</p><ul><li>不变式 invariant</li></ul><p>不变式（invariant）是要求在所有<strong>可见状态</strong>下都必须满足的特性，语法上定义 <code>invariant P</code>，其中 <code>invariant </code>为关键词，<code>P </code>为谓词。对于类型规格而言，<strong>可见状态 (visible state)</strong> 是一个特别重要的概念。下面所述的几种时刻下对象 <code>o</code> 的状态都是可见状态：</p><ul><li><p>对象的有状态构造方法（用来初始化对象成员变量初值）的执行结束时刻</p></li><li><p>在调用一个对象回收方法（finalize 方法）来释放相关资源开始的时刻</p></li><li><p>在调用对象 <code>o</code> 的非静态、有状态方法（non-helper）的开始和结束时刻</p></li><li><p>在调用对象 <code>o</code> 对应的类或父类的静态、有状态方法的开始和结束时刻</p></li><li><p>在未处于对象 <code>o</code> 的构造方法、回收方法、非静态方法被调用过程中的任意时刻</p></li><li><p>在未处于对象 <code>o</code> 对应类或者父类的静态方法被调用过程中的任意时刻</p></li></ul><p>由上面的定义可知，凡是会修改成员变量（包括静态成员变量和非静态成员变量）的方法执行期间，对象的状态都不是可见状态。这里的可见不是一般意义上的能否见到，而是带有完整可见的意思。在会修改状态的方法执行期间，对象状态不稳定，随时可能会被修改。换句话说，在方法执行期间，对象的不变式有可能不满足。因此，类型规格强调在任意可见状态下都要满足不变式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Path</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> ArrayList &lt;Integer&gt; seq_nodes;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> Integer start_node;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> Integer end_node;</span><br><span class="line">    <span class="comment">/*@ invariant seq_nodes != null &amp;&amp; </span></span><br><span class="line"><span class="comment">      @ seq_nodes[0] == start_node &amp;&amp; </span></span><br><span class="line"><span class="comment">      @ seq_nodes[seq_nodes.length-1] == end_node &amp;&amp; </span></span><br><span class="line"><span class="comment">      @ seq_nodes.length &gt;=2;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的例子所示，<code>Path</code> 类的不变式定义了 <code>seq_nodes</code> 不能为 <code>null</code> ，且任意一个 <code>path</code> 对象至少包括两个节点，一个起始节点 (<code>start_node</code>) 和一个终止节点 (<code>end_node</code>) 。一个类可以包括多个不变式，相互独立。如果一个对象的可见状态不满足不变式，则称该对象的状态有错。实际工程中，如果一个类中有两个产生逻辑矛盾的不变式（即二者不可能同时为真），则出现了规格设计缺陷。需要指出的是，不变式中可以直接引用 <code>pure</code> 形态的方法。</p><p>对应类成员变量有静态和非静态之分，JML 区分两类不变式，静态不变式 (static invariant) 和实例不变式 (instance invariant)。其中静态不变式只针对类中的静态成员变量取值进行约束，而实例不变式则可以针对静态成员变量和非静态成员变量的取值进行约束。可以在不变式定义中明确使用 <code>instance invariant </code>或 <code>static invariant </code>来表示不变式的类别。</p><ul><li>状态变化约束 constraint</li></ul><p>对象的状态在变化时往往也许满足一些约束，这种约束本质上也是一种不变式。JML 为了简化使用规则，规定invariant 只针对可见状态(即当下可见状态)的取值进行约束，而是用 constraint 来对前序可见状态和当前可见状态的关系进行约束。如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceCounter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> <span class="keyword">long</span> counter;</span><br><span class="line">    <span class="comment">//@ invariant counter &gt;= 0;</span></span><br><span class="line">    <span class="comment">//@ constraint counter == \old(counter)+1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类 <code>ServiceCounter</code> 拥有一个成员变量 <code>counter</code> ，包含一个不变式和一个状态变化约束。不变式指出<code>counter &gt;= 0</code>，而 constraint 不同，约束每次修改 <code>counter</code> 只能加 <code>1</code>。虽然这个约束可以在可能对 <code>counter</code> 进行修改的方法中通过后置条件来表示，但是每个可能修改 <code>counter</code> 的方法都需要加上这样的后置条件，远不如 constraint 这样的表示来的方便。不仅如此，invariant 和 constraint 可以直接被子类继承获得。</p><p>和不变式一样，JML 也根据类的静态成员变量区分了两类约束：static constraint 和 instance constraint。其中static constraint 只涉及类的静态成员变量，而 instance constraint 则可以涉及类的静态成员变量和非静态成员变量。同样，也可以在规格中通过关键词来明确加以区分：<code>static constraint P </code>和 <code>instance constraint P</code>。</p><ul><li>方法与类型规格的关系</li></ul><p>如果一个类是不可变类，其实就没必要定义其不变式，只需要在构造方法中明确其初始状态应该满足的后置条件即可。当然，也可以反过来，定义不变式，而不定义构造方法的后置条件。事实上，在大部分情况下，一个类有几种不同类别的方法：静态初始化（不是方法，但也是一种行为）、有状态静态方法、有状态构造方法、有状态非静态方法。下表给出了两类不变式与这些方法的关系：</p><table><thead><tr><th align="center"></th><th align="center">静态成员初始化</th><th align="center">有状态静态方法</th><th align="center">有状态构造方法</th><th align="center">有状态非静态方法</th></tr></thead><tbody><tr><td align="center">static invariant</td><td align="center">建立</td><td align="center">保持</td><td align="center">保持</td><td align="center">保持</td></tr><tr><td align="center">instance invariant</td><td align="center">(无关)</td><td align="center">(无关)</td><td align="center">建立</td><td align="center">保持，除非是finalizer方法</td></tr></tbody></table><p>注：“建立”的含义是静态成员建立了满足相应不变式的类或对象状态。“保持”的含义是如果方法执行前不变式满足，执行后还应该满足相应的不变式。</p><p>同理，JML 也对 constraint 与方法之间的关系进行了约定：</p><table><thead><tr><th align="center"></th><th align="center">静态成员初始化</th><th align="center">有状态静态方法</th><th align="center">有状态构造方法</th><th align="center">有状态非静态方法</th></tr></thead><tbody><tr><td align="center">static constraint</td><td align="center">(无关)</td><td align="center">遵从</td><td align="center">遵从</td><td align="center">遵从</td></tr><tr><td align="center">instance constraint</td><td align="center">(无关)</td><td align="center">(无关)</td><td align="center">(无关)</td><td align="center">遵从</td></tr></tbody></table><p>注：“遵从”的含义是成员变量的当前取值和上一个取值之间的关系满足 constraint 的规定，即“遵从规定”。</p><h2 id="5-一个完整例子"><a href="#5-一个完整例子" class="headerlink" title="5. 一个完整例子"></a>5. 一个完整例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="comment">/*@ spec_public @*/</span> String name;</span><br><span class="line"><span class="comment">//@ public invariant credits &gt;= 0;</span></span><br><span class="line"><span class="keyword">private</span> <span class="comment">/*@ spec_public @*/</span> <span class="keyword">int</span> credits;</span><br><span class="line"><span class="comment">/*@ public invariant credits &lt; 180 ==&gt; !master &amp;&amp;</span></span><br><span class="line"><span class="comment">  @ credits &gt;= 180 ==&gt; master;</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="comment">/*@ spec_public @*/</span> <span class="keyword">boolean</span> master;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*@ requires sname != null;</span></span><br><span class="line"><span class="comment">  @ assignable \everything;</span></span><br><span class="line"><span class="comment">  @ ensures name == sname &amp;&amp; credits == 0 &amp;&amp; master == false;</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span> <span class="params">(String sname)</span> </span>&#123;</span><br><span class="line">name = sname;</span><br><span class="line">credits = <span class="number">0</span>;</span><br><span class="line">master = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ requires c &gt;= 0;</span></span><br><span class="line"><span class="comment">  @ ensures credits == \old(credits) + c;</span></span><br><span class="line"><span class="comment">  @ assignable credits, master;</span></span><br><span class="line"><span class="comment">  @ ensures (credits &gt;= 180) ==&gt; master</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCredits</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">updateCredits(c);</span><br><span class="line"><span class="keyword">if</span> (credits &gt;= <span class="number">180</span>) &#123;</span><br><span class="line">changeToMaster();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ requires c &gt;= 0;</span></span><br><span class="line"><span class="comment">  @ ensures credits == \old(credits) + c;</span></span><br><span class="line"><span class="comment">  @ assignable credits;</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateCredits</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">credits += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ requires credits &gt;= 180;</span></span><br><span class="line"><span class="comment">  @ ensures master;</span></span><br><span class="line"><span class="comment">  @ assignable master;</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">changeToMaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">master = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ ensures this.name == name;</span></span><br><span class="line"><span class="comment">  @ assignable this.name;</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ ensures \result == name;</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个针对 <code>Student</code> 类的完整例子。该类提供了三个私有成员变量：<code>private String name</code>、<code>private int credits </code> 和<code>private boolean master</code>。如前所述，因为这三个是私有成员，规格中是不可见的，JML 通过使用 <code>/*@ spec_public @*/</code> 来解决这个问题。</p><p>对比看一下 <code>addCredits(c)</code> 方法和 <code>updateCredits(c)</code> 方法的规格，二者的共同效果是 <code>credits == \old(credits) + c</code>（如果 <code>c &gt;= 0</code>）。<code>(credits &gt;= 180) ==&gt; master </code>给出了 <code>addCredits(c)</code> 方法的差异化功能，即不仅仅改变学分，还会判断学分情况，从而及时改变 <code>master</code> 变量的取值。如果忽略掉了这个后置条件，实际上就隐藏了设计错误。注意方法的规格不对什么情况调用什么方法做出规定（这实际上是非常细节的实现问题），虽然 JML 提供了 callable 子句来规定一个方法在执行过程可能会调用哪些方法，但是并不会对方法执行的后置条件产生实质影响。</p><p>针对从给定方法实现中来提取规格的场景，实践中往往会有方法调用，这时需要把被调用方法的后置条件附加到当前方法，并增加关于该方法被调用条件的约束。可以很清楚的看到，<code>addCredits</code> 规格合并了 <code>changeToMaster</code> 的后置条件，但增加了相应的调用条件约束（<code>credits &gt;= 180</code>）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;规格&quot;&gt;&lt;a href=&quot;#规格&quot; class=&quot;headerlink&quot; title=&quot;规格&quot;&gt;&lt;/a&gt;规格&lt;/h1&gt;&lt;h2 id=&quot;什么是规格&quot;&gt;&lt;a href=&quot;#什么是规格&quot; class=&quot;headerlink&quot; title=&quot;什么是规格&quot;&gt;&lt;/a&gt;什么是规</summary>
      
    
    
    
    <category term="ObjectOriented" scheme="http://yoursite.com/categories/ObjectOriented/"/>
    
    
    <category term="OOP" scheme="http://yoursite.com/tags/OOP/"/>
    
    <category term="JML" scheme="http://yoursite.com/tags/JML/"/>
    
  </entry>
  
  <entry>
    <title>「OS」IO管理</title>
    <link href="http://yoursite.com/2021/05/19/OperatingSystem/OS-IO%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2021/05/19/OperatingSystem/OS-IO%E7%AE%A1%E7%90%86/</id>
    <published>2021-05-19T08:46:00.000Z</published>
    <updated>2021-05-26T15:51:20.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="I-O-设备"><a href="#I-O-设备" class="headerlink" title="I/O 设备"></a>I/O 设备</h1><p>可以将数据输入到计算机，或接收计算机输出数据的外部设备。</p><p>UNIX 系统将外部设备抽象为一种特殊的文件 ，用户可以使用与文件操作相同的方式对外部设备进行操作。</p><p><strong>总线（<code>Bus</code>）</strong>是接入 I/O 设备的主要方式  </p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>按使用特性：人机交互类、存储类、网络通信类</p><p>按信息交换单位 ：</p><ul><li>块设备：数据传输单位为块，传输速率高，可寻址。如磁盘</li><li>字符设备：数据传输单位为字符，一般采用中断驱动。如鼠标键盘等。</li></ul><h1 id="I-O-控制器"><a href="#I-O-控制器" class="headerlink" title="I/O 控制器"></a>I/O 控制器</h1><p>CPU 通过一个电子部件——I/O 控制器来实现 CPU 对设备的控制。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>接受和识别 CPU 发出的指令。I/O 寄存器有相应的<strong>控制寄存器</strong>来存放命令和参数。</li><li>向 CPU 报告设备的状态。I/O 控制器有相应的<strong>状态寄存器</strong>记录 I/O 设备当前的状态。</li><li>数据交换。I/O 控制器中会设置相应的数据寄存器。输出时，数据寄存器用于暂存C PU发来的数据，之后再由控制器传送备。输入时，数据寄存器用于暂存设备发来的数据，之后C PU从数据寄存器中取走数据。</li><li>地址识别。类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的“地址”。I/O控制器通过CPU提供的“地址”来判断CPU要读／写的是哪个寄存器<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2></li></ul><p><img src="https://pic.imgdb.cn/item/60a4ec656ae4f77d35e5b4e8.jpg"></p><ul><li>一个 I/O 控制器可能对应多个设备</li><li>相应的，数据寄存器、控制寄存器、状态寄存器也会有多个。有的计算机在内存地址后继续编址，称为<strong>内存映像 I/O</strong>。有的采用 I/O 专用地址，即寄存器<strong>独立编址</strong></li></ul><p>内存映像 I/O 简化了指令，可以采用对内存进行操作的指令对控制器进行操作。而独立编址则需要设置专门的指令来实现。</p><h1 id="I-O-控制方式"><a href="#I-O-控制方式" class="headerlink" title="I/O 控制方式"></a>I/O 控制方式</h1><h2 id="程序直接控制"><a href="#程序直接控制" class="headerlink" title="程序直接控制"></a>程序直接控制</h2><p>读操作：</p><ol><li>CPU 向 I/O 控制器发出读指令，设备启动，状态寄存器设为 1（未就绪）</li><li>CPU <strong>轮询</strong>检查 I/O 控制器的状态</li><li>输入设备准备好数据后将数据传给控制器，报告自身状态</li><li>控制器将输入的数据放到数据寄存器当中，将状态改为 0（已就绪）</li><li>CPU 发现设备已就绪，就将数据寄存器中的内容读入 CPU 的寄存器中，再将 CPU 寄存器中的内容放入内存。</li></ol><p>数据传输单位：每次读写一个字</p><p>数据流向：</p><ul><li>读：I/O 设备 -&gt; CPU -&gt; 内存</li><li>写：内存 -&gt; CPU -&gt; I/O 设备</li></ul><p>缺点：</p><ul><li>CPU 长期处于”忙等”状态，利用率低</li></ul><h2 id="中断驱动"><a href="#中断驱动" class="headerlink" title="中断驱动"></a>中断驱动</h2><p>在CPU发出读／写命令后，将等待 I/O 的进程阻塞，切换到别的进程执行。当 I/O 完成后，控制器会向CPU发出一个中断信号，CPU检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。处理中断的过程中，CPU从 I/O 控制器读一个字的数据传送到CPU寄存器，再写入主存。接着，CPU恢复等待I/O的进程（或其他进程）的运行环境，然后继续执行。</p><ul><li>CPU会在每个指令周期的末尾检查中断； </li><li>如果中断发生的频率太高，也会降低系统性能。</li></ul><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>DMA方式（Direct Memory Access，直接存储器存取。主要用于块设备的 I/O 控制），由一个专门的控制器来完成数据从内存到设备或者是从设备到内存的传输工作。</p><ul><li>数据的传送单位是“块”。</li><li>数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU作为中转。</li><li>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</li></ul><p><img src="https://pic.imgdb.cn/item/60a4f8ab6ae4f77d353227a5.jpg"></p><ul><li>DR （Data Register，数据寄存器）：暂存从设备到内存，或从内存到设备的数据。</li><li>MAR （Memory Address Register，内存地址寄存器）：在输入时，MAR表示数据应放到内存中的什么位置；输出时MAR表示要输出的数据放在内存中的什么位置。</li><li>DC（Data Counter，数据计数器）：表示剩余要读/写的字节数。</li><li>CR（Command Register，命令／状态寄存器）：用于存放CPU发来的I/O命令，或设备的状态信息。</li></ul><p>首先，CPU指明此次要进行的操作，并说明要读入多少数据、数据要存放在内存的什么位置、数据在外部设备上的地址（如：在磁盘上的地址）</p><p>控制器会根据CPU提出的要求完成数据的读／写工作，整块数据的传输完成后，才向CPU发出中断信号</p><p>CPU干预的频率：</p><ul><li>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</li></ul><p>数据传送的单位：</p><ul><li>每次读/写一个或多个块（注意：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）</li></ul><p>数据的流向（不再需要经过CPU）</p><ul><li>读操作（数据输入）：I/O设备→内存</li><li>写操作（数据输出）：内存→ I/O设备</li></ul><p>缺点：CPU每发出一条 I/O 指令，只能读／写一个或多个连续的数据块。如果要读／写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条 I/O 指令，进行多次中断处理才能完成。</p><h2 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h2><p>通道：一种硬件，可以识别并执行一系列通道指令</p><p>流程：</p><ul><li>CPU向通道发出I/O指令。指明通道程序在内存中的位置，并指明要操作的是哪个 I/O 设备。之后CPU就切换到其他进程执行了</li><li>通道执行内存中的通道程序（其中指明了要读入／写出多少数据，读／写的数据应放在内存的什么位置等信息）</li><li>通道执行完规定的任务后，向CPU发出中断信号，之后CPU对中断进行处理</li></ul><p>CPU干预的频率：极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读／写后才需要发出中断信号，请求CPU干预。</p><p>数据传送的单位：每次读/写一组数据块</p><p>缺点：实现复杂，需要专门的通道硬件支持<br>优点：CPU、通道、I/O 设备可并行工作，资源利用率很高。</p><h1 id="I-O-软件层次结构"><a href="#I-O-软件层次结构" class="headerlink" title="I/O 软件层次结构"></a>I/O 软件层次结构</h1><p><img src="https://pic.imgdb.cn/item/60a506536ae4f77d35a2e295.jpg"></p><ul><li>用户层软件：用户可直接使用该层提供的与 I/O 操作相关的库函数（Windows API）对设备进行操作；同时通过“系统调用”请求操作系统内核的服务</li><li>设备独立性软件：与设备硬件特性无关的功能基本均在这一层实现<ol><li>向上层提供统一的调用接口</li><li>设备保护。原理类似文件保护，不同用户对设备的访问权限也不同</li><li>差错处理。对一些设备的错误进行的处理。</li><li>设备的分配与回收。</li><li>数据缓冲区管理。通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</li><li>建立逻辑设备名到物理设备名的映射，根据设备类型选择调用相的驱动程序。这是根据<strong>逻辑设备表</strong>（LUT）来实现的。<br>操作系统系统可以采用两种方式管理逻辑设备表（LUT）：第一种：整个系统只设置一张LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。第二种：为每个用户设置一张LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。</li></ol></li><li>设备驱动程序：主要负责对硬件设备的具体控制，将上层命令转化为特定设备可执行的一系列操作，如设置设备寄存器、检查设备状态等。<br>  由于不同的 I/O 设备往往有不同的硬件特性 ，因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序</li><li>中断处理程序：进行中断处理</li><li>硬件</li></ul><p>设备独立性：</p><p>​    应用程序独立于具体使用的物理设备。为了实现设备独立性而引入了逻辑设备和物理设备这两个概念。在应用程序中， 使用逻辑设备名称来请求使用某类设备；而系统在实际执行时， 还必须使用物理设备名称。因此，系统须具有将逻辑设备名称转换为某物理设备名称的功能。</p><h1 id="I-O-核心子系统"><a href="#I-O-核心子系统" class="headerlink" title="I/O 核心子系统"></a>I/O 核心子系统</h1><h2 id="I-O调度"><a href="#I-O调度" class="headerlink" title="I/O调度"></a>I/O调度</h2><p>磁盘调度：（先来先服务算法、最短寻道优先算法、SCAN算法、C-SCAN算法、LOOK算法、C-LOOK算法）。当多个磁盘 I/O请求到来时，用某种调度算法确定满足 I/O 请求的顺序。</p><h2 id="设备保护"><a href="#设备保护" class="headerlink" title="设备保护"></a>设备保护</h2><p>每个设备也有对应的 FCB，当用户请求访问某个设备时，系统根据 FCB 中记录的信息来判断该用户是否有相应的访问权限，从而实现”设备保护”</p><h2 id="假脱机技术（SPOOLing）"><a href="#假脱机技术（SPOOLing）" class="headerlink" title="假脱机技术（SPOOLing）"></a>假脱机技术（SPOOLing）</h2><p><strong>脱机技术</strong>：</p><p>脱机技术指的是脱离主机的控制进行输入输出操作。很久以前是纸带输入，速度太慢，于是通过外围控制机将纸带数据输入到磁带，再输入主机，输出同理。<br>作用：​缓解CPU与慢速I/O设备的速度矛盾，实现预输入、缓输出。</p><p><strong>假脱机技术</strong>：利用软件的方式模拟脱机技术。可以把一台物理设备虚拟成逻辑上的多台设备。</p><h3 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h3><p><img src="https://pic.imgdb.cn/item/60a50e616ae4f77d35e8a72d.jpg"><br>输入井和输出井：模拟脱机输入/输出时的磁带</p><p>输入进程和输出进程：模拟脱机输入/输出时的外围控制机</p><h3 id="共享打印机原理"><a href="#共享打印机原理" class="headerlink" title="共享打印机原理"></a>共享打印机原理</h3><p><img src="https://pic.imgdb.cn/item/60a510256ae4f77d35f8298f.jpg"></p><p>虽然系统中只有一台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。</p><h2 id="设别的分配与回收"><a href="#设别的分配与回收" class="headerlink" title="设别的分配与回收"></a>设别的分配与回收</h2><p>设备分配时应考虑的因素有：</p><ul><li>设备的固有属性<ul><li>独占设备：一个时间段只能分配给一个进程（如打印机）</li><li>共享设备：可同时分配给多个进程（如磁盘），但各进程往往是宏观上同时共享使用设备，而微观上交替使用</li><li>虚拟设备：采用 SPOOLing 技术将独占设备改造成虚拟的共享设备</li></ul></li><li>设备分配算法</li><li>设备分配中的安全性<ul><li>安全分配方式：为进程分配一个设备后就将进程阻塞， I/O 完成再唤醒。一个时段内每个进程只能使用一个设备<br>  优点：破坏了“请求和保持”条件，不会死锁<br>  缺点：对于一个进程来说，CPU和 I/O 设备只能串行工作        </li><li>不安全分配方式：进程请求I/O，操作系统负责分配设备，进程可以继续执行或者请求新的I/O，直到某个I/O无法满足才阻塞进程。<br>  优点：进程的计算任务和 I/O 任务可以并行处理，使进程迅速推进<br>  缺点：有可能发生死锁</li></ul></li></ul><h3 id="静态分配和动态分配"><a href="#静态分配和动态分配" class="headerlink" title="静态分配和动态分配"></a>静态分配和动态分配</h3><p>静态分配：进程运行前为其分配全部所需资源，结束后归还。（破坏”请求和保持”条件，不会死锁）</p><p>动态分配：进程运行过程中动态申请设备资源</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>一个通道控制多个设备控制器，一个设备控制器控制多个设备。<br>因此系统为每个设备配置一张设备控制表（DCT）用于记录设备情况<br><img src="https://pic.imgdb.cn/item/60a608526ae4f77d354fee62.jpg"></p><p>每个设备控制器都会对应一张控制器控制表（COCT）。<br><img src="https://pic.imgdb.cn/item/60a608f46ae4f77d3555edd7.jpg"></p><p>每个通道对应一张通道控制表（CHCT）。</p><p>系统中还有系统设备表（SDT），记录了系统中全部设备的情况。</p><p><img src="https://pic.imgdb.cn/item/60a609df6ae4f77d355f2472.jpg"></p><p> <strong>分配过程</strong>：</p><p><img src="https://pic.imgdb.cn/item/60a60ab16ae4f77d356732d2.png"></p><p>注：只有设备、控制器、通道三者都分配成功，此次设备分配才算成功，之后便可启动 I/O 设备进行数据传送</p><p><strong>分配过程改进</strong>：</p><p><img src="https://pic.imgdb.cn/item/60a60cbb6ae4f77d357a894a.png"></p><p>逻辑设备表（LUT）建立了逻辑设备名与物理设备名之间的映射关系。</p><p>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项。</p><p>如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址。</p><p>逻辑设备表的设置问题：</p><ul><li>整个系统只有一张LUT：各用户所用的逻辑设备名不允许重复，适用于单用户操作系统</li><li>每个用户一张LUT：不同用户的逻辑设备名可重复，适用于多用户操作系统</li></ul><h2 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h2><p>缓冲区是一个存储区域， 可以使用专门的硬件寄存器实现，成本高容量小（如 TLB）<br>更多时候使用内存做缓冲区<br>作用：</p><ul><li>缓和CPU与I/O的速度矛盾</li><li>减少对CPU的中断频率，放宽对CPU中断的时间限制（中断驱动的字符型设备）</li><li>解决数据粒度不匹配的问题（输出进程每次生成一块数据，但 I/O 设备每次只能输出一个字符）</li><li>提高CPU与I/O的并行性</li></ul><h3 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h3><p>假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）。</p><p>注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。<br><img src="https://pic.imgdb.cn/item/60a756946ae4f77d35fa425e.png"><br><img src="https://pic.imgdb.cn/item/60a756a96ae4f77d35fadc46.jpg"></p><h3 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h3><p>顾名思义，在主存分配两个缓冲区。<br><img src="https://pic.imgdb.cn/item/60a761b86ae4f77d355a7bd3.png"><br><img src="https://pic.imgdb.cn/item/60a761b86ae4f77d355a7c29.jpg"></p><p>管道通信中的”管道”就是缓冲区。因此要实现数据双向传输，就必须设置两个管道</p><h3 id="循环缓冲区"><a href="#循环缓冲区" class="headerlink" title="循环缓冲区"></a>循环缓冲区</h3><p>将多个大小相等的缓冲区链接成一个循环队列。</p><p><img src="https://pic.imgdb.cn/item/60ac4de608f74bc15916ca0c.jpg"></p><h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为：空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。</p><p>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：用于收容输入数据的工作缓冲区（hin）、用于提取输入数据的工作缓冲区（sin）、用于收容输出数据的工作缓冲区（hout）、用于提取输出数据的工作缓冲区（sout）</p><p><img src="https://pic.imgdb.cn/item/60ac4f5f08f74bc15922cdf3.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;I-O-设备&quot;&gt;&lt;a href=&quot;#I-O-设备&quot; class=&quot;headerlink&quot; title=&quot;I/O 设备&quot;&gt;&lt;/a&gt;I/O 设备&lt;/h1&gt;&lt;p&gt;可以将数据输入到计算机，或接收计算机输出数据的外部设备。&lt;/p&gt;
&lt;p&gt;UNIX 系统将外部设备抽象为一种特</summary>
      
    
    
    
    <category term="OperatingSystem" scheme="http://yoursite.com/categories/OperatingSystem/"/>
    
    
    <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>「C++ 内存管理」</title>
    <link href="http://yoursite.com/2021/05/18/cpp/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2021/05/18/cpp/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-05-18T01:00:15.000Z</published>
    <updated>2021-05-23T13:42:32.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h1><p><img src="https://pic.imgdb.cn/item/60a25ffe6ae4f77d35e76384.jpg"></p><ul><li><strong>代码段</strong>：程序的所有指令会存放在这个区域，这是已经编译后的机器码。</li><li><strong>字面量池</strong>：程序初始化时的一些字符串字面量，在程序中用于显示文字</li><li><strong>全局数据段</strong>：程序初始化时的常量和全局/静态的变量。C/C++ 用<code>global/static</code>声明的变量都存放在这个区域，对所有函数公开可见。</li><li><strong>堆</strong>：这里保存的数据只是为了临时存储一些值而创建的，而我们可能在程序运行过程中可能会回收此内存。因为我们在程序执行期间不需要很长时间，所以使用C中的<code>new</code>或<code>malloc</code>这类内存分配程序来为我们所需的特定数据类型提供新的空间，并且随着我们要求越来越多的动态数据空间而该区域不断扩大，并且在内存中逐渐增长到更高的地址。</li><li><strong>栈</strong>：存储着该程序 “上下文”，它将从内存的高层地址开始，然后向另一个方向向下扩展。<strong>上下文</strong>其实就是程序中各个函数之间调用的<strong>先后顺序</strong>。</li></ul><h1 id="程序栈帧"><a href="#程序栈帧" class="headerlink" title="程序栈帧"></a>程序栈帧</h1><p>帧（<code>frame</code>），在进程中每个函数被调用时分别从这个栈占用一段区域，就称为帧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存布局&quot;&gt;&lt;a href=&quot;#内存布局&quot; class=&quot;headerlink&quot; title=&quot;内存布局&quot;&gt;&lt;/a&gt;内存布局&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://pic.imgdb.cn/item/60a25ffe6ae4f77d35e76384.j</summary>
      
    
    
    
    <category term="C++ 内存管理" scheme="http://yoursite.com/categories/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
    <category term="内存管理" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>「C++ 基础」泛型与模板</title>
    <link href="http://yoursite.com/2021/05/16/cpp/4%20-%20%E6%B3%9B%E5%9E%8B%E4%B8%8E%E6%A8%A1%E6%9D%BF/"/>
    <id>http://yoursite.com/2021/05/16/cpp/4%20-%20%E6%B3%9B%E5%9E%8B%E4%B8%8E%E6%A8%A1%E6%9D%BF/</id>
    <published>2021-05-16T01:00:15.000Z</published>
    <updated>2021-05-23T13:46:23.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b&lt;a?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T是模板的**模板参数(Template Parameter)**，可以表示一个具体的数据类型，例如<code>int</code>,<code>double</code>,<code>std::string</code></p><p><code>typename</code>关键字来定义模板参数，也可以使用<code>class</code>关键字替换</p><p><code>T a, T b</code>称<strong>调用参数</strong></p><p>函数体称<strong>模板函数</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数模板&quot;&gt;&lt;a href=&quot;#函数模板&quot; class=&quot;headerlink&quot; title=&quot;函数模板&quot;&gt;&lt;/a&gt;函数模板&lt;/h1&gt;&lt;h2 id=&quot;术语&quot;&gt;&lt;a href=&quot;#术语&quot; class=&quot;headerlink&quot; title=&quot;术语&quot;&gt;&lt;/a&gt;术语&lt;/h</summary>
      
    
    
    
    <category term="C++ 基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>「C++ 基础」重载</title>
    <link href="http://yoursite.com/2021/05/15/cpp/3%20-%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2021/05/15/cpp/3%20-%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2021-05-15T01:00:15.000Z</published>
    <updated>2021-05-26T15:03:35.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><p>为方便使用，C++ 允许在同一个作用域内，声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，不能仅通过返回类型的不同来重载函数。 </p><p>当调用一个<strong>重载函数</strong>或<strong>重载运算符</strong>时，编译器通过把所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为<strong>重载决策</strong>。 </p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，不能仅通过返回类型的不同来重载函数。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">printData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;整数为: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c[])</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字符串为: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   printData pd;</span><br><span class="line">   <span class="comment">// 输出整数</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="number">5</span>);</span><br><span class="line">   <span class="comment">// 输出字符串</span></span><br><span class="line">   <span class="keyword">char</span> c[] = <span class="string">&quot;Hello C++&quot;</span>;</span><br><span class="line">   pd.<span class="built_in">print</span>(c);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>允许程序使用表达式而不是命名函数，可以编写和阅读更容易。</p><p>重载函数的函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。 </p><p>将多个合法操作符连接也是合法的。如可以定义一个<code>operator **</code>来用于幂运算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp;);</span><br></pre></td></tr></table></figure><p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp;, <span class="keyword">const</span> Box&amp;);</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        Box box;</span><br><span class="line">        box.length = <span class="keyword">this</span>-&gt;length + b.length;</span><br><span class="line">        box.breadth = <span class="keyword">this</span>-&gt;breadth + b.breadth;</span><br><span class="line">        box.height = <span class="keyword">this</span>-&gt;height + b.height;</span><br><span class="line">        <span class="keyword">return</span> box;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> length;</span><br><span class="line">    <span class="keyword">double</span> breadth;</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Box3 = Box1 + Box2;</span><br><span class="line">    volume = Box3.<span class="built_in">getVolume</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Volume of Box3 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可重载的运算符列表：</p><table><thead><tr><th>双目算术运算符</th><th>+ (加)，-(减)，*(乘)，/(除)，% (取模)</th></tr></thead><tbody><tr><td>关系运算符</td><td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于)</td></tr><tr><td>逻辑运算符</td><td>||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td></tr><tr><td>单目运算符</td><td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td></tr><tr><td>自增自减运算符</td><td>++(自增)，–(自减)</td></tr><tr><td>位运算符</td><td>| (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td></tr><tr><td>赋值运算符</td><td>=, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=</td></tr><tr><td>空间申请与释放</td><td>new, delete, new[ ] , delete[]</td></tr><tr><td>其他运算符</td><td><code>()</code>(函数调用)，<code>-&gt;</code>(成员访问)，<code>,</code>(逗号)，<code>[]</code>(下标)</td></tr></tbody></table><p>不可重载的运算符列表：</p><ul><li><code>.</code>：成员访问运算符</li><li><code>.*</code>  <code>-&gt;*</code>：成员指针访问运算符</li><li><code>::</code>：域运算符</li><li><code>sizeof</code>：长度运算符</li><li><code>?:</code>：条件运算符</li><li><code>#</code>： 预处理符号</li></ul><h3 id="一元运算符重载"><a href="#一元运算符重载" class="headerlink" title="一元运算符重载"></a>一元运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Distance</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> feet;   <span class="comment">// 0 到无穷</span></span><br><span class="line">    <span class="keyword">int</span> inches; <span class="comment">// 0 到 12</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 所需的构造函数</span></span><br><span class="line">    <span class="built_in">Distance</span>() &#123;</span><br><span class="line">        feet = <span class="number">0</span>;</span><br><span class="line">        inches = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Distance</span>(<span class="keyword">int</span> f, <span class="keyword">int</span> i) &#123;</span><br><span class="line">        feet = f;</span><br><span class="line">        inches = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 显示距离的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayDistance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;F: &quot;</span> &lt;&lt; feet &lt;&lt; <span class="string">&quot; I:&quot;</span> &lt;&lt; inches &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载负运算符（ - ）</span></span><br><span class="line">    Distance <span class="keyword">operator</span>-()</span><br><span class="line">    &#123;</span><br><span class="line">        feet = -feet;</span><br><span class="line">        inches = -inches;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Distance</span>(feet, inches);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Distance D1(11, 10), D2(-5, 11);</span><br><span class="line"></span><br><span class="line">    -D1;                  <span class="comment">// 取相反数</span></span><br><span class="line">    D1.<span class="built_in">displayDistance</span>(); <span class="comment">// 距离 D1</span></span><br><span class="line"></span><br><span class="line">    -D2;                  <span class="comment">// 取相反数</span></span><br><span class="line">    D2.<span class="built_in">displayDistance</span>(); <span class="comment">// 距离 D2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h3><p>上上例</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Distance</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Distance &amp;d) &#123;</span><br><span class="line">        <span class="keyword">if</span> (feet &lt; d.feet) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (feet == d.feet &amp;&amp; inches &lt; d.inches) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Distance D1(11, 10), D2(5, 11);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (D1 &lt; D2) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;D1 is less than D2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输入输出运算符重载"><a href="#输入输出运算符重载" class="headerlink" title="输入输出运算符重载"></a>输入输出运算符重载</h3><p> C++ 能够使用流提取运算符 &gt;&gt; 和流插入运算符 &lt;&lt; 来输入和输出内置的数据类型。 可以重载流提取运算符和流插入运算符来操作对象等用户自定义的数据类型。 </p><p><strong>注意：</strong> 我们需要把运算符重载函数声明为类的友元函数，这样我们就能不用创建对象而直接调用函数。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Distance</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> feet;   <span class="comment">// 0 到无穷</span></span><br><span class="line">    <span class="keyword">int</span> inches; <span class="comment">// 0 到 12</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 所需的构造函数</span></span><br><span class="line">    <span class="built_in">Distance</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        feet = <span class="number">0</span>;</span><br><span class="line">        inches = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Distance</span>(<span class="keyword">int</span> f, <span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        feet = f;</span><br><span class="line">        inches = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;output, <span class="keyword">const</span> Distance &amp;D)</span><br><span class="line">    &#123;</span><br><span class="line">        output &lt;&lt; <span class="string">&quot;F : &quot;</span> &lt;&lt; D.feet &lt;&lt; <span class="string">&quot; I : &quot;</span> &lt;&lt; D.inches;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;input, Distance &amp;D)</span><br><span class="line">    &#123;</span><br><span class="line">        input &gt;&gt; D.feet &gt;&gt; D.inches;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Distance D1(11, 10), D2(5, 11), D3;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the value of object : &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; D3;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;First Distance : &quot;</span> &lt;&lt; D1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Second Distance :&quot;</span> &lt;&lt; D2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Third Distance :&quot;</span> &lt;&lt; D3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;重载&quot;&gt;&lt;a href=&quot;#重载&quot; class=&quot;headerlink&quot; title=&quot;重载&quot;&gt;&lt;/a&gt;重载&lt;/h1&gt;&lt;p&gt;为方便使用，C++ 允许在同一个作用域内，声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，不能</summary>
      
    
    
    
    <category term="C++ 基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="重载" scheme="http://yoursite.com/tags/%E9%87%8D%E8%BD%BD/"/>
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>「JVM」垃圾回收机制</title>
    <link href="http://yoursite.com/2021/05/14/Java/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2021/05/14/Java/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2021-05-14T02:44:17.000Z</published>
    <updated>2021-05-16T15:14:49.696Z</updated>
    
    <content type="html"><![CDATA[<p>与 C++ 程序设计语言相比，Java 程序设计语言拥有一个独特的语言特性——自动垃圾回收机制 (Garbage Collection)。在 Java 和 C++ 中，新创建一个对象都需要使用 <code>new</code> 运算符。然而，在 C++ 中，程序员需要人工管理内存，对于不再使用的对象使用 <code>delete</code> 运算符显式地回收内存；在 Java 中，程序员无需人工管理内存，JVM 会自动触发垃圾回收，将没有被引用的对象占据的内存空间释放。</p><h2 id="基本垃圾回收机制"><a href="#基本垃圾回收机制" class="headerlink" title="基本垃圾回收机制"></a>基本垃圾回收机制</h2><p>基本的 Java 垃圾回收机制如下：</p><p>首先，垃圾回收器会找出当前哪些对象是正在使用中的，并将其标记为存活对象；以及哪些对象是没有被引用的，并将其标记为未引用对象，这一步称为<strong>标记</strong> 。下图显示了一个标记前后的内存图的样式：</p><p><img src="https://oscimg.oschina.net/oscnet/1459c0fb17fd074a53898d29839ebfaf5ac.jpg" alt="img"></p><p>其次，垃圾回收器会将当前所有未引用对象删除，也就是上图中橙色的部分。</p><p><img src="https://oscimg.oschina.net/oscnet/e6c1fbbf3a3d2d31365d5b74ae5d111333b.jpg" alt="img"></p><p>最后，为了提升性能，在删除完未引用对象后，通常还会采取<strong>压缩</strong>操作，将内存中的存活对象放置在一起，以便后续能够更加高效快捷地分配新的对象。</p><p><img src="https://oscimg.oschina.net/oscnet/01b56829ee40fe72ebca25d554f1adcefce.jpg" alt="img"></p><h2 id="分代垃圾回收机制"><a href="#分代垃圾回收机制" class="headerlink" title="分代垃圾回收机制"></a>分代垃圾回收机制</h2><p>在实际的程序中，如果完全采用上面的基本垃圾回收机制，会导致垃圾回收非常低效，这是因为每一次垃圾回收都需要标记所有的对象并进行删除和压缩；垃圾回收的耗时与分配的对象数量成正相关的联系。</p><p>实际上，对一个程序运行过程中所有对象的存活时间进行统计，可以得到下面的图：</p><p><img src="https://oscimg.oschina.net/oscnet/711116febb97b1ca9f7d75dd6688b06dafe.jpg" alt="img"></p><p>横轴代表程序运行时间，纵轴代表分配的字节</p><p>从图中我们可以看出，大部分对象的存活时间都比较短(聚集在左侧)，存活的对象随着程序的运行逐渐减少，因此，利用对象存活时间的规律对内存中的对象进行分代，可以加快垃圾回收的效率。</p><p>JVM的分代将堆分为如下几个部分：</p><p><img src="https://oscimg.oschina.net/oscnet/805cb061ab8aa9b4f13c372855f13c8b854.jpg" alt="img"></p><p>图中红色部分和橙色部分为新生代，用来存储刚分配的对象和分配不久的对象；蓝色部分为老年代，用来存储存活了一定时期的对象；绿色部分为永久代，主要用来存放类和元数据的信息。</p><p>在 JVM 分代的设计下，垃圾回收被重新设计为如下过程：</p><p>首先，任何新分配的对象都存放于 <code>eden</code> 内存中，此时两个 <code>Survivor</code> 都是空的。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geqksgniujj315g0nk0vl.jpg" alt="image-20200513094116818"></p><p>当新分配的对象达到一定数量时，会将 <code>eden</code> 的空间填满，此时会触发**次垃圾回收(小型垃圾回收)**，我们称之为 <strong><code>MinorGC</code><strong>。具体地，<code>MinorGC</code> 采用的是</strong>标记-复制算法</strong>，首先对 <code>eden</code> 和 <code>FromSurvivorSpace</code> 中的对象进行标记，然后将存活对象复制到 <code>ToSurvivorSpace</code> 中去，随之清空 <code>eden</code> 和 <code>FromSurvivorSpace</code> 中的对象，并将 <code>FromSurvivorSpace</code> 和 <code>ToSurvivorSpace</code> 区域调换，如下图所示：</p><p><img src="https://oscimg.oschina.net/oscnet/bea90b63a47b9fdfae7a31fb3cd8595c894.jpg" alt="img"></p><p>在下一次的 <code>MinorGC</code> 时，会重复同样的操作，<code>Survivor</code> 区会再次发生交换：</p><p><img src="https://oscimg.oschina.net/oscnet/66c2ecf7a0fb11fdca60651c033bbac02d3.jpg" alt="img"></p><p>注意到：从 <code>eden</code> 区迁移到 <code>Survivor</code> 区的对象此时开始有年龄 <code>Age </code>的概念，这里的 <code>Age</code> 是用来表示对象的存活时间，每经过一次 <code>MinorGC</code>，对象的 <code>Age</code> 增加 <code>1</code>。</p><p>经过了一定次数的 <code>MinorGC</code> 后，有些对象的年龄会达到一定的阈值，图中示例为 <code>8</code>，此时这些年龄达到阈值的对象会被转移到老年区 <code>tenured</code> 中，表示为常使用的对象：</p><p><img src="https://oscimg.oschina.net/oscnet/a813815a4e8e6a3601c75ebfc2ae80d9dc7.jpg" alt="img"></p><p>对于老年代中的对象而言，未引用的对象不会在 <code>MinorGC</code> 中被回收，而是在**主垃圾回收 (大型垃圾回收)**，我们称之为 <strong><code>MajorGC</code></strong> 中被回收。</p><p><code>MinorGC</code> 的作用范围是新生代，<code>MajorGC</code> 的作用范围是老年代，<code>MinorGC</code> 发生的频率高，而 <code>MajorGC</code> 发生的频率则较低。老年代中的对象普遍比较稳定，通常会长期存在，所以变化不是特别频繁。<code>MajorGC</code> 采用的是<strong>标记-压缩算法</strong>，也就是上面提到的基本垃圾回收机制。</p><h2 id="代码模拟"><a href="#代码模拟" class="headerlink" title="代码模拟"></a>代码模拟</h2><p>以下是一个简单的垃圾回收机制模拟：</p><ul><li><code>MyObject</code><ul><li>模拟创建的对象</li></ul></li><li><code>MyHeap</code><ul><li>普通小顶堆</li></ul></li><li><code>JvmHeap</code><ul><li>JVM 中的堆，<code>eden</code>、<code>survivor</code>、<code>tenured </code> 均使用堆来实现，继承自<code>MyHeap</code>。</li></ul></li><li><code>MyJvm</code><ul><li>模拟的 JVM，负责管理堆、创建对象、删除对象引用和垃圾回收</li></ul></li><li><code>Main</code><ul><li>模拟程序的输入输出，输入方式为先输入指令名称，换行后再输入参数。</li><li>输入有以下几条指令：<ul><li><code>CreateObject</code> ：创建新的对象，换行后输入创建对象的个数</li><li><code>SetUnreferenced</code> ：将对象设置为未引用，换行后输入删除引用的对象id，用空格分隔</li><li><code>RemoveUnreferenced</code>：直接在堆中移除未引用的对象</li><li><code>MinorGC</code> ：小型垃圾回收</li><li><code>MajorGC</code> ：大型垃圾回收</li><li><code>SnapShot</code> ：查看当前 JVM 中堆的快照</li></ul></li></ul></li></ul><p><code>MyObject.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">MyObject</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> totalId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> <span class="keyword">boolean</span> referenced;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    MyObject() &#123;</span><br><span class="line">        id = totalId;<span class="comment">// 保证创建新对象的id不重复</span></span><br><span class="line">        totalId++;</span><br><span class="line">        referenced = <span class="keyword">true</span>;</span><br><span class="line">        age = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ assignable age;</span></span><br><span class="line"><span class="comment">      @ ensures age == newAge;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> newAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = newAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ ensures \result == age;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ ensures \result == id;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ assignable referenced;</span></span><br><span class="line"><span class="comment">      @ ensures referenced == newReferenced;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReferenced</span><span class="params">(<span class="keyword">boolean</span> newReferenced)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.referenced = newReferenced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ ensures \result == referenced;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function"><span class="keyword">boolean</span> <span class="title">getReferenced</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> referenced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires this == o;</span></span><br><span class="line"><span class="comment">      @ ensures \result == true;</span></span><br><span class="line"><span class="comment">      @ also</span></span><br><span class="line"><span class="comment">      @ requires this != o &amp;&amp; (o == null || !(o instanceof MyObject));</span></span><br><span class="line"><span class="comment">      @ ensures \result == false;</span></span><br><span class="line"><span class="comment">      @ also</span></span><br><span class="line"><span class="comment">      @ requires this != o &amp;&amp; o != null &amp;&amp; o instanceof MyObject;</span></span><br><span class="line"><span class="comment">      @ ensures \result == (id == (MyObject) o.getId() &amp;&amp;</span></span><br><span class="line"><span class="comment">      @         referenced == (MyObject) o.getReferenced() &amp;&amp;</span></span><br><span class="line"><span class="comment">      @         age == (MyObject) o.getAge());</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> MyObject)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        MyObject myObject = (MyObject) o;</span><br><span class="line">        <span class="keyword">return</span> id == myObject.getId() &amp;&amp; referenced == myObject.getReferenced()</span><br><span class="line">                &amp;&amp; age == myObject.getAge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(id, referenced, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires object != null;</span></span><br><span class="line"><span class="comment">      @ ensures ((age &lt; object.age) || (age == object.age &amp;&amp; id &lt; object.id)) ==&gt; (\result == -1);</span></span><br><span class="line"><span class="comment">      @ ensures ((age &gt; object.age) || (age == object.age &amp;&amp; id &gt;= object.id)) ==&gt; (\result == 1);</span></span><br><span class="line"><span class="comment">      @ also</span></span><br><span class="line"><span class="comment">      @ public exceptional_behavior</span></span><br><span class="line"><span class="comment">      @ requires object == null;</span></span><br><span class="line"><span class="comment">      @ signals (NullPointerException e) object == null;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(MyObject object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((age &lt; object.age) || (age == object.age &amp;&amp; id &lt; object.id)) &#123;</span><br><span class="line">        <span class="comment">// 年龄小的更小；年龄相同，则创建早的更小</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyHeap.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gcsimulation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHeap</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;<span class="comment">// 下标从1开始</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;   <span class="comment">// 初始划分的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;   <span class="comment">// 实际堆的大小</span></span><br><span class="line"></span><br><span class="line">    MyHeap(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        elementData = <span class="keyword">new</span> Object[capacity + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ ensures \result == size;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ ensures \result == elementData</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> Object[] getElementData() &#123;</span><br><span class="line">        <span class="keyword">return</span> elementData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires index &gt;= 1 &amp;&amp; index &lt;= getSize();</span></span><br><span class="line"><span class="comment">      @ assignable elementData;</span></span><br><span class="line"><span class="comment">      @ ensures (\forall int i; 1 &lt;= i &amp;&amp; i &lt;= getSize() &amp;&amp; i != index;</span></span><br><span class="line"><span class="comment">      @          \not_modified(elementData[i]));</span></span><br><span class="line"><span class="comment">      @ ensures elementData[index] == element;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="comment">// 置换 index 处数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElementData</span><span class="params">(<span class="keyword">int</span> index, T element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[index] = element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ assignable size;</span></span><br><span class="line"><span class="comment">      @ ensures size == 0;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="comment">// 清除堆的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires newSize &gt;= 0;</span></span><br><span class="line"><span class="comment">      @ assignable size;</span></span><br><span class="line"><span class="comment">      @ ensures size == newSize;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires indexA &gt;= 1 &amp;&amp; indexA &lt;= getSize() &amp;&amp; indexB &gt;= 1 &amp;&amp; indexB &lt;= getSize();</span></span><br><span class="line"><span class="comment">      @ assignable elementData;</span></span><br><span class="line"><span class="comment">      @ ensures (\forall int i; 1 &lt;= i &amp;&amp; i &lt;= getSize() &amp;&amp; i != indexA &amp;&amp; i != indexB;</span></span><br><span class="line"><span class="comment">      @          \not_modified(elementData[i]));</span></span><br><span class="line"><span class="comment">      @ ensures elementData[indexA] == \old(elementData[indexB]);</span></span><br><span class="line"><span class="comment">      @ ensures elementData[indexB] == \old(elementData[indexA]);</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> indexA, <span class="keyword">int</span> indexB)</span> </span>&#123;</span><br><span class="line">        T temp = (T) elementData[indexA];</span><br><span class="line">        elementData[indexA] = elementData[indexB];</span><br><span class="line">        elementData[indexB] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T newElement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">            Object[] oldElementData = elementData.clone();</span><br><span class="line">            <span class="comment">// 现有大小达到划分的容量，动态扩容</span></span><br><span class="line">            capacity = capacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            elementData = <span class="keyword">new</span> Object[capacity + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; i++) &#123;</span><br><span class="line">                elementData[i] = oldElementData[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        elementData[++size] = newElement;</span><br><span class="line">        <span class="keyword">int</span> tempIndex = size;</span><br><span class="line">        <span class="comment">// 将新添加元素向上调整，使其满足小顶堆性质（父节点大于子节点）</span></span><br><span class="line">        <span class="keyword">while</span> (tempIndex / <span class="number">2</span> != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                ((T) elementData[tempIndex]).compareTo((T) elementData[tempIndex / <span class="number">2</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(tempIndex, tempIndex / <span class="number">2</span>);</span><br><span class="line">            tempIndex /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;No element found in list.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除堆顶常规方法，将最后一个元素置换到堆顶，再一路往下调整满足堆结构</span></span><br><span class="line">        elementData[<span class="number">1</span>] = elementData[size--];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; size) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左右儿子都有，那么如果不满足小于两个儿子的小顶堆性质，要保证换到父节点的儿子小于另一个儿子</span></span><br><span class="line">            <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">1</span> &lt;= size) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((T) elementData[index]).compareTo((T) elementData[index * <span class="number">2</span>]) &gt; <span class="number">0</span> ||</span><br><span class="line">                        ((T) elementData[index]).compareTo((T) elementData[index * <span class="number">2</span> + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (((T) elementData[index * <span class="number">2</span> + <span class="number">1</span>]).compareTo(</span><br><span class="line">                            (T) elementData[index * <span class="number">2</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        swap(index * <span class="number">2</span>, index);</span><br><span class="line">                        index = <span class="number">2</span> * index;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        swap(index * <span class="number">2</span> + <span class="number">1</span>, index);</span><br><span class="line">                        index = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index * <span class="number">2</span> &lt;= size) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((T) elementData[index]).compareTo((T) elementData[index * <span class="number">2</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    swap(index * <span class="number">2</span>, index);</span><br><span class="line">                    index = <span class="number">2</span> * index;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JvmHeap.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gcsimulation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmHeap</span> <span class="keyword">extends</span> <span class="title">MyHeap</span>&lt;<span class="title">MyObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    JvmHeap(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传入要设置为未引用的 id list，将id在该list中的对象状态置为未引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUnreferencedId</span><span class="params">(List&lt;Integer&gt; objectId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> id : objectId) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="keyword">this</span>.getSize(); i++) &#123;</span><br><span class="line">                MyObject myObject = (MyObject) <span class="keyword">this</span>.getElementData()[i];</span><br><span class="line">                <span class="keyword">if</span> (myObject.getId() == id) &#123;</span><br><span class="line">                    myObject.setReferenced(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">this</span>.setElementData(i, myObject);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ assignable elementData, size;</span></span><br><span class="line"><span class="comment">      @ ensures size == (\sum int i; 1 &lt;= i &amp;&amp; i &lt;= \old(size) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @                              \old(elementData[i].getReferenced()) == true; 1);</span></span><br><span class="line"><span class="comment">      @ ensures (\forall int i; 1 &lt;= i &amp;&amp; i &lt;= \old(size);</span></span><br><span class="line"><span class="comment">      @          \old(elementData[i].getReferenced()) == true ==&gt;</span></span><br><span class="line"><span class="comment">      @           (\exist int j; 1 &lt;= j &amp;&amp; j &lt;= size; elementData[j].equals(\old(elementData[i]))))</span></span><br><span class="line"><span class="comment">      @ ensures (\forall int i; 1 &lt;= i &amp;&amp; i &lt;= \old(size);</span></span><br><span class="line"><span class="comment">      @          \old(elementData[i].getReferenced()) == false ==&gt;</span></span><br><span class="line"><span class="comment">      @           (\forall int j; 1 &lt;= j &amp;&amp; j &lt;= size;</span></span><br><span class="line"><span class="comment">      @           !elementData[j].equals(\old(elementData[i]))))</span></span><br><span class="line"><span class="comment">      @ ensures (\forall int i; 1 &lt;= i &amp;&amp; i &lt;= size;</span></span><br><span class="line"><span class="comment">      @          (\exists int j; 1 &lt;= j &amp;&amp; j &lt;= \old(size);</span></span><br><span class="line"><span class="comment">      @          elementData[i].equals(\old(elementData[j]))));</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="comment">// 移除 Jvm 堆中所有未标记的元素。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeUnreferenced</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可对原有的堆进行克隆，并通过 clear 方法将堆的 size 置为 0</span></span><br><span class="line">        Object[] oldElementData = <span class="keyword">this</span>.getElementData().clone();</span><br><span class="line">        <span class="keyword">int</span> oldSize = <span class="keyword">this</span>.getSize();</span><br><span class="line">        clear();</span><br><span class="line"><span class="comment">// 遍历原有的堆中的各个对象，调用 add 方法将其中已标记的对象加入至新堆中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= oldSize; i++) &#123;</span><br><span class="line">            MyObject myObject = (MyObject) oldElementData[i];</span><br><span class="line">            <span class="keyword">if</span> (myObject.getReferenced() == <span class="keyword">true</span>) &#123;</span><br><span class="line">                add(myObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires size &gt; 0;</span></span><br><span class="line"><span class="comment">      @ ensures (\exist int i; 1 &lt;= i &amp;&amp; i &lt;= size;</span></span><br><span class="line"><span class="comment">      @          (\forall int j; 1 &lt;= j &amp;&amp; j &lt;= size &amp;&amp; j != i;</span></span><br><span class="line"><span class="comment">      @            elementData[i].compareTo(elementData[j]) == -1) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @           \result == elementData[i]);</span></span><br><span class="line"><span class="comment">      @ also</span></span><br><span class="line"><span class="comment">      @ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires size == 0;</span></span><br><span class="line"><span class="comment">      @ ensures \result == null;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="comment">// 根据小顶堆性质，堆顶就是年龄最小的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function">MyObject <span class="title">getYoungestOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getSize() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (MyObject) getElementData()[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyJvm.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gcsimulation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJvm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_TENURING_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JvmHeap eden;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;JvmHeap&gt; survive = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fromSurviveSpace = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> JvmHeap tenured;</span><br><span class="line"></span><br><span class="line">    MyJvm() &#123;</span><br><span class="line">        eden = <span class="keyword">new</span> JvmHeap(DEFAULT_CAPACITY);</span><br><span class="line">        survive.add(<span class="keyword">new</span> JvmHeap(DEFAULT_CAPACITY));</span><br><span class="line">        survive.add(<span class="keyword">new</span> JvmHeap(DEFAULT_CAPACITY));</span><br><span class="line">        tenured = <span class="keyword">new</span> JvmHeap(DEFAULT_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createObject</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            MyObject newObject = <span class="keyword">new</span> MyObject();</span><br><span class="line">            eden.add(newObject);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (eden.getSize() == DEFAULT_CAPACITY) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Eden reaches its capacity,triggered Minor Garbage Collection.&quot;</span>);</span><br><span class="line">                <span class="comment">// 填满eden时，会触发小型垃圾回收机制</span></span><br><span class="line">                minorGC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUnreferenced</span><span class="params">(List&lt;Integer&gt; objectId)</span> </span>&#123;</span><br><span class="line">        eden.setUnreferencedId(objectId);</span><br><span class="line">        survive.get(fromSurviveSpace).setUnreferencedId(objectId);</span><br><span class="line">        tenured.setUnreferencedId(objectId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeUnreferenced</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        eden.removeUnreferenced();</span><br><span class="line">        survive.get(fromSurviveSpace).removeUnreferenced();</span><br><span class="line">        tenured.removeUnreferenced();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">minorGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Eden 中已标记的对象变为 1 岁并转移到 ToSurvivorSpace；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= eden.getSize(); i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) eden.getElementData()[i];</span><br><span class="line">            <span class="keyword">if</span> (!mo.getReferenced()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mo.setAge(mo.getAge() + <span class="number">1</span>);</span><br><span class="line">            survive.get(<span class="number">1</span> - fromSurviveSpace).add(mo);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// FromSurvivorSpace 中已标记的对象老一岁后，若未超过年龄阈值 8，则转移到 ToSurvivorSpace，反之转移到老年区 Tenured；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= survive.get(fromSurviveSpace).getSize(); i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) survive.get(fromSurviveSpace).getElementData()[i];</span><br><span class="line">            <span class="keyword">if</span> (!mo.getReferenced()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mo.setAge(mo.getAge() + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (mo.getAge() &gt; MAX_TENURING_THRESHOLD) &#123;</span><br><span class="line">                tenured.add(mo);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                survive.get(<span class="number">1</span> - fromSurviveSpace).add(mo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 清空 FromSurvivorSpace 和 Eden ，并交换 FromSurvivorSpace 与 ToSurvivorSpace。</span></span><br><span class="line">        eden.setSize(<span class="number">0</span>);</span><br><span class="line">        survive.get(fromSurviveSpace).setSize(<span class="number">0</span>);</span><br><span class="line">        fromSurviveSpace = <span class="number">1</span> - fromSurviveSpace;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">majorGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 拷贝老年区对象副本，清空老年区，将仍在引用状态的对象还回老年区中，相当于移除了未引用对象</span></span><br><span class="line">        Object[] oldElement = tenured.getElementData().clone();</span><br><span class="line">        <span class="keyword">int</span> oldSize = tenured.getSize();</span><br><span class="line">        tenured.setSize(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= oldSize; i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) oldElement[i];</span><br><span class="line">            <span class="keyword">if</span> (!mo.getReferenced()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tenured.add(mo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSnapShot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Eden: &quot;</span> + eden.getSize());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= eden.getSize(); i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) eden.getElementData()[i];</span><br><span class="line">            System.out.print(mo.getId() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Survive 0: &quot;</span> + survive.get(<span class="number">0</span>).getSize());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= survive.get(<span class="number">0</span>).getSize(); i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) survive.get(<span class="number">0</span>).getElementData()[i];</span><br><span class="line">            System.out.print(mo.getId() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MyObject youngestInSurvive0 = survive.get(<span class="number">0</span>).getYoungestOne();</span><br><span class="line">        <span class="keyword">if</span> (youngestInSurvive0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;, the youngest one &quot;</span> + youngestInSurvive0.getId() +</span><br><span class="line">                    <span class="string">&quot;&#x27;s age is &quot;</span> + youngestInSurvive0.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Survive 1: &quot;</span> + survive.get(<span class="number">1</span>).getSize());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= survive.get(<span class="number">1</span>).getSize(); i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) survive.get(<span class="number">1</span>).getElementData()[i];</span><br><span class="line">            System.out.print(mo.getId() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MyObject youngestInSurvive1 = survive.get(<span class="number">1</span>).getYoungestOne();</span><br><span class="line">        <span class="keyword">if</span> (youngestInSurvive1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;, the youngest one &quot;</span> + youngestInSurvive1.getId() +</span><br><span class="line">                    <span class="string">&quot;&#x27;s age is &quot;</span> + youngestInSurvive1.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Tenured: &quot;</span> + tenured.getSize());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tenured.getSize(); i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) tenured.getElementData()[i];</span><br><span class="line">            System.out.print(mo.getId() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MyObject youngestInTenured = tenured.getYoungestOne();</span><br><span class="line">        <span class="keyword">if</span> (youngestInTenured != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;, the youngest one &quot;</span> + youngestInTenured.getId() +</span><br><span class="line">                    <span class="string">&quot;&#x27;s age is &quot;</span> + youngestInTenured.getAge());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n---------------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Main.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gcsimulation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyJvm myJvm = <span class="keyword">new</span> MyJvm();</span><br><span class="line">        System.out.println(<span class="string">&quot;Start JVM Garbage Collection Simulation.&quot;</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String operation = scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (operation.equals(<span class="string">&quot;CreateObject&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = scanner.nextInt();</span><br><span class="line">                myJvm.createObject(count);</span><br><span class="line">                System.out.println(<span class="string">&quot;Create &quot;</span> + count + <span class="string">&quot; Objects.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">&quot;SetUnreferenced&quot;</span>)) &#123;</span><br><span class="line">                List&lt;Integer&gt; unrefList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span> (scanner.hasNextInt()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> id = scanner.nextInt();</span><br><span class="line">                    unrefList.add(id);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Set id: &quot;</span> + id + <span class="string">&quot; Unreferenced Object.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                myJvm.setUnreferenced(unrefList);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">&quot;RemoveUnreferenced&quot;</span>)) &#123;</span><br><span class="line">                myJvm.removeUnreferenced();</span><br><span class="line">                System.out.println(<span class="string">&quot;Remove Unreferenced Object.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">&quot;MinorGC&quot;</span>)) &#123;</span><br><span class="line">                myJvm.minorGC();</span><br><span class="line">                System.out.println(<span class="string">&quot;Execute Minor Garbage Collection.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">&quot;MajorGC&quot;</span>)) &#123;</span><br><span class="line">                myJvm.majorGC();</span><br><span class="line">                System.out.println(<span class="string">&quot;Execute Major Garbage Collection.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">&quot;SnapShot&quot;</span>)) &#123;</span><br><span class="line">                myJvm.getSnapShot();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Invalid operation.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;End of JVM Garbage Collection Simulation.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;与 C++ 程序设计语言相比，Java 程序设计语言拥有一个独特的语言特性——自动垃圾回收机制 (Garbage Collection)。在 Java 和 C++ 中，新创建一个对象都需要使用 &lt;code&gt;new&lt;/code&gt; 运算符。然而，在 C++ 中，程序员需要人工管</summary>
      
    
    
    
    <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>「C++ 基础」继承 &amp; 多态 内存原理</title>
    <link href="http://yoursite.com/2021/05/14/cpp/2%20-%20%E7%BB%A7%E6%89%BF%20&amp;%20%E5%A4%9A%E6%80%81/"/>
    <id>http://yoursite.com/2021/05/14/cpp/2%20-%20%E7%BB%A7%E6%89%BF%20&amp;%20%E5%A4%9A%E6%80%81/</id>
    <published>2021-05-14T01:00:15.000Z</published>
    <updated>2021-05-26T15:45:37.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承可以重用代码功能和提高执行效率的效果。 </p><p>一个类可以派生自多个类。类派生列表以一个或多个基类命名，形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>-<span class="keyword">class</span>:</span> access-specifier base-<span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure><p>未使用访问修饰符 access-specifier，则默认为 private。 </p><p>一个派生类继承的基类方法不包括如下几种：</p><ul><li>基类的构造函数、析构函数和拷贝构造函数。</li><li>基类的重载运算符。</li><li>基类的友元函数。</li></ul><h2 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h2><p>通常使用 <code>public</code> 继承</p><ul><li><strong>public 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中均不变</li><li><strong>protected 继承：</strong>基类 public 成员的访问属性在派生类中变成 protected。其他两种访问属性不变。</li><li><strong>private 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中均变成 private</li></ul><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>即一个子类可以有多个父类，它继承了多个父类的特性。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;</span>派生类名&gt;:&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类 Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line">      <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类 PaintCost</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintCost</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getCost</span><span class="params">(<span class="keyword">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> area * <span class="number">70</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line">   <span class="keyword">int</span> area;</span><br><span class="line"> </span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">   area = Rect.<span class="built_in">getArea</span>();</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total paint cost: $&quot;</span> &lt;&lt; Rect.<span class="built_in">getCost</span>(area) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>首先明确虚函数的目的：让不同的派生类将继承自父类的同一个虚成员函数(接口)，根据派生类的功能需求进行不同行为的实现，以此达到不同的派生类提供调用层的决策代码同一个函数接口的不同实现版本，从而保持对调用层代码逻辑无需变动,而且隐藏了同一个函数接口的不同版本的实现细节。</p><p>在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。在程序中任意点可以根据所调用的对象类型来选择调用的函数，即<strong>动态链接</strong>。虚函数必须被实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> ReturnType <span class="title">FunctionName</span><span class="params">(Parameter)</span></span>;</span><br></pre></td></tr></table></figure><p>尽管C++编译器允许父类和子类中定义<strong>相同名称</strong>的非虚成员函数，但这是一种不良的设计，因为一个适当的函数名标识了它要实现某个具体的功能。当我们在多个类中要为不同的类实现某个具体功能的不同版本，就应该使用虚函数。</p><p><img src="https://pic.imgdb.cn/item/60ae6c5c08f74bc1591adf07.jpg"></p><p>虚表中存放的是虚函数的地址。</p><p>类的虚表会被这个类的所有对象所共享。类的对象的虚表指针都指向同一个虚表，从这个意义上说，我们可以把虚表简单理解为类的静态数据成员。值得注意的是，虽然虚表是共享的，但是虚表指针并不是，类的每一个对象有一个属于它自己的虚表指针。</p><p>虚指针也是在构造函数里面初始化的，因此构造函数不可能是虚函数，没有初始化的虚指针无法调用虚函数。</p><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>如果在基类中不能对虚函数给出有意义的实现，就会用到纯虚函数。其声明为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funtion1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。</p><p>友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。</p><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p>多继承(环状继承)，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&#123;</span>......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> A&#123;.....&#125;;</span><br></pre></td></tr></table></figure><p>这个菱形继承中，D 的成员变量和成员函数继承到类 A 中变成了两份，这样就可能会产生命名冲突。我们需要在冲突成员前指明它具体来自哪个类：<code>B::chengyuan</code>。</p><p>为解决多继承时的命名冲突和冗余数据问题，c++提出了虚继承，使得在派生类中只保留一份间接基类的成员。</p><p><code>class 类名: virtual 继承方式 父类名</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&#123;</span>......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> A&#123;.....&#125;;</span><br></pre></td></tr></table></figure><p>虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 D 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p><p>此外，如果虚基类的成员只被一条派生路径覆盖，那么仍然可以直接访问这个被覆盖的成员。但是如果该成员被两条或多条路径覆盖了，那就不能直接访问了，此时必须指明该成员属于哪个类。</p><p>假设 D 定义了一个名为 x 的成员变量，当我们在 A 中直接访问 x 时，会有三种可能性：</p><ul><li>如果 B 和 C 中都没有 x 的定义，那么 x 将被解析为 D 的成员，此时不存在二义性。</li><li>如果 B 或 C 其中的一个类定义了 x，也不会有二义性，派生类的 x 比虚基类的 x 优先级更高。</li><li>如果 B 和 C 中都定义了 x，那么直接访问 x 将产生二义性问题。</li></ul><p>可以看到，使用多继承经常会出现二义性问题，必须十分小心。也因此c++之后很多面向对象编程语言都不支持多继承。</p><p>C++标准库中的 iostream 类就是一个虚继承的实际应用案例。iostream 从 istream 和 ostream 直接继承而来，而 istream 和 ostream 又都继承自一个共同的名为 base_ios 的类，是典型的菱形继承。此时 istream 和 ostream 必须采用虚继承，否则将导致 iostream 类中保留两份 base_ios 类的成员。</p><h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p><img src="https://pic.imgdb.cn/item/60a0db976ae4f77d35ba3413.jpg"></p><p>首先，每个使用虚函数的类或从基类派生的虚函数的类都被赋予自己的虚表。该表只是C++编译器在<strong>编译时</strong>设置的<strong>静态数组</strong>。虚表包含当前类中所有虚成员函数的函数指针的相关条目，那么填入虚表的虚成员函数指针有四种来源：</p><ul><li><p>派生类本身原创定义的虚函数。</p></li><li><p>从父类继承的虚成员函数，且该函数未被派生类重写。</p></li><li><p>从父类继承的虚成员函数，但该函数已被派生类重写。需要注意的是，<strong>虚表的虚成员函数指针始终指向该类中的最新的派生版本的虚成员函数</strong>。也就是说重写后，派生类虚表中存的该函数的地址是重写后该函数在内存中的地址。</p></li><li><p>若当前类定义了虚析构函数，那么该类的虚析构函数的函数的地址会“成双成对”地填入虚表中。按照惯例,由于定义类时优先定义解构函数，再实现其他成员函数，因此该虚解构函数对的地址通常会出现在表中头两行。</p><p>为什么是两个函数？</p><ul><li>第一个析构函数，称为**完整对象析构函数(complete object destructor)**，执行销毁操作时无需在对象上调用delete()。</li><li>第二个解构函数称<strong>删除析构函数</strong>( deleting destructor)，在销毁对象后调用delete()。</li><li>两者都摧毁了任何虚拟基类。一个独立的非虚函数称为<strong>基类对象解构函数</strong>(base object destructor)，执行对象的销毁操作，但不执行其<strong>虚拟基类子对象</strong>的销毁操作，并且不调用delete()。</li></ul></li></ul><p>然后，当类对象实例化时，会将<code>*_vptr</code>设置为指向该类的虚表。</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>编译时，多态性是通过<strong>类成员函数重写</strong>和<strong>operator函数重载</strong>实现的。</p><p>运行时，多态性是通过使用继承和虚函数实现的。C++编译器在运行时，根据决策逻辑判断传入对象的类型，然后查找并根据该类虚表中的虚成员函数的地址，进行动态调度目标类中的成员函数。</p><h2 id="静态绑定-amp-动态绑定"><a href="#静态绑定-amp-动态绑定" class="headerlink" title="静态绑定 &amp; 动态绑定"></a>静态绑定 &amp; 动态绑定</h2><p><strong>绑定：</strong>是指将<strong>变量</strong>和<strong>函数名</strong>转换为地址的过程。</p><p><strong>静态绑定</strong>（前绑定）：在程序执行之前，程序编译阶段就确定的绑定。</p><ul><li>早期绑定意味着绑定的函数或者变量，该语句在编译阶段已经被编译成 <strong><code>call 函数地址</code></strong> 或 <strong><code>callq 函数地址</code></strong> 这样的汇编指令格式，并且这些汇编指令中的函数地址在程序编译后是固定不变的。</li><li>优点是效率高、编译器会帮你检查。非虚函数、静态函数都属于静态绑定。</li></ul><p><strong>动态绑定</strong>（后绑定）：是指在运行时才确定的函数调用。</p><ul><li>在一些带有决策性的业务逻辑的代码中，要等到用户的反馈，直到运行时，根据决策的结果才能知道将调用哪个函数。这称为后期绑定(或动态绑定)，动态绑定的技术的本源就是函数指针。在C ++中<strong>运行时多态</strong>正是使用的就是函数指针。</li><li>优点是不用申明类型，运行时方便修改。python 的动态语言特性（无需考虑变量类型）就是因为 Python 的解析器的底层就是用到了运行时的一系列<strong>类型检测</strong>和<strong>类型检测后的内存分配</strong>以及C的<strong>函数指针</strong>的<strong>间接调用</strong>等技术完成了对Python代码的解析和资源初始化，这一切是以低性能为代价的。</li></ul><p>C++编译器仅当遇到如下条件才会做动态绑定：</p><ul><li>通过类型指针,该指针是<code>upcast</code>操作的指针</li><li>该类型指针调用的是虚函数</li></ul><p>体现在汇编中，比如 <code>callq *%rdx</code>，就是调用寄存器中缓存的虚函数指针所指向的虚函数。而如果是静态绑定，那么就会是这样的汇编语句：<code>callq 0x401384</code> </p><h2 id="Upcasting-amp-downcasting"><a href="#Upcasting-amp-downcasting" class="headerlink" title="Upcasting &amp; downcasting"></a>Upcasting &amp; downcasting</h2><p>将派生类对象赋值给基类对象、将派生类指针赋值给基类指针、将派生类引用赋值给基类引用，这在 C++ 中称为向上转型（<code>Upcasting</code>）。向上转型无需强制类型转换，但会丢失精度。</p><p>所谓向下转型（<code>downcasting</code>），即父类对象转换为子类对象，需要类型转换。</p><p>强制类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// false</span></span><br><span class="line">Person p=<span class="keyword">new</span> <span class="built_in">Person</span>();</span><br><span class="line">Student stu=(Student)p;</span><br><span class="line"><span class="comment">// right</span></span><br><span class="line">Person p=<span class="keyword">new</span> <span class="built_in">Student</span>();</span><br><span class="line">Student stu=(Student)p; </span><br></pre></td></tr></table></figure><p>动态类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">destType* dstObj=<span class="keyword">dynamic_cast</span>&lt;destType*&gt;(src)</span><br></pre></td></tr></table></figure><p><code>dynamic_cast</code>是运行时处理的，运行时要进行运行时类型检查。转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。</p><p>如果要进行动态类型转换，基类中一定要有虚函数，因为运行时类型检查需要 “ <strong>运行时类型信息</strong>（<code>Runtime type information，RTTI</code>)”，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表。某些语言实现仅保留有限的类型信息，例如 [ 继承树 ] 信息，而某些实现会保留较多信息，例如对象的属性及方法信息。这确实增加了开销。但是RTTI可以确保进行类型转换(包含隐式转换和动态类型转换)之类的操作可以安全地进行。</p><p>如果运行时<code>src</code>和<code>destType</code>所引用的对象是相同类型，或者存在<code>is-a</code>关系(public继承)则转换成功；否则转换失败。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span>       </span><br><span class="line">    <span class="function">virtualvoid <span class="title">func</span><span class="params">()</span></span>&#123;&#125;           </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&#123;      </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;      </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Derived *pd = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    Base *pb = pd;</span><br><span class="line">Derived *pd2 = <span class="keyword">dynamic_cast</span>&lt;derived*&gt;(pb); <span class="comment">//向下转型，仍然有效地得到一个Derived类实例副本</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类的转换时，在类层次间进行上行转换时，<code>dynamic_cast</code>和<code>static_cast</code>的效果是一样的。在进行下行转换时，<code>dynamic_cast</code>具有类型检查的功能，比 <code>static_cast</code>更安全。</p><h2 id="内存原理"><a href="#内存原理" class="headerlink" title="内存原理"></a>内存原理</h2><p>首先，我们知道对于我们的自定义类型，如果我们没有重载<code>=</code>，是无法强制将一个类型对象类型转换并赋值给另一个类型的对象的。因为当我们尝试执行<code>a=b</code>，那么其实质就是调用了对象 a 的<code>operator=()</code>操作符函数，即等价于如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="keyword">operator</span>=(<span class="keyword">const</span> B &amp;b);</span><br></pre></td></tr></table></figure><p>而对于类实例的指针，我们是可以强制转换并赋值的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span><span class="keyword">int</span> i=<span class="number">1</span>;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span><span class="keyword">double</span> k=<span class="number">1.1</span>;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    A *p=&amp;a;</span><br><span class="line">    B *q=&amp;b;</span><br><span class="line">    p=(A*)q;<span class="comment">// 编译器允许</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若从大尺寸的类B强制类型转换类A，内存会将拷贝低地址位的内存数据，而丢弃高地址位的内存数据。若小尺寸到大尺寸转换，则源操作数的所有字节数据会按低地址到高地址的顺序依次拷贝到目标操作数，目标操作数超出源操作数尺寸的剩余高地址部分数据，编译器会以0填充。</p><p><strong>继承链</strong></p><p>继承动作的实质其实是：派生类通过继承得到类成员函数在内存中的地址。</p><p>父类公开或受保护的成员函数(包括虚函数)同样是被派生类继承，但继承的只是父类成员函数的<strong>调用权</strong>，在继承关系中，派生类从基类继承的成员函数实质上继承的是存储在代码段(<strong>Code Segment</strong>)内存区中，基类可共享的成员函数的内存地址，因为每个成员函数都有一个唯一的<strong>内存地址</strong>。</p><p>而所谓类型，其实就是规定这个类型的变量对哪部分内存拥有操作权限。</p><p>在继承中，派生类都从父类获得一份公开(public)或受保护(protected)的父类数据成员(属性)的副本，也就是说，每个派生类对象内部都持有一份“特殊版本”的父类实例的信息。所以父类类型指针，规定访问的是父类大小的内存区域，若我们将继承类实例化的对象赋给该指针，自然而然父类副本外的内存（即继承类的自定义部分）无法被父类指针访问。</p><p>因此，<code>Upcast</code>操作仅仅是拷贝了派生类中的基类实例副本，派生类所属的内存区域对于基类对象是一无所知的。这也产生了一个问题 —— “**对象切片(<code>Object Slicing</code>)**”，即当拷贝时，派生类原创的成员(属性和方法)会被编译器”阉割”掉。</p><p>在对象切片的作用下可能出现以下情况：</p><ul><li><p>对于非虚成员函数来说，基类对象只能得到基类原创定义且可被继承的成员函数的地址，派生类原创定义的成员函数的地址，对于 upcast 操作后的基类对象是不可见的。</p></li><li><p>对于虚成员函数来说，如下三种情况。对于基类对象运行时绑定哪个虚成员函数的地址，是依据填入基类的虚表的函数地址来判断的。</p><ul><li>若该函数是派生类原创定义的，对于upcast操作后的基类对象是不可见的。</li><li>若该函数是基类原创定义且未被派生类重写，对于 upcast 操作后的基类对象，该基类版本的虚函数可见。</li><li>若该函数是基类原创定义且已被派生类重写，对于 upcast 操作后的基类对象，该派生类版本的虚成员函数可见。</li></ul></li></ul><p><small>注：所谓内存访问限制，访存本身其实是没什么限制的，只是越界了会访问到无效数据而已（比如栈上的对象越界访问可能会访问到其他局部变量，堆上的对象越界访问可能会访问到堆块对齐的部分）编译器能做的只是从语法层面去限制生成越界的访存机器码，而不是防止访存的行为本身（即便编译器也能被骗过）</small></p><p>参考：<a href="https://zhuanlan.zhihu.com/p/192178632">https://zhuanlan.zhihu.com/p/192178632</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h1&gt;&lt;p&gt;继承可以重用代码功能和提高执行效率的效果。 &lt;/p&gt;
&lt;p&gt;一个类可以派生自多个类。类派生列表以一个或多个基类命名，形式如下：&lt;/p&gt;
&lt;f</summary>
      
    
    
    
    <category term="C++ 基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
    <category term="OOP" scheme="http://yoursite.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>「OS」进程管理</title>
    <link href="http://yoursite.com/2021/05/06/OperatingSystem/OS-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2021/05/06/OperatingSystem/OS-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2021-05-06T09:14:23.530Z</published>
    <updated>2021-06-09T07:35:56.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>进程：</strong>为了揭示多道程序、分时系统引发的动态特性（执行-暂停 -执行），而引入了进程。定义可参看内存管理。<br><strong>并发：</strong>有两个活动a1和a2，如果在某一时刻t，无论它们是在同一处理机上还是在不同的处理机上执行，只要都处在各自的起点和终点之间的某一处，则称a1和a2是并发执行的。<br><strong>并行：</strong>两个程序在同一时间度量下同时运行在不同的处理机上，则称这两个程序是并行执行的<br><strong>竞争：</strong>多个进程在读写一个共享数据时结果依赖于它们执行的相对时间<br><strong>竞争条件：</strong>多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关，称为竞争（发生）条件。<br><strong>Bernstein条件：</strong>满足该条件，则程序并发执行结果可再现。该条件可简单理解为两个程序只可以同时读。</p><p><strong>响应时间：</strong>进程到达直至进程结束之间的时间。响应比=响应时间/运行时间</p><h2 id="进程与程序"><a href="#进程与程序" class="headerlink" title="进程与程序"></a>进程与程序</h2><ul><li><strong>进程是动态的，程序是静态的</strong>：程序是有序代码的集合；进程是程序的执行。通常进程不可在计算机之间迁移；而程序通常对应着文件，静态和可以复制。</li><li><strong>进程是暂时的，程序是永久的</strong>：进程是一个状态变化的过程，程序可长久保存。</li><li>进程与程序的<strong>对应关系</strong>：通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。</li></ul><h2 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h2><blockquote><p>由若干条指令所组成的指令序列，来实现某个特定的操作功能<br>原语是操作系统核心组成部分，必须在管态（内核态）下执行，且常驻内存。其指令序列的执行是连续的、不可分割的。</p></blockquote><h3 id="创建原语"><a href="#创建原语" class="headerlink" title="创建原语"></a>创建原语</h3><ul><li>fork<br>创建子进程。一次调用有两个返回值。<br>在fork函数执行完毕后，子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID，如果出现错误则返回负值。</li><li>exec<br>程序替换。<br>当子进程调用exec函数来运行另一个程序时，这个进程的地址空间代码和数据都被新程序的代码和数据刷新替换。<h3 id="撤销原语"><a href="#撤销原语" class="headerlink" title="撤销原语"></a>撤销原语</h3></li><li>kill<br>释放资源、撤销子进程、重新调度<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2></li></ul><p><strong>就绪状态</strong>：进程已获得除处理机外的所需资源，只要分配CPU就可执行。</p><p><strong>执行状态</strong>：占用处理机资源；处于此状态的进程的数目小于等于CPU的数目。在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的idle进程（相当于空操作）。</p><p><strong>阻塞状态</strong>：正在执行的进程，由于发生某种事件而暂时无法执行，便放弃处理机处于暂停状态。</p><p><img src="https://img.imgdb.cn/item/60914edfd1a9ae528ffe8e3e.png"></p><h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h2><p>进程控制的主要任务是<strong>创建</strong>和<strong>撤销</strong>进程，以及实现进程的<strong>状态转换</strong>。</p><p>系统为每个进程定义了一个数据结构：进程控制块<strong>PCB</strong>。在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>进程的创建与撤销。是进程的唯一标志。</p><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ul><li><strong>进程标识符</strong>：每个进程都必须有一个唯一的标识符。Linux系统中是一个整型数。 在进程创建时由系统赋予。</li><li><strong>现场保护区：</strong>进程阻塞释放CPU时，要将CPU的各种状态信息保存</li><li><strong>互斥与同步机制：</strong>用于实现进程间互斥、同步和通信所需的信号量等</li><li>程序和数据地址，当前状态，优先级，资源清单，链接字（指出该进程所在队列中下一个进程PCB的首地址）</li></ul><h3 id="组织方式"><a href="#组织方式" class="headerlink" title="组织方式"></a>组织方式</h3><ul><li>线性表</li></ul><p>不论进程的状态如何，将所有的PCB连续地存放在内存的系统区</p><ul><li>索引方式</li></ul><p>系统按照进程的状态分别建立就绪索引表、 阻塞索引表等</p><ul><li>链接表方式</li></ul><p>系统按照进程的状态将进程的 PCB 组成队列，从而形成就绪队列、阻塞队列、运行队列等。</p><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p><strong>进程上下文</strong>，即一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈上的内容。</p><p>当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。这些内容被保存在任务自己的堆栈中, 入栈工作完成后就把下一个将要运行的任务的当前状况从该任务的栈中重新装入CPU寄存器, 并跳转到下一个进程被中断时的PC，开始下一个任务的运行, 这一过程就是<code>context switch</code>。</p><p>而陷入/退出内核（模态切换 <code>Mode Switch</code>），是由中断、异常、Trap指令（系统调用）引起。系统调用涉及到进程从用户态到内核态的切换（<code>mode switch</code>），此时涉及到的切换主要是寄存器上下文的切换，和通常所说的进程上下文切换（<code>Process Context Switch</code>）不同，mode switch 的消耗相对要小很多。</p><p>注：处理器总处于以下状态中的一种：</p><ol><li>内核态，运行于进程上下文，内核代表进程运行于内核空间；</li><li>内核态，运行于中断上下文，内核代表硬件运行于内核空间；</li><li>用户态，运行于用户空间。</li></ol><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><blockquote><p>线程（<code>thread</code>）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。<br>现代操作系统将资源拥有者称为进程，将可执行单元称为线程。</p></blockquote><h2 id="进程-amp-线程"><a href="#进程-amp-线程" class="headerlink" title="进程 &amp; 线程"></a>进程 &amp; 线程</h2><ul><li>线程间共享相同的地址空间，方便共享资源（也有栈、PC 等私有资源）。而进程地址空间相互独立，同步需要借助消息通信机制。</li><li>进程切换涉及虚拟地址空间的切换而线程不会，有效减少切换造成的开销。</li><li>进程创建/撤销时需要分配/回收大量资源，线程更轻量，开销更少</li><li>多线程并发度更高<h2 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h2><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3></li></ul><blockquote><p><code>User level threads(ULT)</code>，线程在用户空间，是通过 library 模拟的 thread，不需要或仅需要极少的 kernel 支持。由用户程序自行调用、调度和维护。</p></blockquote><p>典型的有：</p><ul><li><code>POSIX Pthreads</code><br>用于线程创建和同步的 POSIX 标准API , 可在用户级或者内核级实现。该 API 规定了线程库的行为，但不限定实现方法，在类 UNIX 系统（Solaris, Linux, Mac OS X）中很常见。</li><li><code>Java Threads</code></li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>线程的创建、撤消和调度不需要OS内核的支持，是在语言或用户库这一级处理，容易进行优化</li><li>可运行在任何操作系统上，只需要线程库的支持<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>用户级线程执行系统调用指令时将导致其所属进程被中断，内核会因此而阻塞所有相关的线程。</li><li>内核只能将处理器分配给进程，即使有多个处理器，也无法实现一个进程中的多个线程的并行执行。<h3 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h3><blockquote><p><code>Kernel level threads (KLT)</code>，kernel 有好几个分身, 一个分身可以处理一件事。支持内核线程的操作系统内核称作<strong>多线程内核</strong></p></blockquote><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4></li><li>CPU调度以线程为单位，由OS的线程调度程序负责线程的调度。内核可以在多个处理器上调度一个进程的多个线程实现同步并行执行</li><li>系统调用导致的阻塞只发生在线程级别</li><li>内核中的一些处理可以通过多线程实现<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4></li><li>一个进程中的线程切换需要内核参与，线程的切换涉及到两个模式的切换（进程-进程、线程-线程）</li><li>效率降低<h3 id="混合的线程实现方式"><a href="#混合的线程实现方式" class="headerlink" title="混合的线程实现方式"></a>混合的线程实现方式</h3><blockquote><p>线程在用户空间创建和管理，实现从用户空间线程到内核空间线程的映射</p></blockquote><h4 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h4>实现用户级线程和内核级线程的连接方式</li><li>Many-to-One Model<br>多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。</li><li>One-to-one Model<br>每个用户级线程映射到一个内核级线程。并发能力较强，但对应用程序性能影响大</li><li>Many-to-Many Model<br>n 个用户级线程映射到 m 个内核级线程上（m $\le$ n）<h1 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2></li></ul><p><strong>临界资源：</strong>一次仅允许一个进程访问的资源</p><p><strong>临界区：</strong>每个进程中访问临界资源的那段代码称为临界区</p><p><strong>进程互斥：</strong>两个或两个以上的进程，不能同时进入关于同一组共享资源的临界区，否则可能发生与时间有关的错误</p><p><strong>进程同步：</strong>系统中各进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性的过程。让本来异步并发的进程相互配合，有序推进。</p><h2 id="临界区管理"><a href="#临界区管理" class="headerlink" title="临界区管理"></a>临界区管理</h2><p><strong>空闲让进：</strong>临界资源处于空闲状态，允许进程进入临界区。临界区内仅有一个进程运行。<br><strong>忙则等待：</strong>临界区有正在执行的进程，所有其他进程则不可以进入临界区。<br><strong>有限等待：</strong>对要求访问临界区的进程，应保证在有限时间内进入自己的临界区，避免死等。<br><strong>让权等待：</strong>当进程（长时间）不能进入自己的临界区时，应立即释放处理机，尽量避免忙等。</p><h2 id="基于信号量的同步与互斥"><a href="#基于信号量的同步与互斥" class="headerlink" title="基于信号量的同步与互斥"></a>基于信号量的同步与互斥</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><blockquote><p>一个确定的二元组(s, q)，其中s是一个具有非负初值的整型变量，q是一个初始状态为空的队列程序。对其访问都是原子操作，且只允许对它进行P(信号变量)和V(信号变量)操作。它用来累计唤醒次数，由 Dijkstra 提出。</p></blockquote><p><strong>semWait 操作（P操作）</strong>：</p><ul><li>使信号量减1。若值为负，则执行 semWait 的进程被阻塞。否则进程继续执行。</li><li>有进程被阻塞时就会进入 q 队列</li></ul><p><strong>semSignal操作（V操作）</strong></p><ul><li>使信号量加1。若值小于或等于零，则被semWait操作阻塞的进程被解除阻塞。<br>PV 操作简单但不安全，使用不当会出现死锁。</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>二元信号量：取值仅为“0”或“1”，主要用作实现互斥。</li><li>一般信号量：初值为可用物理资源的总数，用于进程间的协作同步问题。</li></ul><h3 id="在并发中的应用"><a href="#在并发中的应用" class="headerlink" title="在并发中的应用"></a>在并发中的应用</h3><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>常使用二元信号量的PV操作实现两个进程的互斥。<br>信号量初值为 1，⼀个进程在进⼊临界区之前执⾏semWait操作，退出临界区后再执⾏⼀个semSignal操作。</p><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>想要先执行<code>code1 &amp; code2</code>，再执行<code>code 4</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>; <span class="comment">// 同步信号量初值为 0</span></span><br><span class="line"><span class="built_in">p1</span>() &#123;</span><br><span class="line">    code <span class="number">1</span>;</span><br><span class="line">    code <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">V</span>(S);</span><br><span class="line">    code <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">p2</span>() &#123;</span><br><span class="line">    <span class="built_in">P</span>(S);</span><br><span class="line">    code <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前驱关系"><a href="#前驱关系" class="headerlink" title="前驱关系"></a>前驱关系</h4><p>在”前操作”之后对相应同步变量执行 V 操作</p><p>在”后操作”之前对相应的同步变量执行 P 操作</p><p>例如：<code>S1-&gt;S2, S1-&gt;S3</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">semaphore a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">p1() &#123;</span><br><span class="line">...</span><br><span class="line">S1;</span><br><span class="line">V(a);</span><br><span class="line">V(b);</span><br><span class="line">&#125;</span><br><span class="line">p2() &#123;</span><br><span class="line">...</span><br><span class="line">P(a);</span><br><span class="line">S2;</span><br><span class="line">&#125;</span><br><span class="line">p3() &#123;</span><br><span class="line">...</span><br><span class="line">P(b);</span><br><span class="line">S3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有限并发"><a href="#有限并发" class="headerlink" title="有限并发"></a>有限并发</h4><p>指有n（1≤n≤c，c是⼀个常量）个进程并发执⾏⼀个函数或者⼀个资源。⼀个初始值为c 的信号量可以实现这种并发。</p><h3 id="信号量集机制"><a href="#信号量集机制" class="headerlink" title="信号量集机制"></a>信号量集机制</h3><p>信号量集是指同时需要多个资源时的信号量操作</p><h4 id="AND-型"><a href="#AND-型" class="headerlink" title="AND 型"></a>AND 型</h4><p>将进程需要的所有共享资源一次全部分配给它；待该进程使用完后再一起释放。</p><h4 id="一般型"><a href="#一般型" class="headerlink" title="一般型"></a>一般型</h4><p>进程对信号量$S_i$的测试值为$t_i$（用于信号量的判断，即$S_i &gt;= t_i$，资源数量低于ti时，便不予分配），占用值为 $d_i$（用于信 号量的增减，即$S_i = S_i - d_i$ 和 $S_i = S_i + d_i$ ）</p><h2 id="基于管程的同步与互斥"><a href="#基于管程的同步与互斥" class="headerlink" title="基于管程的同步与互斥"></a>基于管程的同步与互斥</h2><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>信号量机制存在的问题：编写困难、易出错</p><blockquote><p>管程是一种高级同步机制，由四部分组成：1. 管程的名称；2. 局部于管程内部的共享数据结构（变量）说明  3. 对该数据结构进行操作的一组互斥执行的过程；4. 对局部于管程内部的共享数据设置初始值的语句</p><p>这么看，管程其实很像</p></blockquote><p><strong>条件变量：</strong>为了区别等待的不同原因，管程引入了条件变量。不同的条件变量，对应不同原因的进程阻塞等待队列，初始时为空。若条件变量名为X，则调用同步原语的形式为<code>wait(X)</code>和<code>signal(X)</code>。</p><p><strong>与信号量区别：</strong></p><ul><li>条件变量的值不可增减，P-V操作的信号量值可增减</li><li>wait操作一定会阻塞当前进程；但P操作只有当信号量的值小于0时才会阻塞。</li><li>如果没有等待的进程，signal将丢失；而V操作增加了信号量的值，不会丢失。</li><li>访问条件变量必须拥有管程的锁<h3 id="Hoare-管程"><a href="#Hoare-管程" class="headerlink" title="Hoare 管程"></a>Hoare 管程</h3></li></ul><p><strong>入口等待队列</strong>：因为管程是互斥进入的，所以当一个进程试图进入一个已被占用的管程时它应当在管程的入口处等待，因而在管程的入口处应当有一个进程等待队列，称作入口等待队列。<br><strong>紧急等待队列</strong>：如果进程Ｐ唤醒进程Ｑ，则Ｐ等待Ｑ继续；Ｑ执行完又唤醒进程Ｒ，则Ｑ等待Ｒ继续，… 如此，在管程内部，由于执行唤醒操作，可能会出现多个等待进程（已被唤醒，但由于管程的互斥进入而等待），这个管程内部的等待队列被称为紧急等待队列，其优先级高于入口等待队列。</p><h4 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h4><ul><li><code>x.wait()</code><br>如果紧急等待队列非空，则唤醒第一个等待者；否则释放管程的使用权，执行此操作的进程排入x队列尾部（紧急等待队列与x队列的关系：紧急等待队列是由于管程的互斥进入而等待的队列，而x队列是因资源被占用而等待的队列）</li><li><code>x.signal()</code><br>如果x队列为空，则相当于空操作，执行此操作的进程继续；否则唤醒第一个等待者，执行<code>x.signal()</code>操作的进程排入紧急等待队列的<h4 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h4></li><li>mutex 用与互斥<br>初值为 1，进程退出管程时应执行V(mutex)开放管程，以便让其他调用者进入。为了使进程在等待资源期间，其他进程能进入管程， 故在wait操作中也必须执行V(mutex)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P(mutex);        &#x2F;&#x2F; 管程入口</span><br><span class="line">…</span><br><span class="line">Body of F</span><br><span class="line">…</span><br><span class="line">If(next_count &gt; 0)</span><br><span class="line">V(next);</span><br><span class="line">Else</span><br><span class="line">V(mutex);        &#x2F;&#x2F; 管程出口    </span><br></pre></td></tr></table></figure></li><li>next 初值为 0<br>凡发出si gnal操作的进程应该用P(next)挂起自己，直到被释放进程退出管程或产生其他等待条件。<br>进程在退出管程的过程前，须检查是否有别的进程在信号量next上等待，若有，则用V(next)唤醒它。next-count（初值为0），用来记录在next上等待的进程个数</li><li>x-sem 初值为 0<br>申请资源得不到满足时，执行P(x-sem)挂起。由于释放资源时，需要知道是否有别的进程在等待资源，用计数器x-count（初值<br>为0）记录等待资源的进程数。<br>执行signal操作时，应让等待资源的诸进程中的某个进程立即恢复运行，而不让其他进程抢先进入管程，这可以用V(x-se m)来实现<h2 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信 IPC"></a>进程间通信 IPC</h2></li></ul><p><strong>低级通信：</strong>只能传递状态和整数值（控制信息），包括进程互斥和同步所采用的信号量和管程机制。<br><strong>高级通信：</strong>适用于分布式系统，基于共享内存的多处理机系统，单处理机系统，能够传送任意数量的数据，可以解决进程的同步问题和通信问题，主要包括三类：管道、共享内存、消息系统。</p><h3 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h3><ul><li>数据只能向一个方向流动；写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。需要双方通信时，需要建立起两个管道；</li><li>只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）</li><li>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，不属于某种文件系统，而是单独构成一种文件系统，并且只存在于内存中。<h3 id="Named-Pipe-FIFO"><a href="#Named-Pipe-FIFO" class="headerlink" title="Named Pipe / FIFO"></a>Named Pipe / FIFO</h3></li><li>克服了”只能用于具有亲缘关系的进程间通信”的限制</li><li>它提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中。这样，只要可以访问该路径，就能够彼此通过FIFO 相互通信<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3>共享内存是指：同一块物理内存被映射到进程A、B各自的进程地址空间。</li><li>共享内存是最有用的进程间通信方式，也是最快的IPC形式（因为它避免了其它形式的IPC必须执行的开销巨大的缓冲复制）。<ul><li>当多个进程共享同一块内存区域，需要同步机制约束（互斥锁和信号量都可以）。<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3>通过两个通信原语（OS系统调用）:    </li></ul></li><li><code>send (destination, &amp;message)</code></li><li><code>receive(source, &amp;message)</code><h2 id="经典进程互斥与同步问题"><a href="#经典进程互斥与同步问题" class="headerlink" title="经典进程互斥与同步问题"></a>经典进程互斥与同步问题</h2><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3></li></ul><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区取出一个产品并使用。</p><p>producer :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">生产一个产品</span><br><span class="line">    <span class="built_in">P</span>(empty);</span><br><span class="line">    <span class="built_in">P</span>(mutex);</span><br><span class="line">    one &gt;&gt; buffer</span><br><span class="line">    <span class="built_in">V</span>(mutex);</span><br><span class="line">    <span class="built_in">V</span>(full);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>consumer : </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">P</span>(full);</span><br><span class="line">    <span class="built_in">P</span>(mutex);</span><br><span class="line">    one &lt;&lt; buffer</span><br><span class="line">    <span class="built_in">V</span>(mutex);</span><br><span class="line">    <span class="built_in">V</span>(empty);</span><br><span class="line">    使用产品;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>P 操作的互换可能会导致死锁（缓冲区无产品，且先执行 consumer；缓冲区满，producer阻塞）</p><p><strong>多生产者-多消费者</strong></p><p>不同类别的生产者生产的物品不同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">// 实现互斥访问盘子（缓冲区）</span></span><br><span class="line">semaphore apple = <span class="number">0</span>;<span class="comment">// 盘子中有几个苹果</span></span><br><span class="line">semaphore orange = <span class="number">0</span>;<span class="comment">// 盘子中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>;<span class="comment">// 盘子中还可以放多少水果</span></span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/609bbe12d1a9ae528f9bd01c.jpg"></p><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><p>对共享资源的读写操作，任一时刻“写者 ”最多只允许一个，而“读者”则允许多个。即”读写互斥”和”写写互斥”。</p><p>为了不令读进程之间也互斥，而读进 程与写进程又必须互斥访问，那么我们可以让第一个访问文件的读进程“加锁”，让最后一个访问完文件的读进程“解锁”。可以设置一个整数量 count 来记录当前有几个读进程在访问文件。</p><p><strong>读进程优先：</strong></p><p><img src="https://pic.imgdb.cn/item/609bd615d1a9ae528f5f909d.jpg"></p><p><strong>读写公平：</strong></p><p><img src="https://pic.imgdb.cn/item/609bd65dd1a9ae528f61e44a.jpg"></p><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>5个哲学家围绕一张圆桌而坐，桌子上放着5支筷子，每两个哲学家之间放一支；哲学家的动作包括思考和进餐，进餐时需要同时拿起他左边和右边的两支筷子，思考时则同时将两支筷子放回原处。如果筷子已在其他人手上，则需要等待。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>（破除资源互斥） 至多只允许四个哲学家同时（尝试）进餐,以保证至少有一个哲学家能够进餐,最终总会释放出他所使用过的两支筷子,从而可使更多的哲学家进餐。设置信号量room=4。</li><li>（破除资源互斥）对筷子进行编号，每个哲学家按编号从低到高拿起筷子。或者对哲学家编号，奇数号哲学家先拿左，再拿右；偶数号相反。</li><li>（破除保持等待）同时拿起两根筷子，否则不拿起。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//互斥地取筷子  </span></span><br><span class="line"><span class="built_in">Pi</span>()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">P</span>(mutex);  </span><br><span class="line">        <span class="built_in">P</span>(chopstick[i]);  </span><br><span class="line">        <span class="built_in">P</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">//拿右  </span></span><br><span class="line">        <span class="built_in">V</span>(mutex);  </span><br><span class="line">        吃饭  </span><br><span class="line">        <span class="built_in">V</span>(chopstick [i]);  </span><br><span class="line">        <span class="built_in">V</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">//放右  </span></span><br><span class="line">        思考</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h</summary>
      
    
    
    
    <category term="OperatingSystem" scheme="http://yoursite.com/categories/OperatingSystem/"/>
    
    
    <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>「OS」内存管理</title>
    <link href="http://yoursite.com/2021/05/03/OperatingSystem/OS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2021/05/03/OperatingSystem/OS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-05-03T10:07:00.000Z</published>
    <updated>2021-06-08T10:07:19.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>地址空间</strong>：一个进程能够用于访问内存的地址集合</p><p><strong>程序</strong>：是静止的，存放在磁盘上的可执行文件，是进程的实体。</p><p><strong>进程</strong>：是动态的，包括进程控制块 PCB，程序和程序处理对象（数据集），是一个程序的执行过程，是资源分配的基本单位。通常把进程分为系统进程和用户进程。</p><p><strong>作业</strong>：用户需要计算机完成的某项任务，是要求计算机所做工作的集合。通常包括程序、数据、操作说明书。</p><p><strong>系统碎片：</strong>内存中无法被利用的存储空间称为碎片</p><p><strong>内部碎片</strong>：分配给作业的存储空间中未被利用的部分</p><p><strong>外部碎片</strong>：系统中无法利用的小的空闲分区，如分区与分区之间存在的碎片。这是造成内存系统性能下降的主要原因，它可以通过<strong>紧凑技术</strong>等被整理后清除。</p><p><strong>紧凑技术：</strong>通过移动作业，把多个分散的小分区拼接成一个大分区。</p><ul><li>时机：找不到足够大的空闲分区，但总空闲分区容量满足要求。</li><li>实现支撑：<strong>动态重定位</strong></li></ul><h1 id="存储管理的功能"><a href="#存储管理的功能" class="headerlink" title="存储管理的功能"></a>存储管理的功能</h1><ul><li>存储分配和回收</li><li>地址变换<br>  可执行文件生成中的链接技术、程序加载时的重定位技术、进程运行时硬件和软件的地址变换技术</li><li>存储共享和保护</li><li>存储器扩充</li></ul><h1 id="分区式内存管理"><a href="#分区式内存管理" class="headerlink" title="分区式内存管理"></a>分区式内存管理</h1><h2 id="分区式分配"><a href="#分区式分配" class="headerlink" title="分区式分配"></a>分区式分配</h2><p>把内存分为大小相等或不等的分区，每个应用程序占用一个或几个分区。</p><h3 id="固定式分区"><a href="#固定式分区" class="headerlink" title="固定式分区"></a>固定式分区</h3><p>系统初始化时，内存划分为若干固定大小（不一定相等）的连续分区。程序适应分区。</p><ul><li>易于实现</li><li>但内碎片会造成浪费，并且分区总数固定，限制了并发执行的程序数目</li><li>采用分区表来记录分区大小和使用情况</li></ul><h3 id="可变式分区"><a href="#可变式分区" class="headerlink" title="可变式分区"></a>可变式分区</h3><p>分区边界可移动</p><ul><li>没有内碎片，但会有外碎片</li></ul><h2 id="闲置空间的管理"><a href="#闲置空间的管理" class="headerlink" title="闲置空间的管理"></a>闲置空间的管理</h2><p>跟踪内存使用情况的方法有：<strong>位图表示法</strong>和<strong>链表表示法</strong></p><h3 id="位图表示法"><a href="#位图表示法" class="headerlink" title="位图表示法"></a>位图表示法</h3><p>给每个分配单元赋予一个二进制数位,用来记录该分配单元是否闲置</p><ul><li>空间开销固定，时间开销低，但没有容错能力。</li></ul><h3 id="链表表示法"><a href="#链表表示法" class="headerlink" title="链表表示法"></a>链表表示法</h3><p>将分配单元按照是否闲置链接起来。</p><ul><li>有一定的容错能力：链表有被占空间和闲置空间的表项，可以相互验证</li></ul><h2 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h2><h3 id="基于顺序搜索"><a href="#基于顺序搜索" class="headerlink" title="基于顺序搜索"></a>基于顺序搜索</h3><h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><p>每个空闲区按其在内存中地址递增的顺序连在一起，在为作业分配存储区域时，从空闲区域链的始端开始查找，选第一个满足请求的空白块。</p><ul><li>导致空闲碎片集中在低地址区</li></ul><h4 id="下次适应算法"><a href="#下次适应算法" class="headerlink" title="下次适应算法"></a>下次适应算法</h4><p>将所有空闲区组织成一个循环链表，每次为存储请求查找合适分区时，总是从上次查找结束的地方开始</p><ul><li>可能会导致缺乏大的空闲分区</li></ul><h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><p>寻找大小最接近作业要求的存储区域</p><ul><li>产生许多难以利用的小空闲碎片</li></ul><h4 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h4><p>总是寻找最大的空闲区</p><ul><li>缺乏大的空闲分区</li></ul><h3 id="基于索引搜索"><a href="#基于索引搜索" class="headerlink" title="基于索引搜索"></a>基于索引搜索</h3><p>比顺序搜索快，一般用于大中型系统</p><h4 id="快速适应算法"><a href="#快速适应算法" class="headerlink" title="快速适应算法"></a>快速适应算法</h4><p>把空闲分区按容量大小进行分类，常用大小的空闲区设立单独的空闲区链表。系统为多个空闲链表设立一张管理索引表。</p><h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>介于固定分区与可变分区之间的动态分区技术。规定：无论已分配分区或空闲分区，其大小均为$2^k(k\in int)$</p><p>目前应用于 Linux 系统和多处理机系统。</p><p><strong>伙伴</strong>：在分配存储块时将一个大的存储块分裂成两个大小相等的小块，这两个小块称为”伙伴”。</p><p><strong>分配流程：</strong><br>当一个长度为 n 的进程申请内存，若$2^{i-1}&lt;n&lt;2^i$，则在空闲分区大小为$2^i$的空闲分区链表中查找<br>若该长度空闲分区耗尽，则查找大小为$2^{i+1}$的一个空闲分区，将其分为相等的两个分区，一个用于分配，一个加入大小为$2^{i}$的空闲链表中。以此向上类推。</p><p><strong>内存释放：</strong>考虑将被释放块与其伙伴和并成一个大的空闲块，然后继续合并直至不能合并为止。</p><h2 id="分区的存储保护"><a href="#分区的存储保护" class="headerlink" title="分区的存储保护"></a>分区的存储保护</h2><h3 id="界限寄存器法"><a href="#界限寄存器法" class="headerlink" title="界限寄存器法"></a>界限寄存器法</h3><ul><li>上下界寄存器<br>对于一个地址，将其与上界寄存器和下界寄存器比较，如果越界就报告地址错误</li><li>基址、限长寄存器<h3 id="存储保护键法"><a href="#存储保护键法" class="headerlink" title="存储保护键法"></a>存储保护键法</h3>给每个存储块赋予一个单独保护键，相当于一把锁；进入系统的每个作业也赋予一个保护键，相当于一把钥匙。<h2 id="内存扩充"><a href="#内存扩充" class="headerlink" title="内存扩充"></a>内存扩充</h2></li></ul><p><strong>覆盖</strong>与<strong>交换</strong>可以解决小的内存空间运行大的作业的问题。(现代 OS 主要用交换）</p><h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><p>把一个程序划分为一系列功能相对独立的程序段，让执行时不要求同时装入内存的程序段组成一组（称为覆盖段），共享主存的同一个区域。</p><p>一般要求作业各模块之间有明确的调用结构，程序员向系统指明覆盖结构，由 os 自动完成覆盖。</p><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>把暂时不用的进程（等待 I/O）及其数据从主存移至辅存，把指定程序或数据从辅存读入主存，让其在系统中运行。</p><p>交换时，需要：1. 保存前一个进程的现场，寄存器 &amp; 堆栈等。2. 创建新进程的运行现场</p><ul><li>覆盖可以减少单个程序运行所需的空间，交换可以减少多个程序同时占用的内存。</li></ul><h1 id="分页式存储管理"><a href="#分页式存储管理" class="headerlink" title="分页式存储管理"></a>分页式存储管理</h1><p>把一个逻辑地址连续的程序分散存放到若干不连续的内存区域内。既可充分利用内存空间，也可减少移动带来的开销。</p><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>页</strong>：把每个作业的地址空间分成一些大小相等的片，称之为页面。</p><p><strong>存储块/页框</strong>：把物理内存的存储空间也分成和页面大小相同的片。</p><p><strong>页表：</strong>存放在内存中，记录进程的内存分配情况，实现进程运行时的动态重定位。</p><p><strong>纯分页系统：</strong>不具备页面对换功能的分页存储管理方式。在调度一个作业时，必须把它的所有页一次装到主存的页框内。若页框数不足，则作业必须等待。</p><p><strong>地址结构：</strong></p><ul><li>逻辑地址：<code>31~页号~12|11~页内偏移~0</code></li><li>物理地址：<code>21~块号~12|11~块内偏移~0</code></li></ul><p><strong>有效内存访问时间：</strong>（对一级页表）<br>$$<br>EAT=(单次内存访问时间+TLB 查询时间)\times TLB 命中率+(2\times 单次内存访问时间+TLB 查询时间)\times(1-TLB 命中率)<br>$$</p><h2 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h2><p>逻辑地址：把相对地址分为页号和页内地址两部分。<br>页表定位：页表始址＋页号 x 页表项长度。<br>查询页表：读出块号。<br>物理地址：块号＋块内地址。（块内地址＝页内地址）</p><h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><p>由于一级页表在划分页面数很多时会导致页表项很多，占用内存多，因此需要多级页表来实现页表分级，从而实现动态调入页表。</p><h3 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h3><p>将页表再进行分页，离散地将各个页表页面存放在不同的物理块中，同时再建立一张外部页表（即<strong>页目录</strong>）用于记录页表页面对应的物理块号。<br>正在运行的进程需要把页目录调入内存，然后将当前所需的二级页表调入内存，其余二级页表待需要时再调入。</p><h2 id="快表-TLB"><a href="#快表-TLB" class="headerlink" title="快表 TLB"></a>快表 TLB</h2><p>页表机制导致内存访问效率下降。不分页时获取数据只需访存 1 次，而一级页表需要访存 2 次，二级页表需要访存 3 次。</p><p>快表是一种特殊的高速缓冲存储器（Cache），内容是页表中的一部分或全部内容。CPU 产生逻辑地址的页号，首先在快表中寻找，若命中就找出其对应的物理块；若未命中，再到页表中找其对应的物理块，并将相应的页表项复制到快表。若快表中内容满，则按某种算法淘汰某些页。</p><p><img src="https://img.imgdb.cn/item/60911bffd1a9ae528ffe47d1.png"></p><h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><ul><li>有的 TLB 在每个 TLB 表项中还保存有 ASID（ASID 可用来唯一标识进程），这样 TLB 就可以同时包含多个进程的条目。否则每当进程切换时，TLB 就需要被 flushed，因为不同的进程虚拟地址空间相同，不冲刷可能会导致解析为其他进程的虚拟页。</li></ul><h2 id="页目录自映射"><a href="#页目录自映射" class="headerlink" title="页目录自映射"></a>页目录自映射</h2><h2 id="哈希页表"><a href="#哈希页表" class="headerlink" title="哈希页表"></a>哈希页表</h2><h2 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h2><h2 id="页共享与保护"><a href="#页共享与保护" class="headerlink" title="页共享与保护"></a>页共享与保护</h2><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>各进程把需要共享的数据/程序的相应页指向相同物理块<br>但如果共享数据与不共享数据在同一块中，不易保密。而事实上也很难只把共享数据与非共享数据隔离，因为”数据共享”是程序处理逻辑层面的需求。</p><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><ul><li>地址越界保护 </li><li>在页表中设置保护位（定义操作权限：只读、读写、执行等）</li></ul><h1 id="段式内存管理"><a href="#段式内存管理" class="headerlink" title="段式内存管理"></a>段式内存管理</h1><p>一个段可定义为一组逻辑信息，每个作业的地址空间是由一些分段构成的。每个段都有自己的段名（一般为段号）且是一段连续的地址空间，其大小不定。</p><p><strong>段表：</strong>保存在内存中，记录了段与内存位置的对应关系。</p><p><strong>地址结构：</strong>逻辑地址由段和段内地址组成。</p><h2 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h2><p>多用户同时使用一个程序时，我们可以将代码共享而将数据分别保存，这要求代码是可重入的。<br><strong>可重入代码：</strong>也称纯代码，是指在多次并发调用时能安全运行的代码。(不能使用全局/静态变量，不能修改代码本身，不能调用其他不可重入代码）</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li>段是逻辑单位，易于实现信息共享与保护</li><li>能够更好的支持动态的内存需求（如编译器、动态链接）<br>缺点：</li><li>辅存中管理不定长度的分段比较困难<h2 id="地址空间的一维与二维"><a href="#地址空间的一维与二维" class="headerlink" title="地址空间的一维与二维"></a>地址空间的一维与二维</h2></li></ul><p>段式存储管理的作业地址空间是二维的，页式存储管理的作业地址空间是一维的。</p><p>因为段号是程序员自己定义的，要想找到某个数据或指令，需要指定段号和位移两个变量，因此是二维的。而页号是系统自动生成的，本身地址是线性连续的，当要访问特定地址时，只需要提供地址即可。系统会自动将地址划分为页号和页内位移，页号对于程序员来说是没有实际意义的，因此是一维的。</p><h1 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h1><p>将用户程序分为若干段，再将每个段分成若干页。</p><p><strong>地址结构：</strong>段号+段内页号+页内偏移量。因此访问一次数据或指令需访问内存 3 次。</p><h2 id="段表与页表"><a href="#段表与页表" class="headerlink" title="段表与页表"></a>段表与页表</h2><p>每个进程有一张段表，每个段有一张页表。<br>段表包含段号、页表始址和页表长度（每个段的页面数不同）。页表包含页号和页框号。</p><h2 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h2><ul><li>首先从 PCB 中取出段表始址和段表长度，装入段表寄存器。</li><li>利用段表始址与段号得到该段表项在段表中的位置，取出该段的页表始址和页表长度</li><li>利用页表始址和页号得到该页表项在页表中的位置。</li><li>取出该页的物理块号，与页内地址拼接得到物理地址<br>（段表长度和页表长度用于发现并产生越界中断）<h2 id="Intel-X86"><a href="#Intel-X86" class="headerlink" title="Intel X86"></a>Intel X86</h2>X86 的地址映射机制分为：</li><li>段映射机制：将逻辑地址映射到线性地址</li><li>页映射机制：将先行地址映射到物理地址</li></ul><h1 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h1><p>覆盖与交换技术虽部分解决了扩大存储空间的问题，但引入了很多额外的开销。引起这些问题的主要原因是一个作业必须存放在一个连续的内存中。</p><p>虚拟内存是计算机系统存储管理的一种技术，它为每个进程提供了一个一致的、连续完整的私有地址空间。采用虚拟存储技术的操作系统只需将当前所需执行的部分页或段读入内存，将内存与外存统一管理，达到扩充内存的目的。局部性原理使得这一技术有了良好的支撑。</p><h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="进程的逻辑空间"><a href="#进程的逻辑空间" class="headerlink" title="进程的逻辑空间"></a>进程的逻辑空间</h3><p>一个进程的逻辑空间的建立是通过链接器（Linker），将构成进程所需要的所有程序及运行所需环境，按照某种规则装配链接而形成的一种规范格式（布局），按字节从0开始编址。也称为进程的虚拟地址空间。</p><h3 id="交换分区"><a href="#交换分区" class="headerlink" title="交换分区"></a>交换分区</h3><p>交换分区是一段连续的磁盘空间（按页划分的），对用户不可见。它的功能是在物理内存不够的情况下，操作系统把内存中暂时不用的数据，存到硬盘的交换空间，留出物理内存让别的程序运行。<br>在 Linux系统中，交换分区为<code>Swap</code>；在 Windows系统中则以文件的形式存在（<code>pagefile.sys</code>）</p><h2 id="虚拟页式存储管理"><a href="#虚拟页式存储管理" class="headerlink" title="虚拟页式存储管理"></a>虚拟页式存储管理</h2><p>需要在页表中增加：驻留位（标识该页在内存中还是外存中）、外存地址。</p><h3 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h3><p>若从页表中查出该页的信息不在主存而在磁盘上时，发生缺页中断。缺页中断流程如下：</p><ol><li>现场保护：陷入内核态，保存必要的信息（OS及用户进程状态相关的信息）</li><li>页面定位：查找出发生缺页中断的虚拟页面（进程地址空间中的页面）。这个虚拟页面的信息通常会保存在一个硬件寄存器中，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析该指令，通过分析找出发生页面中断的虚拟页面。</li><li>权限检查：检查虚拟地址的有效性及安全保护位。如果发生保护错误，则杀死该进程</li><li>新页面调入 1 ：查找一个空闲的页框（物理内存中的页面），如果没有空闲页框则需要通过页面置换算法找到一个需要换出的页框</li><li>旧页面写回：如果找到的页框中的内容被修改了，则需要将修改的内容保存到磁盘上。（注：此时需要将页框置为忙状态，以防页框被其它进程抢占掉）</li><li>新页面调入 2 ：页框“干净”后，操作系统将保持在磁盘上的页面内容复制到该页框中</li><li>更新页表：当磁盘中的页面内容全部装入页框后，向CPU发送一个中断。操作系统更新内存中的页表项，将虚拟页面映的页框号更新为写入的页框，并将页框标记为正常状态</li><li>恢复现场：恢复缺页中断发生前的状态，将 PC 重新指向引起缺页中断的指令，继续执行</li></ol><p><img src="https://pic.imgdb.cn/item/60bf414f844ef46bb2952b0b.png"></p><h3 id="页面调度策略"><a href="#页面调度策略" class="headerlink" title="页面调度策略"></a>页面调度策略</h3><p>虚拟存储器系统通常定义三种策略来规定如何进行页面调度：调入策略、置页策略和置换策略。</p><h4 id="调入策略"><a href="#调入策略" class="headerlink" title="调入策略"></a>调入策略</h4><p>调入策略决定什么时候将一个页由外存调入内存之中。</p><h5 id="请求调页（demand-paging）"><a href="#请求调页（demand-paging）" class="headerlink" title="请求调页（demand paging）"></a>请求调页（demand paging）</h5><p>只调入发生缺页时所需的页面。这种调入策略实现简单，但容易产生较多的缺页中断，造成对外存I/O次数多，时间开销过大，容易产生抖动现象。</p><h5 id="预调页（prepaging）"><a href="#预调页（prepaging）" class="headerlink" title="预调页（prepaging）"></a>预调页（prepaging）</h5><p>在发生缺页需要调入某页时，一次调入该页以及相邻的几个页。这种策略提高了调页的I/O效率，减少了I/O次数。但由于这是一种基于局部性原理的预测，若调入的页在以后很少被访问，则造成浪费。这种方式常在程序装入时使用。</p><h4 id="置页策略"><a href="#置页策略" class="headerlink" title="置页策略"></a>置页策略</h4><p>当线程产生缺页中断时，内存管理器还必须确定将调入的虚拟页放在物理内存的何处。用于确定最佳位置的一组规则称为“<strong>置页策略</strong>”。<br>选择页框应使CPU内存高速缓存不必要的震荡最小。</p><h4 id="置换策略"><a href="#置换策略" class="headerlink" title="置换策略"></a>置换策略</h4><p>如果缺页中断发生时物理内存已满，“置换策略”被用于确定哪个虚页面必须从内存中移出，为新的页面腾出空位，即调整驻留集的大小。</p><h5 id="固定分配局部置换"><a href="#固定分配局部置换" class="headerlink" title="固定分配局部置换"></a>固定分配局部置换</h5><p>为每一进程分配固定的页数的内存空间，在整个运行期间都不再改变。如果进程在运行中出现缺页，则只能从该进程的N个页面中选出一个换出，再调入一页，以保证分配给该进程的内存空间不变。</p><h5 id="可变分配全局置换"><a href="#可变分配全局置换" class="headerlink" title="可变分配全局置换"></a>可变分配全局置换</h5><p>先为系统中的每一进程分配一定数量的物理块，操作系统本身也保持一个空闲物理块队列。当某进程发生缺页时，由系统的空闲物理块队列中取出一物理块分配给该进程。但当空闲物理块队列中的物理块用完时，操作系统才从内存中选择一块调出。该块可能是系统中任意一个进程的页。</p><h5 id="可变分配局部置换"><a href="#可变分配局部置换" class="headerlink" title="可变分配局部置换"></a>可变分配局部置换</h5><p>为每一进程分配一定数目的内存空间。如果进程在运行的过程中，频繁地发生缺页中断，则系统再为该进程分配若干物理块，直到进程的缺页率降低到适当程度为止。</p><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>当主存空间已被装满而又需调入新页，就需要根据算法将已在主存中的一些页淘汰</p><ul><li>最优置换 OPT</li></ul><p>置换掉未来最久不被使用的页。但它需要页面访问序列的先验知识，是无法实现的。通常用于比较性研究。</p><ul><li>先进先出 FIFO</li></ul><p>置换最久的页。性能差，可能会出现 Belady 异常。<br>注：Belady 异常：随着分配的页框增多，缺页率反而上升。</p><ul><li>second chance</li></ul><p>如果被淘汰的页之前被访问过，则给其第二次机会。每个页面会增加一个访问标志位，用于标识此数据装入内存后是否被再次访问过。</p><ul><li> clock</li></ul><p>改进的 second chance。将数据组织成环形队列。</p><p>1）如果没有缺页错误，将所访问页的访问位置1，指针不动；</p><p>2）如果产生缺页错误：</p><p>如果当前页面的访问位是 1 ，首先将当前页面的访问位置0，将指针向前移一个位置；重复这个过程，直到找到访问位为0的页面，然后转下一步。</p><p>如果当前页面的访问位是 0 ，替换当前页面，并将其访问位置为1，并将指针向前移动一个位置。</p><h4 id="页面清除策略"><a href="#页面清除策略" class="headerlink" title="页面清除策略"></a>页面清除策略</h4><p>页面清除策略决定系统何时把被置换页面写回外存。<br>当正在执行的进程发生缺页中断时，需要阻塞，并等待一个页面的写出和另一个页面的读入，这可能降低处理机的使用效率。<br>一种有效的页面清除策略是结合<strong>页缓冲</strong>（<code>Page Buffering</code>）技术。当发生缺页中断时，不必首先写出置换页，而是将被选中的置换页暂时保留在内存的一个缓冲区，在以后某个合适的时候将被置换页批量写出到外存，减少磁盘I/0的次数，提高处理机的效率。</p><h5 id="最近最少使用-LRU"><a href="#最近最少使用-LRU" class="headerlink" title="最近最少使用 LRU"></a>最近最少使用 LRU</h5><p>是局部性原理的合理近似，性能接近 OPT，但需要记录页面使用的先后关系，实现开销大。</p><h5 id="工作集算法"><a href="#工作集算法" class="headerlink" title="工作集算法"></a>工作集算法</h5><p><strong>工作集</strong>：进程运行正在使用的页面的集合。它会逐渐稳定。</p><p><strong>驻留集</strong>：每个进程驻留在内存的页面集合。</p><p>本算法选择不在工作集中的页面进行替换。</p><h3 id="抖动问题"><a href="#抖动问题" class="headerlink" title="抖动问题"></a>抖动问题</h3><p>随着驻留内存的进程数目增加，即进程并发程度的提高，处理器利用率先上升，然后下降。<br>这里下降的原因通常称为虚拟存储器发生“抖动”，每个进程的驻留集不断减小，当驻留集小于工作集后，缺页率急剧上升，频繁调页使得调页开销增大。<br>因此，OS要选择一个适当的进程数目，以在并发水平和缺页率之间达到一个平衡。</p><h4 id="抖动的消除与预防"><a href="#抖动的消除与预防" class="headerlink" title="抖动的消除与预防"></a>抖动的消除与预防</h4><p><strong>局部置换策略：</strong>如果一个进程出现抖动，它不能从另外的进程那里夺取内存块，从而不会引发其他进程出现抖动，使抖动局限于一个小的范围内</p><p><strong>挂起若干进程：</strong>挂起一个或几个进程，以便腾出内存空间供抖动进程使用，从而消除抖动现象</p><p><strong>引入工作集算法</strong></p><p><strong>预留部分页面</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;地址空间&lt;/strong&gt;：一个进程能够用于访问内存的地址集合&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序&lt;/str</summary>
      
    
    
    
    <category term="OperatingSystem" scheme="http://yoursite.com/categories/OperatingSystem/"/>
    
    
    <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>「C++ 基础」类 &amp; 对象</title>
    <link href="http://yoursite.com/2021/05/01/cpp/1%20-%20%E7%B1%BB%20&amp;%20%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2021/05/01/cpp/1%20-%20%E7%B1%BB%20&amp;%20%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-05-01T01:00:15.000Z</published>
    <updated>2021-05-26T15:40:00.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类-amp-对象"><a href="#类-amp-对象" class="headerlink" title="类 &amp; 对象"></a>类 &amp; 对象</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><table><thead><tr><th align="left">概念</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">类成员函数</td><td align="left">类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。</td></tr><tr><td align="left">类访问修饰符</td><td align="left">类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。</td></tr><tr><td align="left">构造函数 &amp; 析构函数</td><td align="left">类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。</td></tr><tr><td align="left">C++ 拷贝构造函数</td><td align="left">拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。</td></tr><tr><td align="left">C++ 友元函数</td><td align="left"><strong>友元函数</strong>可以访问类的 private 和 protected 成员。</td></tr><tr><td align="left">C++ 内联函数</td><td align="left">通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。</td></tr><tr><td align="left">C++ 中的 this 指针</td><td align="left">每个对象都有一个特殊的指针 <strong>this</strong>，它指向对象本身。</td></tr><tr><td align="left">C++ 中指向类的指针</td><td align="left">指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。</td></tr><tr><td align="left">C++ 类的静态成员</td><td align="left">类的数据成员和函数成员都可以被声明为静态的。</td></tr></tbody></table><h2 id="与-struct-区别"><a href="#与-struct-区别" class="headerlink" title="与 struct 区别"></a>与 struct 区别</h2><ol><li>成员的默认访问权限不同 ：class 默认 private，struct 默认 public</li><li>class 可以用在模板中代替 typename，struct 不能。</li></ol><p>可以看到区别很小 ，c++保留 struct 更多是为了兼容 C。但是语义上一般倾向于把struct当作C时代的struct来用，即只有成员变量，没有逻辑（或只有极其简单的数据存入读取逻辑），用来把多个变量打包成一个类型，而不用struct来做面向对象编程意义上的class。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。</p><h2 id="类成员函数"><a href="#类成员函数" class="headerlink" title="类成员函数"></a>类成员函数</h2><p>成员函数可以定义在类定义内部，或者单独使用<strong>范围解析运算符</strong><code>::</code>来定义。在类定义中定义的成员函数把函数声明为内联的，即便没有使用 inline 标识符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="comment">//  ...</span></span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以在类的外部使用范围解析运算符<code>::</code>定义该函数，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">double</span> length;         <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;        <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> height;         <span class="comment">// 高度</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 成员函数声明</span></span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 成员函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Box::getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类访问修饰符"><a href="#类访问修饰符" class="headerlink" title="类访问修饰符"></a>类访问修饰符</h2><p>数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记 <strong>public、private、protected</strong> 来指定的。</p><p>每个标记区域在下一个标记区域开始之前都是有效的。成员和类的默认访问修饰符是 private。</p><h3 id="公有成员"><a href="#公有成员" class="headerlink" title="公有成员"></a>公有成员</h3><p><strong>公有</strong>成员在类的外部可访问。</p><h3 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h3><p><strong>私有</strong>成员变量或函数在类的外部不可访问，只有类和友元函数可以访问私有成员。 </p><h3 id="保护成员"><a href="#保护成员" class="headerlink" title="保护成员"></a>保护成员</h3><p><strong>保护</strong>成员变量或函数可被派生类中的任何成员函数访问。除此外和私有成员相同。</p><h2 id="类构造函数-amp-析构函数"><a href="#类构造函数-amp-析构函数" class="headerlink" title="类构造函数 &amp; 析构函数"></a>类构造函数 &amp; 析构函数</h2><p>类的<strong>构造函数</strong>是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。</p><p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">( <span class="keyword">double</span> len )</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">      <span class="built_in">Line</span>(<span class="keyword">double</span> len);  <span class="comment">// 这是构造函数</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Line::<span class="built_in">Line</span>( <span class="keyword">double</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Line <span class="title">line</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用初始化列表来初始化字段"><a href="#使用初始化列表来初始化字段" class="headerlink" title="使用初始化列表来初始化字段"></a>使用初始化列表来初始化字段</h3><p>假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化 ，可以：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C::<span class="built_in">C</span>( <span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c): <span class="built_in">X</span>(a), <span class="built_in">Y</span>(b), <span class="built_in">Z</span>(c)<span class="comment">// 最好要按照变量在类声明的顺序一致</span></span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复制控制"><a href="#复制控制" class="headerlink" title="复制控制"></a>复制控制</h2><p>除了成员函数、构造函数定义了类型的对象的操作，类还可以通过特殊的成员函数（复制构造函数、赋值操作符、析构函数）来控制<strong>复制</strong>、<strong>赋值</strong>或<strong>撤销</strong>该类型对象时会发生什么。</p><h3 id="类的析构函数"><a href="#类的析构函数" class="headerlink" title="类的析构函数"></a>类的析构函数</h3><p>类的<strong>析构函数</strong>会在每次删除所创建的对象时执行。当对象的引用或指针超出作用域时，不会运行析构函数。只有删除指向动态分配对象的指针或实际对象超出作用域时，才会执行析构函数。</p><p>一般而言，如果需要析构函数，那么也需要赋值操作符和复制构造函数。</p><p>析构函数的名称与类的名称相同，在前面加<code>~</code>作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">( <span class="keyword">double</span> len )</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">      <span class="built_in">Line</span>();   <span class="comment">// 这是构造函数声明</span></span><br><span class="line">      ~<span class="built_in">Line</span>();  <span class="comment">// 这是析构函数声明</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;</span><br><span class="line">&#125;;</span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being created&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Line::~<span class="built_in">Line</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>拷贝构造函数通常用于： </p><ul><li>通过使用另一个同类型的对象来初始化新创建的对象。</li><li>复制对象把它作为参数传递给函数。</li><li>复制对象，并从函数返回这个对象。</li></ul><p>编译器会默认定义拷贝构造函数。如果类带有指针变量，或者有动态内存分配，则它必须有一个拷贝构造函数。</p><p>因为默认的拷贝构造函数实现的是浅拷贝，即直接将原对象的数据成员值依次复制给新对象中对应的数据成员，并没有为新对象另外分配内存资源。这样，如果对象的数据成员是指针，两个指针对象实际上指向的是同一块内存空间，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。</p><p>所以我们就必须定义一个深拷贝构造函数，为新的对象分配单独的内存资源。</p><p>拷贝构造函数的最常见形式如下： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">classname</span> (<span class="keyword">const</span> classname &amp;obj) &#123;<span class="comment">// obj 是一个对象引用，该对象是用于初始化另一个对象的。</span></span><br><span class="line">   <span class="comment">// 构造函数的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        a = b;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;creat: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">const</span> CExample &amp;C)</span><br><span class="line">    &#123;</span><br><span class="line">        a = C.a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">CExample</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;delete: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数，传入的是对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_Fun</span><span class="params">(CExample C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CExample <span class="title">test</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//传入对象</span></span><br><span class="line">    <span class="built_in">g_Fun</span>(test);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何防止默认拷贝发生</strong></p><p>声明一个私有的拷贝构造函数，这样因为拷贝构造函数是私有的，如果用户试图按值传递或函数返回该类的对象，编译器会报告错误，从而可以避免按值传递或返回对象。</p><p>当出现类的等号赋值时，会调用拷贝函数</p><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>友元机制允许一个类将对其非公有成员的访问权授予指定函数或类。友元不是授予友元关系那个类的成员，所以它们不受其声明出现部分的访问控制影响。</p><p>友元可以是一个函数，该函数被称为友元函数；也可以是一个类，称为友元类，在这种情况下，整个类及其所有成员都是友元。</p><p>如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 <strong>friend</strong></p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> width;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printWidth</span><span class="params">(Box box)</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BigBox</span>;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">double</span> wid)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigBox</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> width, Box &amp;box)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// BigBox是Box的友元类，它可以直接访问Box类的任何成员</span></span><br><span class="line">        box.<span class="built_in">setWidth</span>(width);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注意：printWidth() 不是任何类的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printWidth</span><span class="params">(Box box)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Box box;</span><br><span class="line">    BigBox big;</span><br><span class="line">    <span class="comment">// 使用成员函数设置宽度</span></span><br><span class="line">    box.<span class="built_in">setWidth</span>(<span class="number">10.0</span>);</span><br><span class="line">    <span class="comment">// 使用友元函数输出宽度</span></span><br><span class="line">    <span class="built_in">printWidth</span>(box);</span><br><span class="line">    <span class="comment">// 使用友元类中的方法设置宽度</span></span><br><span class="line">    big.<span class="built_in">Print</span>(<span class="number">20</span>, box);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>友元声明将已命名的类或非成员函数引入外围作用域中。此外友元函数可以在类内部定义，该函数的作用域扩展到包围该类定义的作用域。</p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>由于一般调用函数需要许多工作：保存寄存器，复制实参，跳转到入口地址，返回时恢复寄存器等等。</p><p>内联函数可以避免函数调用时的开销。在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。函数名前面放置关键字 <strong>inline</strong>就可定义为内联函数。</p><p>对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。</p><p>一般而言，内联机制适用于优化比较小的、经常被调用的函数。绝大多数编译器不支持递归函数的内联。</p><p>在类定义中的定义的函数都是内联函数。</p><h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><p>每一个对象都能通过 <strong>this</strong> 指针来访问自己的地址。<strong>this</strong> 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">Volume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(Box box)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">Volume</span>() &gt; box.<span class="built_in">Volume</span>();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="指向类的指针"><a href="#指向类的指针" class="headerlink" title="指向类的指针"></a>指向类的指针</h2><p>一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 **<code>-&gt;</code>**，就像访问指向结构的指针一样。与所有的指针一样，必须在使用指针之前对指针进行初始化。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Box <span class="title">Box1</span><span class="params">(<span class="number">3.3</span>, <span class="number">1.2</span>, <span class="number">1.5</span>)</span></span>;    <span class="comment">// Declare box1</span></span><br><span class="line">   Box *ptrBox;                <span class="comment">// Declare pointer to a class.</span></span><br><span class="line">   ptrBox = &amp;Box1;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Volume of Box1: &quot;</span> &lt;&lt; ptrBox-&gt;<span class="built_in">Volume</span>() &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 <strong>::</strong> 来重新声明静态变量从而对它进行初始化 </p><p>静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义，实际上是给静态成员变量分配内存。如果不加定义就会报错，初始化是赋一个初始值，而定义是分配内存。 </p><ul><li>常量变量：必须通过构造函数参数列表进行初始化。</li><li>引用变量：必须通过构造函数参数列表进行初始化。</li><li>普通静态变量：要在类外通过”::”初始化。</li><li>静态整型常量：可以直接在定义的时候初始化。</li><li>静态非整型常量：不能直接在定义的时候初始化。要在类外通过”::”初始化。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span> objectCount;</span><br><span class="line">      <span class="built_in">Box</span>(<span class="keyword">double</span> l=<span class="number">2.0</span>, <span class="keyword">double</span> b=<span class="number">2.0</span>, <span class="keyword">double</span> h=<span class="number">2.0</span>) &#123;</span><br><span class="line">         objectCount++;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Box::objectCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，<strong>静态函数</strong>只要使用类名加范围解析运算符 <code>::</code> 就可以访问。 </p><p>静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。 </p><p>静态成员函数有一个类范围，他们不能访问类的 this 指针。可以使用静态成员函数来判断类的某些对象是否已被创建。 </p><p><strong>静态成员函数与普通成员函数的区别：</strong></p><ul><li>静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</li><li>普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类-amp-对象&quot;&gt;&lt;a href=&quot;#类-amp-对象&quot; class=&quot;headerlink&quot; title=&quot;类 &amp;amp; 对象&quot;&gt;&lt;/a&gt;类 &amp;amp; 对象&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="C++ 基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
    <category term="OOP" scheme="http://yoursite.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>「Algorithmic questions」动态规划</title>
    <link href="http://yoursite.com/2021/04/26/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E3%80%8CAlgorithmic%20questions%E3%80%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2021/04/26/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E3%80%8CAlgorithmic%20questions%E3%80%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-04-26T04:22:16.000Z</published>
    <updated>2021-06-17T16:15:11.103Z</updated>
    
    <content type="html"><![CDATA[<p>开个坑。感觉算法题还是要经常练保持手感，前段时间蓝桥杯，感觉大一时洛谷那么多题白刷了，那么多算法模板白总结了，都忘完了。做算法题还是要尽量自己多想，不思考看题解忘得太快。虽然最近比较忙，但每两天做一点应该还是可以的（吧）。希望不咕。</p><h1 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h1><h2 id="T198-House-Robber"><a href="#T198-House-Robber" class="headerlink" title="T198. House Robber"></a>T198. House Robber</h2><blockquote><p>假如你是一个劫匪，并且决定抢劫一条街上的房子，每个房子内的钱财数量各不相同。如果 你抢了两栋相邻的房子，则会触发警报机关。求在不触发机关的情况下最多可以抢劫多少钱。</p></blockquote><p>输入是一个一维数组，表示每个房子的钱财数量；输出是劫匪可以最多抢劫的钱财数量。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>很基础的dp，<code>dp[i]</code>表示前<code>i</code>个房子劫匪最多抢劫的数量，那么它有两种情况组成：一种是我们选择不抢劫这个房子，此时累计的金额即为 <code>dp[i-1]</code>；另一种是我们选择抢劫这个房子，那么此前累计的最大金额只能是 <code>dp[i-2]</code>。因此本题的状态转移方程为 <code>dp[i] = max(dp[i-1], nums[i-1] + dp[i-2])</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = nums.<span class="built_in">size</span>(); </span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-2</span>]+nums[i<span class="number">-1</span>], dp[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>当然由于递推到<code>dp[i]</code>时，本数组此前有用的值只有<code>dp[i-1]</code>与<code>dp[i-2]</code>，所以可以简单状态压缩：用三个变量来代替这三个数，节省空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(); </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">int</span> pre2 = <span class="number">0</span>, pre1 = <span class="number">0</span>, cur; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; </span><br><span class="line">        cur = <span class="built_in">max</span>(pre2 + nums[i], pre1); pre2 = pre1; pre1 = cur;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> cur; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T413-Arithmetic-Slices"><a href="#T413-Arithmetic-Slices" class="headerlink" title="T413. Arithmetic Slices"></a>T413. Arithmetic Slices</h2><blockquote><p>给定一个数组，求这个数组中连续且等差的子数组一共有多少个。</p></blockquote><p>输入是一个一维数组，输出是满足等差条件的连续字数组个数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4] </span><br><span class="line">Output: 3  &#x2F;&#x2F; 等差数列有 [1,2,3]、[2,3,4] 和 [1,2,3,4]</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>对于<code>[1,2,3,4]</code>，在尾部加一个5，那么原来以4结尾的等差数列，增加了一个元素，它们的数量不变。但同时会形成一个新的数列<code>[3,4,5]</code>。因此设<code>dp[i]</code>表示<strong>以<code>nums[i]</code>结尾的等差数列</strong>的个数。</p><p>递推关系：如果<code>A[i]-A[i-1] = A[i-1]-A[i-2]</code>，则<code>dp[i]=1+dp[i-1]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]-nums[i<span class="number">-1</span>] == nums[i<span class="number">-1</span>]-nums[i<span class="number">-2</span>]) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        ans += dp[i];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h1><h2 id="T64-Minimum-Path-Sum"><a href="#T64-Minimum-Path-Sum" class="headerlink" title="T64. Minimum Path Sum"></a>T64. Minimum Path Sum</h2><blockquote><p>给定一个m × n 大小的非负整数矩阵，求从左上角开始到右下角结束的、经过的数字的和最小的路径。每次只能向右或者向下移动。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3,1], [1,5,1], [4,2,1]] </span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>很基础的二维dp，思路很好想：<code>dp[i][j]</code>表示左上角开始到<code>(i,j)</code>处最小路径的数字和。那么状态转移方程为：</p><p><code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</code>。当然边界要特判一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">dp</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j] + grid[i][j], dp[i][j - <span class="number">1</span>] + grid[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间压缩：因为 dp 数组的值由左边和上边转移而来，对于第 i 行，在遍历到第 j 列的时候，因为第j-1列已经更新过了，所以<code>dp[j-1]</code>代表<code>dp[i][j-1] </code>的值；而 <code>dp[j]</code> 还未更新，此时的值是在第 i-1 行的时候计算的，因此可以代表 <code>dp[i-1][j]</code> 的值。这样就把dp数组压成一维的了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = grid[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = dp[j - <span class="number">1</span>] + grid[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = dp[j] + grid[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T542-01-Matrix"><a href="#T542-01-Matrix" class="headerlink" title="T542. 01 Matrix"></a>T542. 01 Matrix</h2><blockquote><p>给定一个由 0 和 1 组成的二维矩阵，求每个位置到最近的 0 的距离</p></blockquote><p>和上一题主要的区别在于本次矩阵需要四个方向的搜索，我们就不能简单由上方和左方矩阵转移而来。我们可以从左上到右下进行一次 dp ，再从右下到左上进行一次 dp 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3fffffff</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = INF;<span class="comment">// 注意 inf 的设置</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里开始不一样，需要和之前dp所得的成果相比，取最小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp; j == m - <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(INF, dp[i][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == m - <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], <span class="built_in">min</span>(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T221-Maximal-Square"><a href="#T221-Maximal-Square" class="headerlink" title="T221. Maximal Square"></a>T221. Maximal Square</h2><blockquote><p>给定一个二维的 0-1 矩阵，求全由 1 构成的最大正方形面积。</p></blockquote><h3 id="悬线法"><a href="#悬线法" class="headerlink" title="悬线法"></a>悬线法</h3><p>悬线法常用来求解这种给定矩阵中满足条件的最大子矩阵。</p><p>首先我们用<code>left[i][j]</code>表示从<code>(i,j)</code>能到达的最左位置，用<code>right[i][j]</code>表示从<code>(i,j)</code>能到达的最右位置，用<code>up[i][j]</code>表示从<code>(i,j)</code>向上扩展的最长长度。</p><p>那么这道题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(vector &lt;vector&lt;<span class="keyword">char</span>&gt;&gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">left</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">right</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">up</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="comment">// 能到达的最右和最左都初始化为自己开始的横坐标</span></span><br><span class="line">            left[i][j] = j;</span><br><span class="line">            right[i][j] = j;</span><br><span class="line">            up[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;<span class="comment">// 注意 j 是最作坊元素的右边元素位置，因为要递推</span></span><br><span class="line">            <span class="keyword">if</span> ((matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &amp;&amp; (matrix[i][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)) &#123;</span><br><span class="line">                left[i][j] = left[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123;<span class="comment">// 这里 j 类似</span></span><br><span class="line">            <span class="keyword">if</span> ((matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &amp;&amp; (matrix[i][j + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)) &#123;</span><br><span class="line">                right[i][j] = right[i][j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &amp;&amp; (matrix[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>)) &#123; <span class="comment">// i类似</span></span><br><span class="line">                left[i][j] = <span class="built_in">max</span>(left[i][j], left[i - <span class="number">1</span>][j]); </span><br><span class="line">                <span class="comment">// 上下的left取最靠右的，确保满足</span></span><br><span class="line">                right[i][j] = <span class="built_in">min</span>(right[i][j], right[i - <span class="number">1</span>][j]);</span><br><span class="line">                up[i][j] = up[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = right[i][j] - left[i][j] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> height = <span class="built_in">min</span>(len, up[i][j]);</span><br><span class="line">                area = <span class="built_in">max</span>(area, height * height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常规的-dp-转移"><a href="#常规的-dp-转移" class="headerlink" title="常规的 dp 转移"></a>常规的 dp 转移</h3><p><code>dp[i][j] </code>表示满足题目条件的、以 <code>(i, j)</code> 为右下角的正方形或者长方形的属性。对于本题，则表示以 <code>(i, j)</code> 为右下角的全由 1 构成的最大正方形边长。如果当前位置是 0，那么 <code>dp[i][j]</code> 即为 0；如果当前位置是 1，我们假设 $dp[i][j]=k$，其充分条件为 <code>dp[i-1][j-1]</code>、<code>dp[i][j-1]</code> 和 <code>dp[i-1][j]</code> 的值必须 都不小于$(k-1)$，否则 <code>(i, j)</code> 位置不可以构成一个边长为 k 的正方形。同理，如果这三个值中的 的最小值为 k − 1，则 <code>(i, j)</code> 位置一定且最大可以构成一个边长为 k 的正方形。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>(), max_side = <span class="number">0</span>; </span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>)); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123; </span><br><span class="line">            <span class="keyword">if</span> (matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123; </span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            max_side = <span class="built_in">max</span>(max_side, dp[i][j]); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> max_side * max_side;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h1><h2 id="T279-Perfect-Squares"><a href="#T279-Perfect-Squares" class="headerlink" title="T279. Perfect Squares"></a>T279. Perfect Squares</h2><blockquote><p>给定一个正整数，求其最少可以由几个完全平方数相加构成。</p></blockquote><p>dp[i] 表示数字 i 最少可以由几个完全平方数相加构成。那么它可以由 $i-k^2$的数加$k^2$得到，组成数+1。遍历一下可能的 k 即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT32_MAX)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开个坑。感觉算法题还是要经常练保持手感，前段时间蓝桥杯，感觉大一时洛谷那么多题白刷了，那么多算法模板白总结了，都忘完了。做算法题还是要尽量自己多想，不思考看题解忘得太快。虽然最近比较忙，但每两天做一点应该还是可以的（吧）。希望不咕。&lt;/p&gt;
&lt;h1 id=&quot;一维&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Algorithm problems" scheme="http://yoursite.com/categories/Algorithm-problems/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="algorithmic questions" scheme="http://yoursite.com/tags/algorithmic-questions/"/>
    
    <category term="dp" scheme="http://yoursite.com/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>「组合数学」母函数与递推关系</title>
    <link href="http://yoursite.com/2021/04/25/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88_%E6%AF%8D%E5%87%BD%E6%95%B0%E4%B8%8E%E9%80%92%E6%8E%A8/"/>
    <id>http://yoursite.com/2021/04/25/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88_%E6%AF%8D%E5%87%BD%E6%95%B0%E4%B8%8E%E9%80%92%E6%8E%A8/</id>
    <published>2021-04-25T01:00:15.000Z</published>
    <updated>2021-05-25T16:07:21.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用函数求解组合问题"><a href="#用函数求解组合问题" class="headerlink" title="用函数求解组合问题"></a>用函数求解组合问题</h2><p>r^x，代表取x个红球。现2个红球，1个白球，1个黄球</p><p><img src="https://i.loli.net/2021/05/25/UazGnT5OdRViZLE.png" alt="image.png"></p><p>只求组合数，不求具体组合，则可令 $r=w=y=x$，$1+3x+4x^2+3x^3+x^4$</p><p>即一个球的组合数为3，2个球组合数为4…</p><p><img src="https://i.loli.net/2021/05/26/XPWCkvGFLcr5hbH.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;用函数求解组合问题&quot;&gt;&lt;a href=&quot;#用函数求解组合问题&quot; class=&quot;headerlink&quot; title=&quot;用函数求解组合问题&quot;&gt;&lt;/a&gt;用函数求解组合问题&lt;/h2&gt;&lt;p&gt;r^x，代表取x个红球。现2个红球，1个白球，1个黄球&lt;/p&gt;
&lt;p&gt;&lt;img sr</summary>
      
    
    
    
    <category term="组合数学" scheme="http://yoursite.com/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>「OOP」设计模式</title>
    <link href="http://yoursite.com/2021/04/24/ObjectOriented/%E3%80%8COO%E3%80%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2021/04/24/ObjectOriented/%E3%80%8COO%E3%80%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-04-24T12:54:47.000Z</published>
    <updated>2021-05-21T03:12:19.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="肾莫是设计模式"><a href="#肾莫是设计模式" class="headerlink" title="肾莫是设计模式"></a>肾莫是设计模式</h2><p>设计模式（<code>Design pattern</code>）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 </p><p>软件模式是将模式的一般概念应用于软件开发领域，即软件开发的总体指导思路或参照样板。软件模式除了设计模式，还包括架构模式、分析模式和过程模式等。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><strong>创建型模式</strong></li></ul><p>对象实例化的模式，创建型模式用于解耦对象的实例化过程。</p><ul><li><strong>结构型模式</strong></li></ul><p>把类或对象结合在一起形成一个更大的结构。</p><ul><li><strong>行为型模式</strong></li></ul><p>类和对象如何交互，及划分责任和算法。以及对象之间的通信问题。</p><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote><p>确保某一个类只有一个实例，并且提供一个全局访问点。</p></blockquote><p>场景：一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li><strong>饿汉式</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较常用。它基于<code>classloader</code> 机制避免了多线程的同步问题，没有加锁，效率高。但类加载时就初始化，浪费内存。</p><ul><li><strong>双重校验锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用双锁机制，安全且在多线程情况下能保持高性能。</p><ul><li><strong>登记式/静态内部类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。</li><li>允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li></ul><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><blockquote><p>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，也就是说工厂方法模式让实例化推迟到子类。</p></blockquote><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Rectangle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Circle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;CIRCLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><blockquote><p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p></blockquote><p>通俗地讲，就是围绕一个抽象工厂创建具体工厂。这样创建的产品可以使多个维度的。这里以创建“形状”与“颜色”两个维度举例：</p><p>多个产品的接口及其实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shape接口、Rectangle类、Circle类同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 颜色接口及其实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Red::fill() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Green</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Green::fill() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提到的抽象工厂，只要负责定义多个维度的产品的创建接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Color <span class="title">getColor</span><span class="params">(String color)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂的具体实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ShapeFactory 同上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(color == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">&quot;RED&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Red();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">&quot;BLUE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Blue();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryProducer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">getFactory</span><span class="params">(String choice)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">&quot;SHAPE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">&quot;COLOR&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ColorFactory();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取形状工厂</span></span><br><span class="line">AbstractFactory shapeFactory = FactoryProducer.getFactory(<span class="string">&quot;SHAPE&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取形状为 Circle 的对象</span></span><br><span class="line">Shape shape1 = shapeFactory.getShape(<span class="string">&quot;CIRCLE&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</li><li>开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。</li></ul><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><blockquote><p>使用多个简单的对象一步一步构建成一个复杂的对象。将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p></blockquote><p><code>StringBuilder</code>就采用本模式实现。</p><p>本模式包含如下角色：</p><ul><li>Builder：抽象建造者</li><li>ConcreteBuilder：具体建造者，创建和提供实例</li><li>Director：指挥者，管理建造出来的实例的依赖关系</li><li>Product：产品角色</li></ul><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>建造者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPart1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPart2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPart3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的建造者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder1</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> StringBuffer buffer = <span class="keyword">new</span> StringBuffer();<span class="comment">//假设 buffer.toString() 就是最终生成的产品</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart1</span><span class="params">()</span> </span>&#123;<span class="comment">//实现构建最终实例需要的所有方法</span></span><br><span class="line">        buffer.append(<span class="string">&quot;Builder1 : Part1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        buffer.append(<span class="string">&quot;Builder1 : Part2\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        buffer.append(<span class="string">&quot;Builder1 : Part3\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;<span class="comment">//定义获取最终生成实例的方法</span></span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指挥者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;    <span class="comment">// 将一个复杂的构建过程与其表示相分离</span></span><br><span class="line">    <span class="keyword">private</span> Builder builder;    <span class="comment">// 针对接口编程，而不是针对实现编程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBuilder</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span> </span>&#123;   <span class="comment">// 控制（定义）一个复杂的构建过程</span></span><br><span class="line">        builder.buildPart1();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;   <span class="comment">// 提示：如果想在运行过程中替换构建算法，可以考虑结合策略模式。</span></span><br><span class="line">            builder.buildPart2();</span><br><span class="line">        &#125;</span><br><span class="line">        builder.buildPart3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>如果产品之间的差异性很大，则不适合使用建造者模式。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ul><h4 id="与抽象工厂模式对比"><a href="#与抽象工厂模式对比" class="headerlink" title="与抽象工厂模式对比"></a>与抽象工厂模式对比</h4><ul><li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。</li><li>如果将抽象工厂模式看成 汽车配件生产工厂 ，生产一个产品族的产品，那么建造者模式就是一个 汽车组装工厂 ，通过对部件的组装可以返回一辆完整的汽车。</li></ul><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="适配器模式（Adapter）"><a href="#适配器模式（Adapter）" class="headerlink" title="适配器模式（Adapter）"></a>适配器模式（Adapter）</h3><blockquote><p>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p></blockquote><p>我们可能需要将两个不同接口的类来进行通信，在不修改这两个的前提下，我们可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器。所谓适配器模式就是将一个类的接口，转换成客户期望的另一个接口。</p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>例：电脑只有读SD卡的接口，现在要读TF卡：</p><ol><li>先创建一个SD卡与TF卡的接口与其实现类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -- SD card -- */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SDCard</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">readSD</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">writeSD</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SDCardImpl</span> <span class="keyword">implements</span> <span class="title">SDCard</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String msg = <span class="string">&quot;sdcard read a msg :hello word SD&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writeSD</span><span class="params">(String msg)</span> </span>&#123;      </span><br><span class="line">        System.out.println(<span class="string">&quot;sd card write msg : &quot;</span> + msg);    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* -- TF card -- */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TFCard</span> </span>&#123;    </span><br><span class="line">    <span class="function">String <span class="title">readTF</span><span class="params">()</span></span>;    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">writeTF</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TFCardImpl</span> <span class="keyword">implements</span> <span class="title">TFCard</span> </span>&#123;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readTF</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        String msg =<span class="string">&quot;tf card reade msg : hello word tf card&quot;</span>;        </span><br><span class="line">        <span class="keyword">return</span> msg;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writeTF</span><span class="params">(String msg)</span> </span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;tf card write a msg : &quot;</span> + msg);        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建计算机接口与计算机实例，计算机提供读取SD卡方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;    </span><br><span class="line">    <span class="function">String <span class="title">readSD</span><span class="params">(SDCard sdCard)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThinkpadComputer</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">(SDCard sdCard)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span>(sdCard == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;sd card null&quot;</span>);        </span><br><span class="line">        <span class="keyword">return</span> sdCard.readSD();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们希望在不改变计算机读取SD卡接口的情况下，通过适配器模式读取TF卡：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* -- 创建SD适配TF （也可以说是SD兼容TF，相当于读卡器）：  -- */</span></span><br><span class="line"><span class="comment">// 实现SDCard接口，并将要适配的对象作为适配器的属性引入。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SDAdapterTF</span> <span class="keyword">implements</span> <span class="title">SDCard</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> TFCard tfCard;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SDAdapterTF</span><span class="params">(TFCard tfCard)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.tfCard = tfCard;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);        </span><br><span class="line">        <span class="keyword">return</span> tfCard.readTF();    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writeSD</span><span class="params">(String msg)</span> </span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);        </span><br><span class="line">        <span class="keyword">return</span> tfCard.writeTF(msg);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以读取TF卡：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerReadDemo</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">        Computer computer = <span class="keyword">new</span> ThinkpadComputer();            </span><br><span class="line">        TFCard tfCard = <span class="keyword">new</span> TFCardImpl();        </span><br><span class="line">        SDCard tfCardAdapterSD = <span class="keyword">new</span> SDAdapterTF(tfCard);        </span><br><span class="line">        System.out.println(computer.readSD(tfCardAdapterSD));    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合模式（Composite-）"><a href="#组合模式（Composite-）" class="headerlink" title="组合模式（Composite ）"></a>组合模式（Composite ）</h3><blockquote><p>将对象组合成树形结构以表示”部分-整体”的层次结构。</p></blockquote><p>看代码很容易理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String dept;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> salary;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Employee&gt; subordinates;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//构造函数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name,String dept, <span class="keyword">int</span> sal)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.dept = dept;</span><br><span class="line">      <span class="keyword">this</span>.salary = sal;</span><br><span class="line">      subordinates = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">      subordinates.add(e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="外观模式（Facade-）"><a href="#外观模式（Facade-）" class="headerlink" title="外观模式（Facade ）"></a>外观模式（Facade ）</h3><blockquote><p>外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面</p></blockquote><p>我们知道类与类之间的耦合越低，那么可复用性就越好，如果两个类不必彼此通信，那么就不要让这两个类发生直接的相互关系，如果需要调用里面的方法，可以通过第三者来转发调用。外观模式非常好的诠释了这段话。外观模式提供了一个统一的接口，用来访问子系统中的一群接口，实现了客户与子系统之间的松耦合。</p><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>电脑的外观：打开开关按钮，就可以开机（启动CPU，内存，硬盘…）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 电脑接口 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * CPU类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cpu</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;启动CPU&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * 内存类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ddr</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;启动内存&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * 硬盘类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ssd</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;启动硬盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** * 外观类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Computer cpu;</span><br><span class="line">    <span class="keyword">private</span> Computer ddr;</span><br><span class="line">    <span class="keyword">private</span> Computer ssd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Facade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cpu = <span class="keyword">new</span> Cpu();</span><br><span class="line">        ddr = <span class="keyword">new</span> Ddr();</span><br><span class="line">        ssd = <span class="keyword">new</span> Ssd();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 启动电脑 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cpu.open();</span><br><span class="line">        ddr.open();</span><br><span class="line">        ssd.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">        facade.onComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理模式（Proxy-）"><a href="#代理模式（Proxy-）" class="headerlink" title="代理模式（Proxy ）"></a>代理模式（Proxy ）</h3><blockquote><p>创建具有现有对象的对象，以便向外界提供功能接口。</p></blockquote><p>某些情况下，一个客户不想或不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul><li>Subject： 抽象主题角色</li><li>Proxy： 代理主题角色</li><li>RealSubject： 真实主题角色</li></ul><h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  RealSubject  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> String fileName;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RealImage</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">      loadFromDisk(fileName);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Displaying &quot;</span> + fileName);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Loading &quot;</span> + fileName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Proxy  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> RealImage realImage;</span><br><span class="line">   <span class="keyword">private</span> String fileName;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ProxyImage</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(realImage == <span class="keyword">null</span>)&#123;</span><br><span class="line">         realImage = <span class="keyword">new</span> RealImage(fileName);</span><br><span class="line">      &#125;</span><br><span class="line">      realImage.display();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Image image = <span class="keyword">new</span> ProxyImage(<span class="string">&quot;test_10mb.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图像将从磁盘加载</span></span><br><span class="line">    image.display(); </span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// 图像不需要从磁盘加载</span></span><br><span class="line">    image.display();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h4><p>根据代理模式的使用目的，常见的代理模式有以下几种类型：</p><ul><li>远程(Remote)代理：为一个位于不同的地址空间的对象提供一个本地 的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在 另一台主机中，远程代理又叫做大使(Ambassador)。</li><li>虚拟(Virtual)代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li><li>图片代理：一个很常见的代理模式的应用实例就是对大图浏览的控制。用户通过浏览器访问网页时先在代理对象的方法中，使用一个线程向客户端浏览器加载一个小图片，然后在后台使用另一个线程来调用大图加载方法将大图片加载到客户端。当需要浏览大图片时，再将大图片在新网页中显示。如果此时加载工作还没完成，可以再启动一个线程来显示相应的提示信息。通过代理技术结合多线程编程将真实图片的加载放到后台来操作，不影响前台图片的浏览。</li><li>动态代理：在事先不知道真实主题角色的情况下使用代理主题角色。</li></ul><p>对于动态代理，JDK有自带的包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Proxy: 生成动态代理类和对象；</span><br><span class="line">java.lang.reflect.InvocationHandler（处理器接口）：可以通过invoke方法实现</span><br></pre></td></tr></table></figure><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="职责链模式-Chain-of-Responsibility"><a href="#职责链模式-Chain-of-Responsibility" class="headerlink" title="职责链模式(Chain of Responsibility)"></a>职责链模式(Chain of Responsibility)</h3><blockquote><p>它将对象组成一条链，发送者将请求发给链的第一个接收者，并且沿着这条链传递，直到有一个对象来处理它或者直到最后也没有对象处理而留在链末尾端。</p></blockquote><h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><p>消息记录器，判断消息等级小于自己的等级就打印消息，并传递到下一个链节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INFO = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEBUG = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ERROR = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">int</span> level;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//责任链中的下一个元素</span></span><br><span class="line">   <span class="keyword">protected</span> AbstractLogger nextLogger;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextLogger</span><span class="params">(AbstractLogger nextLogger)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.nextLogger = nextLogger;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMessage</span><span class="params">(<span class="keyword">int</span> level, String message)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.level &lt;= level)&#123;</span><br><span class="line">         write(message);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(nextLogger !=<span class="keyword">null</span>)&#123;</span><br><span class="line">         nextLogger.logMessage(level, message);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span></span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实体类：将<code>ConsoleLogger-&gt;FileLogger-&gt;ErrorLogger</code>串联</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsoleLogger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = Level.INFO;</span><br><span class="line">        <span class="comment">//指定nextLogger为FileLogger</span></span><br><span class="line">        setNextLogger(<span class="keyword">new</span> FileLogger());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Console logger: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileLogger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = Level.DEBUG;</span><br><span class="line">        setNextLogger(<span class="keyword">new</span> ErrorLogger());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;File logger: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorLogger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = Level.ERROR;</span><br><span class="line">        <span class="comment">//nextLogger设置为null</span></span><br><span class="line">        <span class="comment">//扩展时将此更改为新的Logger</span></span><br><span class="line">        setNextLogger(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Error logger: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**         </span></span><br><span class="line"><span class="comment">         * 暴露最低等级既可         </span></span><br><span class="line"><span class="comment">         */</span>        </span><br><span class="line">        AbstractLogger consoleLogger = <span class="keyword">new</span> ConsoleLogger();</span><br><span class="line"></span><br><span class="line">        consoleLogger.logMegger(<span class="number">3</span>, <span class="string">&quot;错误信息&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        consoleLogger.logMegger(<span class="number">2</span>, <span class="string">&quot;测试信息&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        consoleLogger.logMegger(<span class="number">1</span>, <span class="string">&quot;控制台信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Console logger: 错误信息</span></span><br><span class="line"><span class="comment">File logger: 错误信息</span></span><br><span class="line"><span class="comment">Error logger: 错误信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Console logger: 测试信息</span></span><br><span class="line"><span class="comment">File logger: 测试信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Console logger: 控制台信息</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>在职责链模式中，使得每一个对象都有可能来处理请求，从而实现了请求的发送者和接收者之间的解耦。</li><li>同时职责链模式简化了对象的结构，它使得每个对象都只需要引用它的后继者即可，而不必了解整条链，这样既提高了系统的灵活性也使得增加新的请求处理类也比较方便。</li><li>但是在职责链中我们不能保证所有的请求都能够被处理，而且不利于观察运行时特征。</li></ul><h3 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式(Command)"></a>命令模式(Command)</h3><blockquote><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p></blockquote><p>一个编辑器的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StringBuilder buffer = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paste</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String text = getFromClipBoard();</span><br><span class="line">        add(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        buffer.append(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.deleteCharAt(buffer.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用一个StringBuilder模拟一个文本编辑器，它支持copy()、paste()、add()、delete()等方法。</p><p>直接调用方法，调用方需要了解TextEditor的所有接口信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TextEditor editor = <span class="keyword">new</span> TextEditor();</span><br><span class="line">editor.add(<span class="string">&quot;Command pattern in text editor.\n&quot;</span>);</span><br><span class="line">editor.copy();</span><br><span class="line">editor.paste();</span><br><span class="line">System.out.println(editor.getState());</span><br></pre></td></tr></table></figure><p>命令需要把调用方发送命令和执行方执行命令分开。引入一个Command接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方创建一个对应的Command，然后执行，并不关心内部是如何具体执行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 持有执行者对象:</span></span><br><span class="line">    <span class="keyword">private</span> TextEditor receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CopyCommand</span><span class="params">(TextEditor receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.copy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TextEditor receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PasteCommand</span><span class="params">(TextEditor receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.paste();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TextEditor editor = <span class="keyword">new</span> TextEditor();</span><br><span class="line">editor.add(<span class="string">&quot;Command pattern in text editor.\n&quot;</span>);</span><br><span class="line"><span class="comment">// 执行一个CopyCommand:</span></span><br><span class="line">Command copy = <span class="keyword">new</span> CopyCommand(editor);</span><br><span class="line">copy.execute();</span><br><span class="line">editor.add(<span class="string">&quot;----\n&quot;</span>);</span><br><span class="line"><span class="comment">// 执行一个PasteCommand:</span></span><br><span class="line">Command paste = <span class="keyword">new</span> PasteCommand(editor);</span><br><span class="line">paste.execute();</span><br><span class="line">System.out.println(editor.getState());</span><br></pre></td></tr></table></figure><p>本例的需求很简单，那么直接调用显然更直观而且更简单。但如果TextEditor复杂到一定程度，例如需要支持Undo、Redo的功能时，就需要使用命令模式，因为我们可以给每个命令增加undo()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把执行的一系列命令用List保存起来，就既能支持Undo，又能支持Redo。这个时候，我们又需要一个Invoker对象，负责执行命令并保存历史命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐</span><br><span class="line">│   Client    │</span><br><span class="line">└─────────────┘</span><br><span class="line">       │</span><br><span class="line"></span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line">┌─────────────┐</span><br><span class="line">│   Invoker   │</span><br><span class="line">├─────────────┤    ┌───────┐</span><br><span class="line">│List commands│─ ─&gt;│Command│</span><br><span class="line">│invoke(c)    │    └───────┘</span><br><span class="line">│undo()       │        │  ┌──────────────┐</span><br><span class="line">└─────────────┘        ├─&gt;│ CopyCommand  │</span><br><span class="line">                       │  ├──────────────┤</span><br><span class="line">                       │  │editor.copy() │─ ┐</span><br><span class="line">                       │  └──────────────┘</span><br><span class="line">                       │                    │  ┌────────────┐</span><br><span class="line">                       │  ┌──────────────┐   ─&gt;│ TextEditor │</span><br><span class="line">                       └─&gt;│ PasteCommand │  │  └────────────┘</span><br><span class="line">                          ├──────────────┤</span><br><span class="line">                          │editor.paste()│─ ┘</span><br><span class="line">                          └──────────────┘</span><br></pre></td></tr></table></figure><h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><blockquote><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p></blockquote><p>例如，使用正则表达式来匹配字符串时，正则表达式本身就是一个字符串，但要把正则表达式解析为语法树，然后再匹配指定的字符串，就需要一个解释器。</p><p>实现一个完整的正则表达式的解释器非常复杂，但是使用解释器模式却很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s &#x3D; &quot;+861012345678&quot;;</span><br><span class="line">System.out.println(s.matches(&quot;^\\+\\d+$&quot;));</span><br></pre></td></tr></table></figure><p>类似的，当我们使用JDBC时，执行的SQL语句虽然是字符串，但最终需要数据库服务器的SQL解释器来把SQL“翻译”成数据库服务器能执行的代码，这个执行引擎也非常复杂，但对于使用者来说，仅仅需要写出SQL字符串即可。</p><h3 id="迭代器模式-Iterator"><a href="#迭代器模式-Iterator" class="headerlink" title="迭代器模式(Iterator)"></a>迭代器模式(Iterator)</h3><blockquote><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p></blockquote><p>实现一个自定义的集合，通过Iterator模式实现倒序遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseArrayCollection</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReverseArrayCollection</span><span class="params">(T... objs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = Arrays.copyOfRange(objs, <span class="number">0</span>, objs.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReverseIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ReverseIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 索引位置:</span></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReverseIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 创建Iterator时,索引在数组末尾:</span></span><br><span class="line">            <span class="keyword">this</span>.index = ReverseArrayCollection.<span class="keyword">this</span>.array.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果索引大于0,那么可以移动到下一个元素(倒序往前移动):</span></span><br><span class="line">            <span class="keyword">return</span> index &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 将索引移动到下一个元素并返回(倒序往前移动):</span></span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">return</span> array[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类隐含地持有一个它所在对象的this引用，可以通过<code>ReverseArrayCollection.this</code>引用到它所在的集合。</p><h3 id="观察者模式-Observer"><a href="#观察者模式-Observer" class="headerlink" title="观察者模式(Observer)"></a>观察者模式(Observer)</h3><blockquote><p>一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。</p></blockquote><p>例如，一个商品网站，当发生商品变动时，需要通知管理员与消费者，就可以抽象出一个<code>ProductObserver</code>接口，任何人想要观察Store，只要实现该接口，并且把自己注册到Store即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ProductObserver&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Product&gt; products = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册观察者:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(ProductObserver observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消注册:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(ProductObserver observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNewProduct</span><span class="params">(String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        Product p = <span class="keyword">new</span> Product(name, price);</span><br><span class="line">        products.put(p.getName(), p);</span><br><span class="line">        <span class="comment">// 通知观察者:</span></span><br><span class="line">        observers.forEach(o -&gt; o.onPublished(p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProductPrice</span><span class="params">(String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        Product p = products.get(name);</span><br><span class="line">        p.setPrice(price);</span><br><span class="line">        <span class="comment">// 通知观察者:</span></span><br><span class="line">        observers.forEach(o -&gt; o.onPriceChanged(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，<code>Admin</code> 和 <code>Consumer</code>就可以通过实现该接口并注册即可，无需在函数中对于每个不同类的对象调用一次通知方法。</p><h3 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式(State)"></a>状态模式(State)</h3><blockquote><p>将不同状态的逻辑分离到不同的状态类中，从而使得增加新状态更容易；</p></blockquote><p>例如，我们设计一个聊天机器人，它有两个状态：未连线；已连线。</p><p>对于未连线状态，我们收到消息也不回复：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisconnectedState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bye!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reply</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于已连线状态，我们回应收到的消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectedState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, I&#x27;m Bob.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reply</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input.endsWith(<span class="string">&quot;?&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Yes. &quot;</span> + input.substring(<span class="number">0</span>, input.length() - <span class="number">1</span>) + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (input.endsWith(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> input.substring(<span class="number">0</span>, input.length() - <span class="number">1</span>) + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> input.substring(<span class="number">0</span>, input.length() - <span class="number">1</span>) + <span class="string">&quot;?&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态模式的关键设计思想在于<strong>状态切换</strong>，我们引入一个<code>BotContext</code>完成状态切换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BotContext</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> State state = <span class="keyword">new</span> DisconnectedState();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">chat</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;hello&quot;</span>.equalsIgnoreCase(input)) &#123;</span><br><span class="line">            <span class="comment">// 收到hello切换到在线状态:</span></span><br><span class="line">state = <span class="keyword">new</span> ConnectedState();</span><br><span class="line"><span class="keyword">return</span> state.init();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;bye&quot;</span>.equalsIgnoreCase(input)) &#123;</span><br><span class="line">            <span class="comment">//  收到bye切换到离线状态:</span></span><br><span class="line">state = <span class="keyword">new</span> DisconnectedState();</span><br><span class="line"><span class="keyword">return</span> state.init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> state.reply(input);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello</span><br><span class="line">&lt; Hello, I&#39;m Bob.</span><br><span class="line">&gt; Nice to meet you.</span><br><span class="line">&lt; Nice to meet you!</span><br><span class="line">&gt; Today is cold?</span><br><span class="line">&lt; Yes. Today is cold!</span><br><span class="line">&gt; bye</span><br><span class="line">&lt; Bye!</span><br></pre></td></tr></table></figure><h3 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式(Strategy)"></a>策略模式(Strategy)</h3><blockquote><p>核心思想是在一个计算方法中把容易变化的算法抽出来作为“策略”参数传进去，从而使得新增策略不必修改原有逻辑。</p></blockquote><p>策略模式在Java标准库中应用非常广泛，例如，实现忽略大小写排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;orange&quot;</span> &#125;;</span><br><span class="line">Arrays.sort(array, String::compareToIgnoreCase);</span><br><span class="line">System.out.println(Arrays.toString(array));</span><br><span class="line"><span class="comment">// [apple, Banana, orange, Pear]</span></span><br></pre></td></tr></table></figure><p>想倒序排序，就传入<code>(s1, s2) -&gt; -s1.compareTo(s2)</code>，这个比较两个元素大小的算法就是策略。</p><p>在 OO 课中，我们将电梯调度算法进行的封装也是策略模式思想的体现。或是商城的折扣算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 持有某个策略:</span></span><br><span class="line">    <span class="keyword">private</span> DiscountStrategy strategy = <span class="keyword">new</span> UserDiscountStrategy();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许客户端设置新策略:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(DiscountStrategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">calculatePrice</span><span class="params">(BigDecimal total)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total.subtract(<span class="keyword">this</span>.strategy.getDiscount(total)).setScale(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* --- 调用 --- */</span></span><br><span class="line">DiscountContext ctx = <span class="keyword">new</span> DiscountContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认使用普通会员折扣:</span></span><br><span class="line">BigDecimal pay1 = ctx.calculatePrice(BigDecimal.valueOf(<span class="number">105</span>));</span><br><span class="line">System.out.println(pay1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用满减折扣:</span></span><br><span class="line">ctx.setStrategy(<span class="keyword">new</span> OverDiscountStrategy());</span><br><span class="line">BigDecimal pay2 = ctx.calculatePrice(BigDecimal.valueOf(<span class="number">105</span>));</span><br><span class="line">System.out.println(pay2);</span><br></pre></td></tr></table></figure><h3 id="模板方法模式-Template-Method"><a href="#模板方法模式-Template-Method" class="headerlink" title="模板方法模式(Template Method)"></a>模板方法模式(Template Method)</h3><blockquote><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p></blockquote><p>例：实现一个支持数据库查询数据、对数据进行缓存的类。如何缓存没想好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSetting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getSetting</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String value = lookupCache(key);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            value = readFromDatabase(key);</span><br><span class="line">            putIntoCache(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">lookupCache</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">putIntoCache</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们希望用一个Map做缓存，那么可以写一个LocalSetting：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalSetting</span> <span class="keyword">extends</span> <span class="title">AbstractSetting</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">lookupCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">putIntoCache</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要使用Redis做缓存，那么可以再写一个RedisSetting：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSetting</span> <span class="keyword">extends</span> <span class="title">AbstractSetting</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RedisClient client = RedisClient.create(<span class="string">&quot;redis://localhost:6379&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">lookupCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;</span><br><span class="line">            RedisCommands&lt;String, String&gt; commands = connection.sync();</span><br><span class="line">            <span class="keyword">return</span> commands.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">putIntoCache</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;</span><br><span class="line">            RedisCommands&lt;String, String&gt; commands = connection.sync();</span><br><span class="line">            commands.set(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：Redis是一个数据库，其具备如下特性：</p><ul><li>基于内存运行，性能高效</li><li>支持分布式，理论上可以无限扩展</li><li>key-value存储系统</li><li>开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;肾莫是设计模式&quot;&gt;&lt;a href=&quot;#肾莫是设计模式&quot; class=&quot;headerlink&quot; title=&quot;肾莫是设计模式&quot;&gt;&lt;/a&gt;肾莫是设计模式&lt;/h2&gt;&lt;p&gt;设计模式（&lt;code&gt;Design pattern&lt;/code&gt;）是一套被反复使用、多数人知晓的、经</summary>
      
    
    
    
    <category term="ObjectOriented" scheme="http://yoursite.com/categories/ObjectOriented/"/>
    
    
    <category term="OO" scheme="http://yoursite.com/tags/OO/"/>
    
    <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>「OOP」UML图</title>
    <link href="http://yoursite.com/2021/04/23/ObjectOriented/%E3%80%8COO%E3%80%8D-UML%E5%9B%BE/"/>
    <id>http://yoursite.com/2021/04/23/ObjectOriented/%E3%80%8COO%E3%80%8D-UML%E5%9B%BE/</id>
    <published>2021-04-23T11:18:06.000Z</published>
    <updated>2021-04-27T03:44:39.452Z</updated>
    
    <content type="html"><![CDATA[<p>UML（<code>Unified Modeling Language</code>），统一建模语言。是用来对软件密集系统进行可视化建模的一种语言。</p><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="https://img.imgdb.cn/item/60856100d1a9ae528f8509d9.jpg"></p><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><h4 id="泛化关系-generalization"><a href="#泛化关系-generalization" class="headerlink" title="泛化关系(generalization)"></a>泛化关系(generalization)</h4><p>类的继承结构表现在UML中为：泛化与实现。</p><p>泛化关系表现为继承非抽象类：（A继承自B）</p><p><img src="https://img.imgdb.cn/item/60855e68d1a9ae528f6d19cd.jpg" alt="uml_gen"></p><h4 id="实现关系-realize"><a href="#实现关系-realize" class="headerlink" title="实现关系(realize)"></a>实现关系(realize)</h4><p>实现关系表现为继承抽象类或实现接口：</p><p><img src="https://img.imgdb.cn/item/60855ee4d1a9ae528f713a04.jpg" alt="uml_realize"></p><h4 id="聚合关系-aggregation"><a href="#聚合关系-aggregation" class="headerlink" title="聚合关系(aggregation)"></a>聚合关系(aggregation)</h4><p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义。例如：一个部门由多个员工组成。</p><p>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在。例如， 部门撤销了，人员不会消失，他们依然存在。</p><p>下图表示B由A组成：</p><p><img src="https://img.imgdb.cn/item/60855f55d1a9ae528f7527f8.jpg"></p><h4 id="组合关系-composition"><a href="#组合关系-composition" class="headerlink" title="组合关系(composition)"></a>组合关系(composition)</h4><p>组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在。例如，公司不存在了，部门也将不存在了。</p><p><img src="https://img.imgdb.cn/item/60855fb4d1a9ae528f787e31.jpg"></p><h4 id="关联关系-association"><a href="#关联关系-association" class="headerlink" title="关联关系(association)"></a>关联关系(association)</h4><p>一般用来定义对象之间静态的、天然的结构。关联关系是一种“强关联”的关系。例如：乘车人和车票之间、学生和学校都是一种关联关系。</p><p>用一条直线表示。</p><h4 id="依赖关系-dependency"><a href="#依赖关系-dependency" class="headerlink" title="依赖关系(dependency)"></a>依赖关系(dependency)</h4><p>描述一个对象在运行期间会用到另一个对象的关系。</p><p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变化。</p><p>依赖也有方向，双向依赖是一种非常糟糕的结构，我们应该保持单向依赖，杜绝双向依赖的产生。</p><p>注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还有“使用”对方的方法和属性。</p><p>下图表示A依赖于B：</p><p><img src="https://img.imgdb.cn/item/608560cbd1a9ae528f82fee1.jpg"></p><h2 id="UML时序图（顺序图）"><a href="#UML时序图（顺序图）" class="headerlink" title="UML时序图（顺序图）"></a>UML时序图（顺序图）</h2><p>时序图(<code>Sequence Diagram</code>)，又名序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。</p><p><img src="https://img.imgdb.cn/item/60856504d1a9ae528fad75f5.jpg"></p><h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h3><h4 id="角色-Actor"><a href="#角色-Actor" class="headerlink" title="角色(Actor)"></a>角色(Actor)</h4><p>系统角色，可以是人或者其他系统，子系统。以一个小人图标表示。</p><h4 id="对象-Object"><a href="#对象-Object" class="headerlink" title="对象(Object)"></a>对象(Object)</h4><p>位于时序图的顶部，以一个矩形表示。</p><h4 id="生命线-LifeLine"><a href="#生命线-LifeLine" class="headerlink" title="生命线(LifeLine)"></a>生命线(LifeLine)</h4><p>时序图中每个对象和底部中心都有一条垂直的虚线，即对象的生命线(对象的时间线)。</p><h4 id="消息-Message"><a href="#消息-Message" class="headerlink" title="消息(Message)"></a>消息(Message)</h4><p>表现代表对象之间发送的信息。消息分为三种类型。</p><ul><li><p><strong>同步消息(Synchronous Message)</strong></p><p>消息的发送者把信号传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。以一条实线+实心箭头表示。</p></li><li><p><strong>异步消息(Asynchronous Message)</strong></p><p>消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息。以<code>-&gt;</code>表示。</p></li><li><p><strong>返回消息(Return Message)</strong></p><p>表示从过程调用返回。以<code>&lt;---</code>表示</p></li></ul><h4 id="自关联消息"><a href="#自关联消息" class="headerlink" title="自关联消息"></a>自关联消息</h4><p>表示方法的自身调用或者一个对象内的一个方法调用另外一个方法。以一个半闭合的长方形+下方实心剪头表示。</p><h4 id="组合片段"><a href="#组合片段" class="headerlink" title="组合片段"></a>组合片段</h4><p>组合片段用来解决交互执行的条件和方式，它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。</p><hr><p>附：</p><ul><li><a href="https://plantuml.com/zh/sequence-diagram">https://plantuml.com/zh/sequence-diagram</a> 一个可online根据代码生成时序图的网站</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;UML（&lt;code&gt;Unified Modeling Language&lt;/code&gt;），统一建模语言。是用来对软件密集系统进行可视化建模的一种语言。&lt;/p&gt;
&lt;h2 id=&quot;UML类图&quot;&gt;&lt;a href=&quot;#UML类图&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="ObjectOriented" scheme="http://yoursite.com/categories/ObjectOriented/"/>
    
    
    <category term="OO" scheme="http://yoursite.com/tags/OO/"/>
    
    <category term="UML" scheme="http://yoursite.com/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>「OS」Pre</title>
    <link href="http://yoursite.com/2021/04/20/OperatingSystem/OS-1/"/>
    <id>http://yoursite.com/2021/04/20/OperatingSystem/OS-1/</id>
    <published>2021-04-20T12:54:47.000Z</published>
    <updated>2021-05-06T09:13:57.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>操作系统是一组管理计算机硬件资源的软件集合，它向计算机程序提供共性的服务：</p><ul><li>提供一个计算机用户与计算机硬件系统之间的接口，使计算机系统更易于使用。（使用者）</li><li>有效地控制和管理计算机系统中的各种硬件和软件资源，使之得到更有效的利用。（资源管理者）</li><li>合理地组织计算机系统的工作流程，以改善系统性能（如响应时间、系统吞吐量）。</li></ul><h1 id="历史沿革"><a href="#历史沿革" class="headerlink" title="历史沿革"></a>历史沿革</h1><p>OS 史前阶段 -&gt; 批处理 -&gt; 分时 -&gt; 现代 OS -&gt; 网络化 OS / 分布式 OS</p><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><blockquote><p>把用户提交的作业成批送入计算机，由作业调度程序自动选择作业运行</p></blockquote><h3 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h3><blockquote><p>加载在计算机上的一个系统软件，在它的控制下，计算机能够自动地、成批地处理一个或多个用户的作业（包括程序、数据和命令）<br>它分为：<strong>联机批处理系统</strong>和<strong>脱机批处理系统</strong></p></blockquote><ul><li>首先出现的是联机批处理系统，即作业的输入/输出由CPU来处理。<ul><li>在主机与输入机之间增加一个存储设备——<strong>磁带</strong>，在运行于主机上的监督程序的自动控制下，计算机可自动完成：成批地把输入机上的用户作业读入磁带，依次把磁带上的用户作业读入主机内存并执行，然后把计算结果向输出机输出</li></ul></li><li>为缓解高速主机与慢速外设的矛盾，引入了脱机批处理系统，即输入/输出脱离主机控制。<ul><li>增加一台不与主机直接相连而专门用于与输入/输出设备打交道的<strong>卫星机</strong>。<br>在前述的批处理系统中，引入<strong>多道程序设计技术</strong>后形成<strong>多道批处理系统</strong></li></ul></li><li>多道：系统内可同时容纳多个作业。</li></ul><h2 id="分时"><a href="#分时" class="headerlink" title="分时"></a>分时</h2><blockquote><p>将CPU处理时间分割为多个时间片，将时间片分给不同程序，达到多个程序“同时”运行的效果。从而支持用户、多进程。<br>与批处理相比，增加了管理时间片的系统开销、管理多用户的系统开销、管理硬件的系统开销（引入了虚存）、交互IO的系统开销等等。</p></blockquote><h2 id="网络化-OS"><a href="#网络化-OS" class="headerlink" title="网络化 OS"></a>网络化 OS</h2><blockquote><p>在传统单机OS上增加一个模块——网络通信模块，主要提供联网功能和资源的远程访问，实现多机互联<br>网络操作系统主要指运行在各种服务器上的操作系统，目前主要有 UNIX、LINUX、Winodws。</p></blockquote><h2 id="分布式-OS"><a href="#分布式-OS" class="headerlink" title="分布式 OS"></a>分布式 OS</h2><blockquote><p>区别于集中式操作系统，分布式操作系统负责管理分布式处理系统资源和控制分布式程序运行。它是一个一体化系统，将若干独立的计算机连成网络，有一个全局操作系统负责全系统的资源分配和调度等工作，但整个系统对用户来说如同是一台计算机。<br>计算机网络是分布式操作系统的物理基础。<br>分布式操作系统的特点主要有：</p></blockquote><ul><li>分布性。网络操作系统虽具分布处理功能，但其控制功能却是集中在某个或某些主机或网络服务器中，即集中式。</li><li>透明性。分布式操作系统通常能很好地隐藏系统内部的实现细节。</li><li>并行性。分布式操作系统具有任务分配功能，可将多个任务分配到多个处理单元上，使这些任务并行执行，从而加速了任务的执行。</li><li>共享性。分布式操作系统支持系统中所有用户对分布在各个站点上的软硬件资源的共享和透明方式访问。而网络操作系统所提供的资源共享功能仅局限于主机或网络服务器中资源，对于其它机器上的资源通常仅有使用该机的用户独占。</li><li>健壮性。分布式操作系统由于处理和控制功能的分布性而具有较好的可用性和可靠性，即健壮性。而网络操作系统由于控制功能的集中式特点而使系统重构功能较弱，且具有潜在的不可靠性。</li></ul><h1 id="Boot"><a href="#Boot" class="headerlink" title="Boot"></a>Boot</h1><p>操作系统的启动过程。</p><p>CPU 加电，取指寄存器复位到固定值后，需要 Bootloader 的引导。bootloader 需要将内核镜像文件加载到内存中， 那么它就能选择使用哪一个内核镜像进行加载，即实现多重开机的功能。使用bootloader后，我们就能够在一个硬件上运行多个操作系统了。</p><h2 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h2><p>从操作系统的角度看，boot loader 的总目标就是正确地调用内核来执行。 由于 boot loader 的实现依赖于 cpu 的体系结构，因此大多数 boot loader 都分为 stage1 和 stage2 两大部分。</p><h3 id="stage-1"><a href="#stage-1" class="headerlink" title="stage 1"></a>stage 1</h3><p>由于内存 RAM 尚未初始化完成， stage 1 直接运行在存放 bootloader 的存储设备上（比如FLASH）</p><ul><li>初始化硬件设备，包括watchdog timer、中断、时钟、内存等。</li><li>为加载 stage 2准备RAM空间，然后将stage 2的代码复制到RAM空间</li><li>设置堆栈，并跳转到stage 2的入口函数。</li></ul><h3 id="stage-2"><a href="#stage-2" class="headerlink" title="stage 2"></a>stage 2</h3><p>运行在RAM中。（由于 stage 1 不能在内存 RAM 中运行，其自身运行会受诸多限制， 比如有些 flash 程序不可写，即使程序可写的 flash 也有存储空间限制。这就是为什么需要stage 2的原因）</p><ul><li>初始化这一阶段需要使用的硬件设备以及其他功能</li><li>将内核镜像文件从存储器读到RAM中</li><li>为内核设置启动参数</li><li>将CPU指令寄存器的内容设置为内核入口函数的地址，即可将控制权从bootloader 转交给操作系统内核。</li></ul><p>以上两个工作阶段的具体实现在不同系统、不同硬件环境都会有差别。</p><p>比如 x86 PC 的启动过程中，首先执行的是BIOS中的代码，主要完成硬件初始化相关的工作， 然后BIOS会从MBR（master boot record，开机硬盘的第一个扇区）中读取开机信息。Linux中常说的 Grub 和 Lilo 这两种开机管理程序就是被保存在MBR中的。</p><p><em>注：GRUB(GRand Unified Bootloader)是GNU项目的一个多操作系统启动程序。简单的说，就是可以用于在有多个操作系统的机器上， 在刚开机的时候选择一个操作系统进行引导。</em></p><p>BIOS加载MBR中的Grub代码后就把CPU交给了Grub，Grub的工作就是一步一步的加载自身代码，从而识别文件系统， 然后就能够将文件系统中的内核镜像文件加载到内存中，并将CPU控制权转交给操作系统内核。 这样看来，其实BIOS和Grub的前一部分构成了前述stage 1的工作，而stage 2的工作则是完全在Grub中完成的。</p><p>*注：bootloader有两种操作模式：启动加载模式和下载模式。对于普通用户而言，bootloader只运行在启动加载模式，就是我们之前讲解的过程。 而下载模式仅仅对于开发人员有意义，区别是前者是通过本地设备中的内核镜像文件启动操作系统的，而后者是通过串口或以太网等通信手段将远端的内核镜像上载到内存的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;操作系统是一组管理计算机硬件资源的软件集合，它向计算机程序提供共性的服务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供一个计算机用户与计算机硬件系统之间</summary>
      
    
    
    
    <category term="OperatingSystem" scheme="http://yoursite.com/categories/OperatingSystem/"/>
    
    
    <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>「组合数学」生成排列组合</title>
    <link href="http://yoursite.com/2021/04/20/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88/"/>
    <id>http://yoursite.com/2021/04/20/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88/</id>
    <published>2021-04-20T01:00:15.000Z</published>
    <updated>2021-05-21T03:15:37.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路径数问题"><a href="#路径数问题" class="headerlink" title="路径数问题"></a>路径数问题</h2><p>$C(m+n, n)$，从$(0,0)$到$(m,n)$，那么每一个路径对应一个 xxyx… 这样的排列，选n个位置放y，即 $C(m+n, n)$</p><ul><li>$C(n,r)=C(n-1,r)+C(n-1,r-1)$</li></ul><p>可推出杨辉三角。</p><ul><li>$(_r^{n+r+1})=(<em>r^{n+r})+(^{n+r-1}</em>{r-1})+…+(^n_0)$</li></ul><p><img src="https://pic.imgdb.cn/item/60a0debe6ae4f77d35d1de66.jpg"></p><ul><li>$(^{m+n}_r)=(^m_0)(^n_r)+…+(^m_r)(^n_0)$</li></ul><p>m+n个球，m个红球，n个蓝球，取出的r个球：0个红球，r个蓝球…..r个红球，0个蓝球</p><h2 id="生成排列"><a href="#生成排列" class="headerlink" title="生成排列"></a>生成排列</h2><p>由 n 个正整数组成的集合<code>&#123;1,2,..,n&#125;</code>有$n!$排列。</p><p>$n!=\sqrt{2\pi n}(\frac{n}{e})^n$</p><p>需求：从已知排列出发，生成新的排列</p><h3 id="序数法"><a href="#序数法" class="headerlink" title="序数法"></a>序数法</h3><h4 id="递增进位"><a href="#递增进位" class="headerlink" title="递增进位"></a>递增进位</h4><p>以<code>&#123;(n-1)!,(n-2)!...2!,1!&#125;</code>为基数表示：<br>$$<br>n!=(n-1)(n-1)!+(n-1)!=…=\sum_{k=1}^{n-1}k\cdot k!+1<br>$$<br>那么对于任意一个整数 m（$0\le m\le n!-1$）：<br>$$<br>m=a_1(n-1)!+a_2(n-2)!+…+a_{n-1}1!\qquad(a_i\in[0,n-i])<br>$$<br>$(a_1,…,a_{n-1})$序列与$0\sim n!-1$之间的整数一一对应，故称为<strong>中介数</strong></p><p>或相对应$(b_n,…,b_2)$，$b_n=a_1$，以此类推</p><p><strong>转化</strong>：</p><p>$a_{n-1}=m/2的余数,a_{n-2}=(m/3)/2的余数…$</p><h4 id="递减进位"><a href="#递减进位" class="headerlink" title="递减进位"></a>递减进位</h4><p>$$<br>m=\sum_{i=1}^{n-1}a_i\cdot \frac{n!}{(n-i+1)!}\=a_1+a_2\cdot\frac{n!}{(n-1)!}+…+a_{n-1}\cdot\frac{n!}{2!}\qquad(a_i\in[0,n-i])<br>$$</p><p>$(a_{n-1},…,a_{1})$是中介数</p><p><strong>转化</strong>：</p><p>$a_{1}=m/n的余数,a_{2}=(m/n)/(n-1)的余数…$</p><h4 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h4><p>（1）排列$i_1i_2…i_n$与逆序列$(a_1,…,a_{n-1})$，$a_1$代表 1 左边比 1 大的整数的个数，以此类推。</p><p><strong>转化</strong>：</p><p>先确定n个空位。确定 1 的位置：从左向右数$a_1$个空格，下一空格填1；确定 2 的位置：从左向右数$a_2$个空格，注意此时填了 1，空格就不包括这个位置。</p><p>（2）排列$i_1i_2…i_n$与逆序列$(b_n,…,b_2)$，$b_n$为 n 右边比 n 小的整数个数</p><p>转化：类似上边</p><h3 id="字典序法"><a href="#字典序法" class="headerlink" title="字典序法"></a>字典序法</h3><p>$i_1i_2…i_n$求下一个排列的算法：</p><p>从右向左找到第一个右邻比自己大的数$i_k$，在其右边的所有比自己大的数中选取最右边的数$i_j$，将两者交换。</p><p>例：839647521,4是从右向左第一个右邻比自己大的，然后右边比自己大的有7、5，选最右的5，交换，得下个排列为：839657421</p><p>中介数：$(a_1,a_2,…,a_{n-1})$ ，$a_1$代表$i_1$右边比$i_1$小的字符的个数</p><p>序数：<br>$$<br>m=a_1(n-1)!+a_2(n-2)!+…+a_{n-1}1!\qquad(a_i\in[0,n-i])<br>$$<br><img src="https://pic.imgdb.cn/item/60a3c5516ae4f77d359e6274.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;路径数问题&quot;&gt;&lt;a href=&quot;#路径数问题&quot; class=&quot;headerlink&quot; title=&quot;路径数问题&quot;&gt;&lt;/a&gt;路径数问题&lt;/h2&gt;&lt;p&gt;$C(m+n, n)$，从$(0,0)$到$(m,n)$，那么每一个路径对应一个 xxyx… 这样的排列，选n个位置</summary>
      
    
    
    
    <category term="组合数学" scheme="http://yoursite.com/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
  </entry>
  
</feed>
