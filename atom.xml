<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>烟湮燕眼&#39;s Notes</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-07-09T11:24:29.409Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>烟湮燕眼</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「Spring」AOP</title>
    <link href="http://yoursite.com/2021/07/07/Spring/Spring-2-AOP/"/>
    <id>http://yoursite.com/2021/07/07/Spring/Spring-2-AOP/</id>
    <published>2021-07-07T10:44:17.000Z</published>
    <updated>2021-07-09T11:24:29.409Z</updated>
    
    <content type="html"><![CDATA[<p>OOP我们都知道，它把系统看作多个对象的交互。而AOP（<code>Aspect Oriented Programming</code>），面向切面编程，把系统分解为不同的关注点，或者称之为切面（Aspect）。</p><p>例如，对每个业务方法，除了业务逻辑，还需要安全检查、日志记录和事务处理。</p><p>安全检查、日志、事务等代码，它们会重复出现在每个业务方法中。</p><p>如果我们采用<code>Proxy</code>模式，给业务组件包一个代理类来实现这些，确实也可以，但比较麻烦：必须先抽取接口，然后，针对每个方法实现Proxy。</p><p>而AOP可以把权限检查、日志、事务等视作一种切面（Aspect），然后，以某种自动化的方式，把切面织入到核心逻辑中，实现Proxy模式。</p><p>在Java平台上，对于AOP的织入，有3种方式：</p><ol><li>编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ就扩展了Java编译器，使用关键字aspect来实现织入；</li><li>类加载器：在目标类被装载到JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；</li><li>运行期：目标对象和切面都是普通Java类，通过JVM的动态代理功能或者第三方库实现运行期动态织入。</li></ol><p>Spring的AOP实现就是基于JVM的动态代理。</p><p>一些术语：</p><ul><li>Aspect：切面，即一个横跨多个核心逻辑的功能，或者称之为系统关注点；</li><li>Joinpoint：连接点，即定义在应用程序流程的何处插入切面的执行；</li><li>Pointcut：切入点，即一组连接点的集合；</li><li>Advice：增强，指特定连接点上执行的动作；</li><li>Introduction：引介，指为一个已有的Java对象动态地增加新的接口；</li><li>Weaving：织入，指将切面整合到程序的执行流程中；</li><li>Interceptor：拦截器，是一种实现增强的方式；</li><li>Target Object：目标对象，即真正执行业务的核心逻辑对象；</li><li>AOP Proxy：AOP代理，是客户端持有的增强后的对象引用。</li></ul><h1 id="装配"><a href="#装配" class="headerlink" title="装配"></a>装配</h1><p>现在，我们准备给<code>UserService</code>的每个业务方法执行前添加日志，给<code>MailService</code>的每个业务方法执行前后添加日志</p><p>首先，通过Maven引入Spring对AOP的支持：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-aspects&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>上述依赖会自动引入AspectJ，使用AspectJ实现AOP比较方便。</p><p>定义执行方法，并在方法上通过AspectJ的注解标注应该在何处触发并执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在执行UserService的每个方法前执行:</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(public * com.itranswarp.learnjava.service.UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[Before] do access check...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在执行MailService的每个方法前后执行:</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(public * com.itranswarp.learnjava.service.MailService.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doLogging</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[Around] start &quot;</span> + pjp.getSignature());</span><br><span class="line">        Object retVal = pjp.proceed();</span><br><span class="line">        System.err.println(<span class="string">&quot;[Around] done &quot;</span> + pjp.getSignature());</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，我们需要给<code>@Configuration</code>类加上一个<code>@EnableAspectJAutoProxy</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring的IoC容器看到这个注解，就会自动查找带有<code>@Aspect</code>的Bean，然后根据每个方法的<code>@Before</code>、<code>@Around</code>等注解把AOP注入到特定的Bean中。</p><p>AOP实现原理就是用核心业务类的子类，持有原实例的引用和切面类的引用，将它们组合。Spring对接口类型使用JDK动态代理，对普通类使用CGLIB创建子类。如果一个Bean的class是final，Spring将无法为其创建子类。</p><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><ul><li>@Before：这种拦截器先执行拦截代码，再执行目标代码。如果拦截器抛异常，那么目标代码就不执行了；</li><li>@After：这种拦截器先执行目标代码，再执行拦截器代码。无论目标代码是否抛异常，拦截器代码都会执行；</li><li>@AfterReturning：和@After不同的是，只有当目标代码正常返回时，才执行拦截器代码；</li><li>@AfterThrowing：和@After不同的是，只有当目标代码抛出了异常时，才执行拦截器代码；</li><li>@Around：能完全控制目标代码是否执行，并可以在执行前后、抛异常后执行任意拦截代码，可以说是包含了上面所有功能。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;OOP我们都知道，它把系统看作多个对象的交互。而AOP（&lt;code&gt;Aspect Oriented Programming&lt;/code&gt;），面向切面编程，把系统分解为不同的关注点，或者称之为切面（Aspect）。&lt;/p&gt;
&lt;p&gt;例如，对每个业务方法，除了业务逻辑，还需要安全</summary>
      
    
    
    
    <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
    <category term="SSM" scheme="http://yoursite.com/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>「Spring」IoC</title>
    <link href="http://yoursite.com/2021/07/04/Spring/Spring-1-IoC/"/>
    <id>http://yoursite.com/2021/07/04/Spring/Spring-1-IoC/</id>
    <published>2021-07-04T10:44:17.000Z</published>
    <updated>2021-07-07T08:41:28.234Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Framework主要包括几个模块：</p><ul><li>支持IoC和AOP的容器；</li><li>支持JDBC和ORM的数据访问模块；</li><li>支持声明式事务的模块；</li><li>支持基于Servlet的MVC开发；</li><li>支持基于Reactive的Web开发；</li><li>以及集成JMS、JavaMail、JMX、缓存等其他模块。</li></ul><p>IoC全称Inversion of Control，译为控制反转。</p><h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>如果一个系统有大量的组件，采用<code>new</code>创建实例的方式来持有，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。</p><p>而IoC就可以用于解决这一系列核心问题：</p><ul><li>负责创建组件</li><li>负责根据依赖关系组装组件</li><li>销毁时，按依赖顺序正确销毁</li></ul><p>传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。</p><p>在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，即等待外部的<code>set(...)</code>方法来传入组件</p><p>通过注入，我们获得了以下几点便利：</p><ul><li>无需关心如何创建，只需将引用指向注入的组件即可</li><li>共享组件容易</li><li>测试方便，我们可以传入容易获取的组件来测试正确性</li></ul><p>因此，IoC又称为依赖注入（DI：Dependency Injection）</p><p>我们需要告诉容器如何创建组件，以及各组件的依赖关系。最简单的是配置XML文件，Spring容器通过读取XML文件后使用反射完成：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;HikariDataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;BookService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。</p><p>上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为<code>dataSource</code>的组件通过属性<code>dataSource</code>（即调用<code>setDataSource()</code>方法）注入到另外两个组件中。</p><p>在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口。</p><h1 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h1><p>以一个具体的用户注册登录的例子为例，工程结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">spring-ioc-appcontext</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itranswarp</span><br><span class="line">        │           └── learnjava</span><br><span class="line">        │               ├── Main.java</span><br><span class="line">        │               └── service</span><br><span class="line">        │                   ├── MailService.java</span><br><span class="line">        │                   ├── User.java</span><br><span class="line">        │                   └── UserService.java</span><br><span class="line">        └── resources</span><br><span class="line">            └── application.xml</span><br></pre></td></tr></table></figure><ol><li>导入Spring开发的基本包坐标</li></ol><p>在<code>pom.xml</code>中引入<code>spring-context</code>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-ioc-appcontext<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.2.3.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写接口和实现类</li></ol><p>即主要功能的类与接口。</p><ol start="3"><li>创建 Spring核心配置文件</li></ol><ol start="4"><li>在Spring配置文件中配置UserDaolmpl</li></ol><p>即<code>application.xml</code>配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itranswarp.learnjava.service.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mailService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mailService&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mailService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itranswarp.learnjava.service.MailService&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Bean的顺序不重要，Spring根据依赖关系会自动正确初始化。</p><p>该<code>xml</code>配置文件与如下java代码等价：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UserService userService = <span class="keyword">new</span> UserService();</span><br><span class="line">MailService mailService = <span class="keyword">new</span> MailService();</span><br><span class="line">userService.setMailService(mailService);</span><br></pre></td></tr></table></figure><ol start="5"><li>使用Spring的API获得Bean实例</li></ol><p>创建一个Spring的IoC容器实例，然后加载配置文件，让Spring容器为我们创建并装配好配置文件中指定的所有Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;application.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>之后，我们就可以从Spring容器中“取出”装配好的Bean然后使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserService userService = context.getBean(UserService.class);</span><br><span class="line">User user = userService.login(<span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br></pre></td></tr></table></figure><p>Spring容器就是<code>ApplicationContext</code>，它是一个接口，有很多实现类，这里我们选择<code>ClassPathXmlApplicationContext</code>，表示它会自动从classpath中查找指定的XML配置文件。</p><h1 id="Annotation配置"><a href="#Annotation配置" class="headerlink" title="Annotation配置"></a>Annotation配置</h1><p>使用XML配置，写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。</p><p>而Annotation配置，可以无需XML配置文件，让Spring自动扫描Bean并组装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;        </span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">MailService mailService;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">(<span class="meta">@Autowired</span> MailService mailService)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mailService = mailService;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Component</code>注解就相当于定义了一个Bean，有一个可选的名称，默认是即小写开头的类名。</p><p><code>@Autowired</code>相当于把指定类型的Bean注入到指定的字段中。</p><p>最后，编写一个<code>AppConfig</code>类启动容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">        UserService userService = context.getBean(UserService.class);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AppConfig</code>标注了<code>@Configuration</code>，表示它是一个配置类。实现类<code>AnnotationConfigApplicationContext</code>必须传入一个标注了<code>@Configuration</code>的类名。</p><p><code>@ComponentScan</code>告诉容器，自动搜索当前类所在的包以及子包，把所有标注为<code>@Component</code>的Bean自动创建出来，并根据<code>@Autowired</code>进行装配。</p><p>因此要特别注意包的层次结构，工程目录需要如下创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring-ioc-annoconfig</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        └── java</span><br><span class="line">            └── com</span><br><span class="line">                └── itranswarp</span><br><span class="line">                    └── learnjava</span><br><span class="line">                        ├── AppConfig.java</span><br><span class="line">                        └── service</span><br><span class="line">                            ├── MailService.java</span><br><span class="line">                            ├── User.java</span><br><span class="line">                            └── UserService.java</span><br></pre></td></tr></table></figure><p>通常来说，启动配置<code>AppConfig</code>位于自定义的顶层包（例如<code>com.itranswarp.learnjava</code>），其他Bean按类别放入子包。</p><h1 id="定制Bean"><a href="#定制Bean" class="headerlink" title="定制Bean"></a>定制Bean</h1><ul><li>Spring默认使用Singleton（单例）创建Bean，容器初始化时创建Bean，容器关闭前销毁Bean。也可指定Scope为Prototype，我们每次调用<code>getBean(Class)</code>，容器都返回一个新的实例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span> <span class="comment">// @Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSession</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可将相同类型的Bean注入<code>List</code>。为了指定<code>List</code>中Bean的顺序，可以加上<code>@Order</code>注解：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailValidator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordValidator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可用<code>@Autowired(required=false)</code>允许可选注入。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="comment">// 如果找到一个类型为ZoneId的Bean，就注入，如果找不到，就忽略，而不会抛异常。</span></span><br><span class="line">    ZoneId zoneId = ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可用带<code>@Bean</code>标注的方法创建Bean。返回的Bean仍然是单例。</p></li><li><p>可使用<code>@PostConstruct</code>和<code>@PreDestroy</code>对Bean进行初始化和清理。</p></li></ul><p>首先引入入JSR-250定义的Annotation：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.annotation&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.annotation-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>然后在Bean的初始化和清理方法上标记<code>@PostConstruct</code>和<code>@PreDestroy</code>。</p><p>初始化时间在注入之后。</p><ul><li>相同类型的Bean只能有一个指定为<code>@Primary</code>，其他必须用<code>@Quanlifier(&quot;beanName&quot;)</code>指定别名。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;z&quot;)</span></span><br><span class="line">    <span class="function">ZoneId <span class="title">createZoneOfZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;utc8&quot;)</span></span><br><span class="line">    <span class="function">ZoneId <span class="title">createZoneOfUTC8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;UTC+08:00&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注入时，可通过别名<code>@Quanlifier(&quot;beanName&quot;)</code>指定某个Bean；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;z&quot;)</span> <span class="comment">// 指定注入名称为&quot;z&quot;的ZoneId</span></span><br><span class="line">ZoneId zoneId = ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以定义<code>FactoryBean</code>来使用工厂模式创建Bean。</li></ul><h1 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h1><p>Spring提供了<code>org.springframework.core.io.Resource</code>类便于注入资源文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> version;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;classpath:/logo.txt&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Resource resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String logo;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line"><span class="keyword">new</span> InputStreamReader(resource.getInputStream(), StandardCharsets.UTF_8))) &#123;</span><br><span class="line"><span class="keyword">this</span>.logo = reader.lines().collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLogo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(logo);</span><br><span class="line">System.out.println(<span class="string">&quot;app.version: &quot;</span> + version);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似<code>classpath:/logo.txt</code>表示在classpath中搜索<code>logo.txt</code>文件，然后，我们直接调用<code>Resource.getInputStream()</code>就可以获取到输入流，避免了自己搜索文件的代码。</p><h1 id="注入配置"><a href="#注入配置" class="headerlink" title="注入配置"></a>注入配置</h1><p>配置文件常用的配置方法是以<code>key=value</code>的形式写在<code>.properties</code>文件中。</p><p><code>@PropertySource</code>可以自动读取配置文件，相较于用<code>Resource</code>来读更简便。</p><p>先使用<code>@PropertySource</code>读取配置文件，然后通过<code>@Value</code>以<code>$&#123;key:defaultValue&#125;</code>的形式注入，可以极大地简化读取配置的麻烦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;app.properties&quot;)</span> <span class="comment">// 表示读取classpath的app.properties</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.zone:Z&#125;&quot;)</span></span><br><span class="line">    String zoneId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">ZoneId <span class="title">createZoneId</span><span class="params">(<span class="meta">@Value(&quot;$&#123;app.zone:Z&#125;&quot;)</span> String zoneId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(zoneId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者先通过一个简单的JavaBean持有所有的配置，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmtpConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;smtp.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;smtp.port:25&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在需要读取的地方，使用<code>#&#123;smtpConfig.host&#125;</code>注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;smtpConfig.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String smtpHost;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;smtpConfig.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> smtpPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>#&#123;&#125;</code>表示从JavaBean读取属性。<code>&quot;#&#123;smtpConfig.host&#125;&quot;</code>的意思是，从名称为<code>smtpConfig</code>的Bean读取<code>host</code>属性。</p><h1 id="条件装配"><a href="#条件装配" class="headerlink" title="条件装配"></a>条件装配</h1><p>在开发和部署时，我们可能需要的环境并不相同。</p><p>创建某个Bean时，Spring容器可以根据注解<code>@Profile</code>来决定是否创建，从而使得应用更加灵活。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;!test&quot;)</span></span><br><span class="line">    <span class="function">ZoneId <span class="title">createZoneId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.systemDefault();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;test&quot;)</span></span><br><span class="line">    <span class="function">ZoneId <span class="title">createZoneIdForTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行程序时，加上JVM参数<code>-Dspring.profiles.active=test</code>就可以指定以<code>test</code>环境启动。</p><p>此外，Spring还提供了<code>@Conditional</code>来进行条件装配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Conditional(OnSmtpEnvCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmtpMailService</span> <span class="keyword">implements</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示如果满足<code>OnSmtpEnvCondition</code>的条件，才会创建<code>SmtpMailService</code>这个Bean。</p><p>我们自定义条件为存在环境变量<code>smtp</code>，且值为<code>true</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnSmtpEnvCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;true&quot;</span>.equalsIgnoreCase(System.getenv(<span class="string">&quot;smtp&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Boot提供了更多使用起来更简单的条件注解，例如，如果配置文件中存在<code>app.smtp=true</code>，则创建<code>MailService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name=&quot;app.smtp&quot;, havingValue=&quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前classpath中存在类<code>javax.mail.Transport</code>，则创建<code>MailService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;javax.mail.Transport&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring Framework主要包括几个模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持IoC和AOP的容器；&lt;/li&gt;
&lt;li&gt;支持JDBC和ORM的数据访问模块；&lt;/li&gt;
&lt;li&gt;支持声明式事务的模块；&lt;/li&gt;
&lt;li&gt;支持基于Servlet的MVC开发；&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
    <category term="SSM" scheme="http://yoursite.com/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>「Java」多线程</title>
    <link href="http://yoursite.com/2021/07/03/Java/8-java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2021/07/03/Java/8-java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-07-03T02:44:17.000Z</published>
    <updated>2021-07-09T08:40:34.915Z</updated>
    
    <content type="html"><![CDATA[<p>Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行<code>main()</code>方法，在<code>main()</code>方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p><h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><ol><li>从<code>Thread</code>派生一个自定义类，然后覆写<code>run()</code>方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建<code>Thread</code>实例时，传入一个<code>Runnable</code>实例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看<code>Thread</code>类的源代码，会看到<code>start()</code>方法内部调用了一个<code>private native void start0()</code>方法，<code>native</code>修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。</p><h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>通过对另一个线程对象调用<code>join()</code>方法可以等待其执行结束，然后继续往下执行自身线程。</p><p>可以指定等待时间<code>join(long)</code>，超过等待时间线程仍然没有结束就不再等待。对已经运行结束的线程调用<code>join()</code>方法会立刻返回。</p><h2 id="currentThread"><a href="#currentThread" class="headerlink" title="currentThread"></a>currentThread</h2><p><code>Thread.currentThread()</code>获取当前线程</p><h1 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h1><h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h2><p><code>interrupt()</code>方法可以发出“中断请求”，通过检测<code>isInterrupted()</code>，可以响应是否结束。</p><p>如果线程处于等待状态，例如<code>t.join()</code>会让<code>main</code>线程等待，如果对<code>main</code>线程调用<code>interrupt()</code>，<code>join()</code>方法会立刻抛出<code>InterruptedException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread hello = <span class="keyword">new</span> HelloThread();</span><br><span class="line">        hello.start(); <span class="comment">// 启动hello线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hello.join(); <span class="comment">// 等待hello线程结束</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;interrupted!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hello.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h2><p>用一个<code>running</code>标志位来标识线程是否应该继续运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        HelloThread t = <span class="keyword">new</span> HelloThread();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        t.running = <span class="keyword">false</span>; <span class="comment">// 标志位置为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意线程间共享变量需要使用<code>volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p><p>在Java虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时间并不确定。因此，如果另一个线程在JVM把修改后的变量写回主存前读取了该变量，就会导致多线程之间共享的变量不一致。</p><p><code>volatile</code>关键字的目的就是告诉虚拟机：</p><ul><li>每次访问变量时，总是获取主内存的最新值；</li><li>每次修改变量后，立刻回写到主内存。</li></ul><h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p><p>在调用<code>start()</code>方法前，调用<code>setDaemon(true)</code>把该线程标记为守护线程即可。</p><p>在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。</p><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="synchronized-lockObject"><a href="#synchronized-lockObject" class="headerlink" title="synchronized(lockObject)"></a>synchronized(lockObject)</h2><p>JVM保证同一个锁在任意时刻只能被一个线程获取。</p><p>加锁是为了令同步块内的语句变为原子操作。JVM规范定义了几种单个原子操作：</p><ul><li>基本类型（<code>long</code>和<code>double</code>除外）赋值，例如：<code>int n = m</code>；</li><li>引用类型赋值，例如：<code>List&lt;String&gt; list = anotherList</code>。</li></ul><p><code>long</code>和<code>double</code>是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把<code>long</code>和<code>double</code>的赋值作为原子操作实现的。</p><h2 id="线程安全类"><a href="#线程安全类" class="headerlink" title="线程安全类"></a>线程安全类</h2><p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe）。Java标准库的<code>java.lang.StringBuffer</code>是线程安全的。</p><p>还有一些不变类，例如<code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是<code>final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p><p>最后，类似<code>Math</code>这些只提供静态方法，没有成员变量的类，也是线程安全的。</p><p>要设计线程安全类，就要将类的方法设计为线程安全的。用<code>synchronized</code>修饰方法可以把整个方法变为同步代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 相当于锁住this</span></span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 相当于锁住该类的Class实例</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>Java的线程锁是可重入的锁，即JVM允许同一个线程重复获取同一个锁。获取锁的时候，要记录这是第几次获取。每获取一次锁，记录+1，每退出<code>synchronized</code>块，记录-1，减到0时，才会真正释放锁。</p><p>而多线程各自持有不同的锁，并互相试图获取对方已持有的锁，就会导致无限等待，即死锁。</p><p>我们编写代码时，保证多线程获取锁的顺序一致，就可以避免这种死锁情况。</p><h2 id="wait-amp-notifyAll"><a href="#wait-amp-notifyAll" class="headerlink" title="wait() &amp; notifyAll()"></a>wait() &amp; notifyAll()</h2><p>两者配合可以用于多线程协调运行。</p><p>在<code>synchronized</code>内部：</p><ul><li>已获得的锁对象调用<code>wait()</code>方法，线程进入等待状态，并释放锁。<code>wait()</code>方法不会返回，直到将来某个时刻，线程从等待状态被其他线程唤醒后，<code>wait()</code>方法才会返回。<code>wait()</code>方法返回后，线程又会重新试图获得锁。</li><li>已获得的锁对象调用<code>notify()</code>或<code>notifyAll()</code>方法，唤醒其他等待线程。已唤醒的线程需要重新获得锁后才能继续执行。</li></ul><p>看一种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这里的判断条件是<code>if</code>，有A、B、C 3个线程在<code>isEmpty()=true</code>后进入了<code>wait()</code>，此时<code>queue</code>为空。D线程放入了一个task，唤醒所有等待线程。此时A、B、C都要从<code>wait()</code>返回，但只有其中一个能先获得锁先执行，假设是A，它立刻调用<code>remove()</code>然后释放锁，这个时候，queue又空了。随后，这个锁如果被B或C获得了，它们直接从<code>wait()</code>下一行执行，无需再次判断便<code>remove()</code>，就会出错。因此这里需要设置为<code>while</code>，从而到<code>wait()</code>下一行时，仍需判断，如果不为空，那么就不进入循环，直接<code>remove</code>就好；为空，那么再<code>wait()</code>。</p><p>当然，如果调用<code>remove</code>的只有一个线程，那么用<code>if</code>也不会出错。</p><h1 id="concurrent"><a href="#concurrent" class="headerlink" title="concurrent"></a>concurrent</h1><p><code>java.util.concurrent</code>包提供了许多并发相关功能实现。</p><h2 id="线程安全集合"><a href="#线程安全集合" class="headerlink" title="线程安全集合"></a>线程安全集合</h2><table><thead><tr><th align="left">interface</th><th align="left">non-thread-safe</th><th align="left">thread-safe</th></tr></thead><tbody><tr><td align="left">List</td><td align="left">ArrayList</td><td align="left">CopyOnWriteArrayList</td></tr><tr><td align="left">Map</td><td align="left">HashMap</td><td align="left">ConcurrentHashMap</td></tr><tr><td align="left">Set</td><td align="left">HashSet / TreeSet</td><td align="left">CopyOnWriteArraySet</td></tr><tr><td align="left">Queue</td><td align="left">ArrayDeque /  LinkedList</td><td align="left">ArrayBlockingQueue / LinkedBlockingQueue</td></tr><tr><td align="left">Deque</td><td align="left">ArrayDeque / LinkedList</td><td align="left">LinkedBlockingDeque</td></tr></tbody></table><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p><code>ReentrantLock</code>可以尝试获取锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，<code>tryLock()</code>返回<code>false</code>，程序就可以做一些额外处理，而不是无限等待下去。因此比直接使用<code>synchronized</code>更安全</p><h3 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h3><p>通过<code>Condition</code>，可以使用 <code> ReentrantLock</code>来实现<code>wait</code>和<code>notify</code>的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>await()</code>可以在等待指定时间后，如果还没有被其他线程通过<code>signal()</code>或<code>signalAll()</code>唤醒，可以自己醒来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition.await(<span class="number">1</span>, TimeUnit.SECOND)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p><code>ReadWriteLock</code>可以保证：</p><ul><li>只允许一个线程写入（其他线程既不能写入也不能读取）；</li><li>没有写入时，多个线程允许同时读（提高性能）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock rwlock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock rlock = rwlock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock wlock = rwlock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        wlock.lock(); <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            wlock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] get() &#123;</span><br><span class="line">        rlock.lock(); <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rlock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适合读多写少的场景。</p><h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p><strong>乐观锁：</strong>乐观地估计读的过程中大概率不会有写入，读的过程中也允许获取写锁后写入。这样需要一点额外的代码来判断读的过程中是否有写入。显然乐观锁并发程度更高。</p><p><strong>悲观锁：</strong>读的过程中拒绝有写入，也就是写入必须等待。</p><p><code>ReadWriteLock</code>是一种悲观锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead(); <span class="comment">// 获得一个乐观读锁，返回版本号</span></span><br><span class="line">        <span class="keyword">double</span> currentX = x;</span><br><span class="line">        <span class="keyword">double</span> currentY = y;</span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="comment">// 验证版本号，检查乐观读锁后是否有其他写锁发生</span></span><br><span class="line">            stamp = stampedLock.readLock(); <span class="comment">// 如果有写，获取一个悲观读锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StampedLock</code>把读锁细分为乐观读和悲观读，能进一步提升并发效率。</p><p>但<code>StampedLock</code>使不可重入的。</p><h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><p>使用<code>java.util.concurrent.atomic</code>提供的原子操作可以简化多线程编程：</p><ul><li>原子操作实现了无锁的线程安全；</li><li>适用于计数器，累加器等。</li></ul><p>以<code>AtomicInteger</code>为例，它提供的主要操作有：</p><ul><li>增加值并返回新值：<code>int addAndGet(int delta)</code></li><li>加1后返回新值：<code>int incrementAndGet()</code></li><li>获取当前值：<code>int get()</code></li><li>用CAS方式设置：<code>int compareAndSet(int expect, int update)</code></li></ul><p>Atomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了<code>CAS：Compare and Set</code>。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。</p><p>线程池内部维护了若干个线程，没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。线程池实现了线程的复用，效率更高。</p><p>Java标准库提供了<code>ExecutorService</code>接口表示线程池，典型用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建固定大小的线程池:</span></span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 提交任务:</span></span><br><span class="line">executor.submit(task1);</span><br><span class="line">executor.submit(task2);</span><br><span class="line"><span class="comment">// 关闭线程池:</span></span><br><span class="line">executor.shutdown();</span><br><span class="line"><span class="comment">// `shutdownNow()`会立刻停止正在执行的任务，`awaitTermination()`则会等待指定的时间让线程池关闭。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure><p><code>ExecutorService</code>只是接口，Java标准库提供的几个常用实现类有：</p><ul><li>FixedThreadPool：线程数固定的线程池；</li><li>CachedThreadPool：线程数根据任务动态调整的线程池；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> min = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">10</span>;</span><br><span class="line">ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(min, max,</span><br><span class="line">        <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure><ul><li>SingleThreadExecutor：仅单线程执行的线程池。</li></ul><h2 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h2><p>放入<code>ScheduledThreadPool</code>的任务可以定期反复执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 1秒后执行一次性任务:</span></span><br><span class="line">ses.schedule(<span class="keyword">new</span> Task(<span class="string">&quot;one-time&quot;</span>), <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 2秒后开始执行定时任务，每3秒执行:</span></span><br><span class="line">ses.scheduleAtFixedRate(<span class="keyword">new</span> Task(<span class="string">&quot;fixed-rate&quot;</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 2秒后开始执行定时任务，以3秒为间隔执行:</span></span><br><span class="line">ses.scheduleWithFixedDelay(<span class="keyword">new</span> Task(<span class="string">&quot;fixed-delay&quot;</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>FixedRate是指任务总是以固定时间间隔触发，不管任务执行多长时间；而FixedDelay是指，上一次任务执行完毕后，等待固定的时间间隔，再执行下一次任务。</p><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>通过实现<code>Runnable</code>接口编写的多线程没有返回值，如果任务需要返回结果，可以继承<code>Callable</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(d).setScale(<span class="number">2</span>, RoundingMode.DOWN);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对线程池提交一个<code>Callable</code>任务，可以获得一个<code>Future</code>对象。可以用<code>Future</code>在将来某个时刻获取结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">Future&lt;BigDecimal&gt; future = es.submit(<span class="keyword">new</span> Task());</span><br><span class="line"><span class="comment">// 从Future获取异步执行返回的结果:</span></span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure><p>在调用<code>get()</code>时，如果异步任务已经完成，我们就直接获得结果。如果异步任务还没有完成，那么<code>get()</code>会阻塞，直到任务完成后才返回结果。</p><p><code>Future&lt;V&gt;</code>接口定义的方法有：</p><ul><li><code>get()</code>：获取结果</li><li><code>get(long timeout, TimeUnit unit)</code>：获取结果，但只等待指定的时间；</li><li><code>cancel(boolean mayInterruptIfRunning)</code>：取消当前任务；</li><li><code>isDone()</code>：判断任务是否已完成。</li></ul><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p>通过<code>Future</code>获得异步执行的结果时，调用阻塞方法<code>get()</code>或轮询<code>isDone()</code>都会导致主线程被迫等待。</p><p><code>CompletableFuture</code>针对<code>Future</code>做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。主线程设置好回调后，不再关心异步任务的执行。</p><p>创建一个<code>CompletableFuture</code>是通过<code>CompletableFuture.supplyAsync()</code>实现的，它需要一个实现了<code>Supplier</code>接口的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>thenAccept()</code>处理正常结果；</li><li><code>exceptional()</code>处理异常结果；</li><li><code>thenApplyAsync()</code>用于串行化另一个<code>CompletableFuture</code>；</li><li><code>anyOf()</code>和<code>allOf()</code>用于并行化多个<code>CompletableFuture</code>。</li></ul><p><code>CompletableFuture</code>的命名规则为：</p><ul><li><code>xxx()</code>：表示该方法将继续在已有的线程中执行；</li><li><code>xxxAsync()</code>：表示将异步在线程池中执行。</li></ul><h2 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h2><p>Fork/Join是一种基于“分治”的算法：通过分解任务，并行执行，最后合并结果得到最终结果。</p><p>Fork/Join线程池可以把一个大任务拆成多个小任务并行执行，在多核CPU上就可以大大提高效率。任务类必须继承自<code>RecursiveTask</code>或<code>RecursiveAction</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 创建2000个随机数组成的数组:</span></span><br><span class="line"><span class="keyword">long</span>[] array = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2000</span>];</span><br><span class="line"><span class="keyword">long</span> expectedSum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">array[i] = random();</span><br><span class="line">expectedSum += array[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;Expected sum: &quot;</span> + expectedSum);</span><br><span class="line"><span class="comment">// fork/join:</span></span><br><span class="line">ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> SumTask(array, <span class="number">0</span>, array.length);</span><br><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">Long result = ForkJoinPool.commonPool().invoke(task);</span><br><span class="line"><span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;Fork/join sum: &quot;</span> + result + <span class="string">&quot; in &quot;</span> + (endTime - startTime) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> random.nextInt(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">long</span>[] array;</span><br><span class="line"><span class="keyword">int</span> start;</span><br><span class="line"><span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">SumTask(<span class="keyword">long</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line"><span class="keyword">this</span>.array = array;</span><br><span class="line"><span class="keyword">this</span>.start = start;</span><br><span class="line"><span class="keyword">this</span>.end = end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line"><span class="comment">// 如果任务足够小,直接计算:</span></span><br><span class="line"><span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">sum += <span class="keyword">this</span>.array[i];</span><br><span class="line"><span class="comment">// 故意放慢计算速度:</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务太大,一分为二:</span></span><br><span class="line"><span class="keyword">int</span> middle = (end + start) / <span class="number">2</span>;</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;split %d~%d ==&gt; %d~%d, %d~%d&quot;</span>, start, end, start, middle, middle, end));</span><br><span class="line">        <span class="comment">// “分裂”子任务:</span></span><br><span class="line">SumTask subtask1 = <span class="keyword">new</span> SumTask(<span class="keyword">this</span>.array, start, middle);</span><br><span class="line">SumTask subtask2 = <span class="keyword">new</span> SumTask(<span class="keyword">this</span>.array, middle, end);</span><br><span class="line">        <span class="comment">// invokeAll会并行运行两个子任务:</span></span><br><span class="line">invokeAll(subtask1, subtask2);</span><br><span class="line">Long subresult1 = subtask1.join();</span><br><span class="line">Long subresult2 = subtask2.join();</span><br><span class="line">Long result = subresult1 + subresult2;</span><br><span class="line">System.out.println(<span class="string">&quot;result = &quot;</span> + subresult1 + <span class="string">&quot; + &quot;</span> + subresult2 + <span class="string">&quot; ==&gt; &quot;</span> + result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><code>ThreadLocal</code>表示线程的“局部变量”，它确保每个线程的<code>ThreadLocal</code>变量都是各自独立的；</p><p><code>ThreadLocal</code>适合在一个线程的处理流程中保持上下文（避免了同一参数在所有方法中传递）；</p><p>初始化 &amp;&amp; 使用：（使用<code>ThreadLocal</code>要用<code>try ... finally</code>结构，并在<code>finally</code>中清除）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;User&gt; threadLocalUser = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processUser</span><span class="params">(user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        threadLocalUser.set(user);</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadLocalUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过设置一个<code>User</code>实例关联到<code>ThreadLocal</code>中，在移除之前，所有方法都可以随时获取到该<code>User</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">step1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User u = threadLocalUser.get();</span><br><span class="line">    log();</span><br><span class="line">    printUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果<code>ThreadLocal</code>没有被清除，该线程执行其他代码时，会把上一次的状态带进去。</p><p>为了保证能释放<code>ThreadLocal</code>关联的实例，我们可以通过<code>AutoCloseable</code>接口配合<code>try (resource) &#123;...&#125;</code>结构，让编译器自动为我们关闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContext</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; ctx = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserContext</span><span class="params">(String user)</span> </span>&#123;</span><br><span class="line">        ctx.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">currentUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ctx.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// use:</span></span><br><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> ctx = <span class="keyword">new</span> UserContext(<span class="string">&quot;Bob&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 可任意调用UserContext.currentUser():</span></span><br><span class="line">    String currentUser = UserContext.currentUser();</span><br><span class="line">&#125; <span class="comment">// 在此自动调用UserContext.close()方法释放ThreadLocal关联对象</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行&lt;code&gt;main()&lt;/code&gt;方法，在&lt;code&gt;main()&lt;/code&gt;方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
    <category term="java并发" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>「Java」泛型</title>
    <link href="http://yoursite.com/2021/06/28/Java/7-java-%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2021/06/28/Java/7-java-%E6%B3%9B%E5%9E%8B/</id>
    <published>2021-06-28T02:44:17.000Z</published>
    <updated>2021-07-03T14:51:46.785Z</updated>
    
    <content type="html"><![CDATA[<p>泛型即编写模板代码来适应任意类型。使用时不必对类型进行强制转换，并通过编译器对类型进行检查；</p><p>例如，编一个<code>Pair</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> K last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, K last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;Q&gt; <span class="function">Pair&lt;Q&gt; <span class="title">create</span><span class="params">(Q first, Q last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;Q&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，需要注意，静态泛型方法不能引用泛型类型，应该使用其他类型区分。</p><h2 id="擦拭法"><a href="#擦拭法" class="headerlink" title="擦拭法"></a>擦拭法</h2><p>不同语言的泛型实现方式不一定相同。Java语言的泛型实现方式是擦拭法（Type Erasure）。</p><p>即，虚拟机对泛型一无所知，所有的工作由编译器完成：</p><ul><li>编译器内部把类型<code>&lt;T&gt;</code>视为<code>Object</code>处理。</li><li>需要转型时，编译器根据<code>&lt;T&gt;</code>的类型自动实现安全的强制转型。</li></ul><p>因此，这也带来了几点局限性：</p><ol><li><p><code>&lt;T&gt;</code>不能是基本类型，例如<code>int</code>，因为实际类型是<code>Object</code>，<code>Object</code>类型无法持有基本类型</p></li><li><p>所有泛型实例，无论<code>T</code>的类型是什么，<code>getClass()</code>返回同一个<code>Class</code>实例，因为编译后它们全部都是<code>Pair&lt;Object&gt;</code>。</p><p>因此，<code>if (p instanceof Pair&lt;String&gt;)</code>也会编译错误。</p></li><li><p>不能实例化<code>T</code>类型。即<code>new T();</code>会编译错误。正确的实例化：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助Class&lt;T&gt;参数并通过反射来实例化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    first = clazz.newInstance();</span><br><span class="line">    last = clazz.newInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pair&lt;String&gt; pair = <span class="keyword">new</span> Pair&lt;&gt;(String.class);</span><br></pre></td></tr></table></figure><h2 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h2><p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Class&lt;IntPair&gt; clazz = IntPair.class;</span><br><span class="line">        Type t = clazz.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            ParameterizedType pt = (ParameterizedType) t;</span><br><span class="line">            Type[] types = pt.getActualTypeArguments(); <span class="comment">// 可能有多个泛型类型</span></span><br><span class="line">            Type firstType = types[<span class="number">0</span>]; <span class="comment">// 取第一个泛型类型</span></span><br><span class="line">            Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;</span><br><span class="line">            System.out.println(typeClass); <span class="comment">// Integer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntPair</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntPair</span><span class="params">(Integer first, Integer last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="extends通配符"><a href="#extends通配符" class="headerlink" title="extends通配符"></a>extends通配符</h2><p>使用类似<code>&lt;? extends Number&gt;</code>通配符作为方法参数时表示：</p><ul><li>方法内部可以调用获取<code>Number</code>引用的方法，例如：<code>Number n = obj.getFirst();</code>；</li><li>方法内部无法调用传入<code>Number</code>引用的方法（<code>null</code>除外），例如：<code>obj.setFirst(Number n);</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="keyword">int</span> n = add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// right</span></span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        <span class="comment">// wrong, 传入的p不一定是 Pair&lt;Integer&gt;</span></span><br><span class="line">        p.setFirst(<span class="keyword">new</span> Integer(first.intValue() + <span class="number">100</span>));</span><br><span class="line">        <span class="keyword">return</span> p.getFirst().intValue() + p.getFirst().intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，许多方法参数用到此种上界通配符，如<code>List&lt;? extends Integer&gt;</code>，通常也代表着该方法内部只会读取<code>List</code>的元素，不会修改<code>List</code>的元素。</p><p>使用类似<code>&lt;T extends Number&gt;</code>定义泛型类时表示：</p><ul><li>泛型类型限定为<code>Number</code>以及<code>Number</code>的子类。</li></ul><h2 id="super通配符"><a href="#super通配符" class="headerlink" title="super通配符"></a>super通配符</h2><p><code>Pair&lt;? super Integer&gt;</code>表示，方法参数接受所有泛型类型为<code>Integer</code>或<code>Integer</code>父类的<code>Pair</code>类型</p><p>使用下界通配符作为方法参数时表示：</p><ul><li>方法内部可以调用传入<code>Integer</code>引用的方法，例如：<code>obj.setFirst(Integer n);</code>；</li><li>方法内部无法调用获取<code>Integer</code>引用的方法（<code>Object</code>除外），例如：<code>Integer n = obj.getFirst();</code>。</li></ul><p>即使用<code>super</code>通配符表示只能写不能读。</p><p>Java标准库的<code>Collections</code>类定义的<code>copy()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把src的每个元素复制到dest中:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;src.size(); i++) &#123;</span><br><span class="line">            T t = src.get(i);</span><br><span class="line">            dest.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的定义就展示了<code>extends</code>和<code>super</code>的意图：方法内部不会读取<code>dest</code>，也不会修改<code>src</code>。</p><h2 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h2><p>既不能读，也不能写，只能做一些<code>null</code>判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNull</span><span class="params">(Pair&lt;?&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="keyword">null</span> || p.getLast() == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，<code>Pair&lt;?&gt;</code>是所有<code>Pair&lt;T&gt;</code>的超类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">Pair&lt;?&gt; p2 = p; <span class="comment">// 安全地向上转型</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;泛型即编写模板代码来适应任意类型。使用时不必对类型进行强制转换，并通过编译器对类型进行检查；&lt;/p&gt;
&lt;p&gt;例如，编一个&lt;code&gt;Pair&lt;/code&gt;类：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>「Java」注解</title>
    <link href="http://yoursite.com/2021/06/27/Java/6-java-%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2021/06/27/Java/6-java-%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-06-27T02:44:17.000Z</published>
    <updated>2021-06-28T08:05:34.010Z</updated>
    
    <content type="html"><![CDATA[<p>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”，是Java语言用于工具处理的标注，比如常用的<code>@Override</code></p><p>Java的注解可以分为三类：</p><ul><li><p>第一类是由编译器使用的注解，例如：</p><ul><li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li><li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li></ul><p>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</p></li><li><p>第二类是由工具处理<code>.class</code>文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p></li><li><p>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p></li></ul><p>注解可以配置参数，没有指定配置的参数使用默认值；如果参数名称是<code>value</code>，且只有一个参数，那么可以省略参数名称。</p><h1 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h1><ol><li>用<code>@interface</code>语法来定义注解（<code>Annotation</code>）。</li><li>添加参数、默认值，把最常用的参数定义为<code>value()</code>。</li><li>用元注解配置注解，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">    ElementType.TYPE,</span></span><br><span class="line"><span class="meta">    ElementType.METHOD,</span></span><br><span class="line"><span class="meta">    ElementType.FIELD</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>有一些注解可以修饰其他注解，这些注解就称为元注解</p><h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p><ul><li>类或接口：<code>ElementType.TYPE</code>；</li><li>字段：<code>ElementType.FIELD</code>；</li><li>…</li></ul><h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p>定义了<code>Annotation</code>的生命周期：</p><ul><li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li><li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li><li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li></ul><h3 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h3><p>使用<code>@Repeatable</code>这个元注解可以定义<code>Annotation</code>是否可重复。</p><p>自定义注解经过<code>@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个此注解</p><h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p>使用<code>@Inherited</code>定义子类是否可继承父类定义的<code>Annotation</code>。<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效</p><h1 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h1><p><code>SOURCE</code>类型的注解主要由编译器使用，因此我们一般只使用，不编写。<code>CLASS</code>类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有<code>RUNTIME</code>类型的注解不但要使用，还经常需要编写。</p><p>读取注解，需要使用反射API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Person.class;</span><br><span class="line"><span class="comment">// 判断@Report是否存在于Person类</span></span><br><span class="line"><span class="keyword">if</span> (cls.isAnnotationPresent(Report.class)) &#123;</span><br><span class="line">    Report report = cls.getAnnotation(Report.class);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">Report report = cls.getAnnotation(Report.class);</span><br><span class="line"><span class="keyword">if</span> (report != <span class="keyword">null</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取方法参数的<code>Annotation</code>需要多考虑一些，方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，一次获取方法参数的所有注解就必须用一个二维数组来表示，例如下述方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="meta">@NotNull</span> <span class="meta">@Range(max=5)</span> String name, <span class="meta">@NotNull</span> String prefix)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Method实例:</span></span><br><span class="line">Method m = ...</span><br><span class="line"><span class="comment">// 获取所有参数的Annotation:</span></span><br><span class="line">Annotation[][] annos = m.getParameterAnnotations();</span><br><span class="line"><span class="comment">// 第一个参数（索引为0）的所有Annotation:</span></span><br><span class="line">Annotation[] annosOfName = annos[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (Annotation anno : annosOfName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> Range) &#123; <span class="comment">// @Range注解</span></span><br><span class="line">        Range r = (Range) anno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> NotNull) &#123; <span class="comment">// @NotNull注解</span></span><br><span class="line">        NotNull n = (NotNull) anno;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。</p><p>例：一个<code>Person</code>实例<code>Filed</code>字段的检查方法，检查其是否满足<code>@Range</code>的定义。如果字段类型是<code>String</code>，就检查<code>String</code>的长度，如果字段是<code>int</code>，就检查<code>int</code>的范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(Person person)</span> <span class="keyword">throws</span> IllegalArgumentException, ReflectiveOperationException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class="line">        Range range = field.getAnnotation(Range.class);</span><br><span class="line">        <span class="keyword">if</span> (range != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object value = field.get(person);</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String temp = (String) value;</span><br><span class="line">                <span class="keyword">if</span> (temp.length() &lt; range.min() || temp.length() &gt; range.max()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid field: &quot;</span> + field.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">                Integer temp = (Integer) value;</span><br><span class="line">                <span class="keyword">if</span> (temp &lt; range.min() || temp &gt; range.max()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid field: &quot;</span> + field.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Range(min = 1, max = 20)</span></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Range(min = 1, max = 100)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><code>Range</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> <span class="keyword">default</span> 255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，我们通过<code>@Range</code>注解，配合<code>check()</code>方法，就可以完成<code>Person</code>实例的检查。相比于在构造方法里写n个判断，用注解更加直观，只需要在每个成员前加上注解，然后写一个检查方法就可以检查所有的成员是否满足条件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”，是Java语言用于工具处理的标注，比如常用的&lt;code&gt;@Override&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Java的注解可以分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一类是由编译器使用的注解，例如：&lt;/p&gt;</summary>
      
    
    
    
    <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>「Java」反射</title>
    <link href="http://yoursite.com/2021/06/21/Java/5-java-%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2021/06/21/Java/5-java-%E5%8F%8D%E5%B0%84/</id>
    <published>2021-06-21T14:44:17.000Z</published>
    <updated>2021-06-27T09:38:41.283Z</updated>
    
    <content type="html"><![CDATA[<p>通过<code>Class</code>实例获取<code>class</code>信息的方法称为反射。通过反射，即便我们对某个实例一无所知，但仍可以在程序运行期间获取该对象的所有信息。</p><h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><p>在java中，除了<code>int</code>等基本类型，其他类型均为<code>class</code>（包括<code>interface</code>）。而<code>class</code>是由JVM在执行过程中动态加载的。（动态加载：JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载）</p><p>JVM在第一次读取到一种<code>class</code>类型时，将其加载进内存。每加载一种<code>class</code>，JVM就为其创建一个<code>Class</code>类型的实例，这个实例就包含了该class的所有信息（<code>name</code>、<code>package</code>、<code>super</code>、<code>field</code>、<code>method</code>…）。当编译一个新类时，会产生一个同名的 <code>.class</code> 文件，该文件内容保存着 Class 对象。</p><p>注意<code>Class</code>类的构造方法是<code>private</code>，只有JVM能创建<code>Class</code>实例，我们自己的Java程序无法创建。</p><p>那么如何<strong>获取<code>class</code>实例</strong>？</p><ul><li>通过一个<code>class</code>的静态变量<code>class</code>获取：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = String.class;</span><br></pre></td></tr></table></figure><ul><li>通过实例变量提供的<code>getClass()</code>方法获取：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Class cls = s.getClass();</span><br></pre></td></tr></table></figure><ul><li>根据完整类名获取：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure><p>此外，JVM为每一种基本类型如<code>int</code>也创建了<code>Class</code>，通过<code>int.class</code>访问。数组（例如<code>String[]</code>）也是一种<code>Class</code>，它的类名是<code>[Ljava.lang.String</code>。</p><p>获取<code>Class</code>实例之后，也可以通过该实例创建对应类型的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class cls = String.class;</span><br><span class="line">String s = (String) cls.newInstance();</span><br></pre></td></tr></table></figure><p><strong>获取父类Class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class n = Integer.class.getSuperclass();<span class="comment">// class java.lang.Number</span></span><br></pre></td></tr></table></figure><p><strong>获取实现的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class[] is = Integer.class.getInterfaces();</span><br><span class="line"><span class="comment">// [ java.lang.Comparable, java.lang.constant.Constable,  java.lang.constant.ConstantDesc ]</span></span><br></pre></td></tr></table></figure><p>注意并不包括其父类实现的接口类型</p><p>获取接口的父接口要用<code>getInterfaces()</code>，而不是<code>getSuperclass()</code></p><p><strong>判断继承关系</strong></p><p>对两个<code>Class</code>实例，要判断一个向上转型是否成立，可以调用<code>isAssignableFrom()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line">Object.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Object</span></span><br></pre></td></tr></table></figure><p>Class 和 <code>java.lang.reflect </code> 一起对反射提供了支持，<code>java.lang.reflect</code> 类库主要包含了<code>Field</code>、<code>Method</code>、<code>Constructor</code></p><h2 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h2><p><strong>通过<code>Class</code>实例获取<code>Field</code>实例：</strong></p><ul><li><code>Field getField(name)</code>：根据字段名获取某个public的field（包括父类）</li><li><code>Field getDeclaredField(name)</code>：根据字段名获取当前类的某个field（不包括父类）</li><li><code>Field[] getFields()</code>：获取所有public的field（包括父类）</li><li><code>Field[] getDeclaredFields()</code>：获取当前类的所有field（不包括父类）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class stdClass = Student.class;</span><br><span class="line">System.out.println(stdClass.getDeclaredField(<span class="string">&quot;grade&quot;</span>));</span><br><span class="line"><span class="comment">// private int Student.grade</span></span><br></pre></td></tr></table></figure><p><strong>通过Field实例可以获取字段信息：</strong></p><ul><li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li><li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li><li><code>getModifiers()</code>：返回字段的修饰符，是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field f = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> m = f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true or false</span></span><br></pre></td></tr></table></figure><p><strong>通过Field实例读取/设置某个对象的字段：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object p = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">Field f = p.getClass().getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">Object value = f.get(p);<span class="comment">// &quot;Xiao Ming&quot;</span></span><br></pre></td></tr></table></figure><p>如果因为修饰符为<code>private</code>或<code>protected</code>而不能访问，需要先设置为<code>f.setAccessible(true);</code></p><p>设置字段值通过<code>Field.set(Object, Object)</code>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.set(p, <span class="string">&quot;Xiao Hong&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h2><p>类似的，</p><p><strong>获取<code>Method</code>实例：</strong></p><ul><li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li><li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li></ul><p><strong>通过<code>Method</code>对象查看一个方法的所有信息：</strong></p><ul><li><p>比<code>Field</code>多了一个：</p><p><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</p></li></ul><p><strong>调用方法：</strong></p><ul><li><p>普通方法，例如<code>s.substring(6);</code>，可以<code>(String) m.invoke(s, 6);</code></p></li><li><p>静态方法，如<code>Integer.parseInt(&quot;1234&quot;)</code>，可以<code>(Integer) m.invoke(null, &quot;1234&quot;);</code></p></li><li><p>非public方法，需要设置<code>Method.setAccessible(true)</code>允许其调用</p></li></ul><p><strong>多态：</strong></p><p>反射调用也遵循多态，即总是调用实际类型的覆写方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> ...</span></span><br><span class="line"><span class="class"><span class="title">Method</span> <span class="title">m</span> </span>= Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">m.invoke(<span class="keyword">new</span> Student());</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 相当于 ---</span></span><br><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">p.hello();</span><br></pre></td></tr></table></figure><h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><p>调用类的public无参数构造方法创建实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = Person.class.newInstance();</span><br></pre></td></tr></table></figure><p>而通过获取Constructor对象，就可以调用任意构造方法。</p><p><strong>获取Constructor的方法</strong>：</p><ul><li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>，括号内为参数；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li><li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li></ul><p>调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor cons1 = Integer.class.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">Integer n1 = (Integer) cons1.newInstance(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>反射是一种非常规的用法，会破坏对象的封装。使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。</p><p>此外，<code>setAccessible(true)</code>可能会失败。如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p><strong>优点：</strong></p><ul><li><strong>可扩展性</strong> ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li><li><strong>类浏览器和可视化开发环境</strong> ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</li><li><strong>调试器和测试工具</strong> ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>性能开销</strong> ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</li><li><strong>安全限制</strong> ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</li><li><strong>内部暴露</strong> ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</li></ul><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>动态代理（Dynamic Proxy）机制：可以在运行期动态创建某个<code>interface</code>的实例。</p><p>看个例子吧，身为一个coder，我们要会<code>code</code>，也要会<code>debug</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Developer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而程序员有很多种呀，Java程序员，C++程序员，摸鱼程序员，带薪拉*的程序员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDeveloper</span> <span class="keyword">implements</span> <span class="title">Developer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaDeveloper</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is coding Java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is debugging Java code&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如现在有上千个实现类，忽然有一个需求，每当一个行为产生时（调用了方法），要给coder们的行为做记录来决定年底奖金，code和debug的时候可以加kpi，摸鱼就不能加。怎么办呢，要我们在这么多实现类的接口方法中一个一个去加纪录代码吗？除了删库跑路，我们还有一种选择：动态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JavaDeveloper p1 = <span class="keyword">new</span> JavaDeveloper(<span class="string">&quot;p1&quot;</span>);</span><br><span class="line"></span><br><span class="line">Developer p1Proxy = (Developer) Proxy.newProxyInstance(p1.getClass().getClassLoader(),</span><br><span class="line">        p1.getClass().getInterfaces(), ((proxy, method, args1) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;code&quot;</span>)) &#123;</span><br><span class="line">                method.invoke(p1, args);</span><br><span class="line">                System.out.println(<span class="string">&quot;今天没有摸鱼!kpi++&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;debug&quot;</span>)) &#123;</span><br><span class="line">                method.invoke(p1, args);</span><br><span class="line">                System.out.println(<span class="string">&quot;Shit mountain 变得更漂亮了一点!kpi++&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;));</span><br><span class="line">p1Proxy.code();</span><br><span class="line">p1Proxy.debug();</span><br></pre></td></tr></table></figure><p>通过<code>Proxy</code>创建代理对象，然后将接口方法“代理”给<code>InvocationHandler</code>完成：</p><ol><li><p>定义一个<code>InvocationHandler</code>实例，它负责实现接口的方法调用；</p></li><li><p>通过<code>Proxy.newProxyInstance()</code> 创建<code>interface</code>实例，它需要3个参数：</p><ol><li>使用的<code>ClassLoader</code>，通常就是接口类的<code>ClassLoader</code>；</li><li>需要实现的接口数组，至少需要传入一个接口进去；</li><li>用来处理接口方法调用的<code>InvocationHandler</code>实例。</li></ol></li><li><p>将返回的<code>Object</code>强制转型为接口。</p></li></ol><p>动态代理实际上是JVM在运行期动态创建class字节码并加载的过程。</p><h2 id="Proxy-newProxyInstance"><a href="#Proxy-newProxyInstance" class="headerlink" title="Proxy.newProxyInstance()"></a>Proxy.newProxyInstance()</h2><p>通常我们先生成一个实例对象，然后用Proxy的newInstance方法对这个实例对象代理生成一个代理对象。这是代理模式思想的体现，可以回顾下设计模式那块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span> </span>&#123;</span><br></pre></td></tr></table></figure><blockquote><p>ClassLoader是负责加载类的对象，如果给定类的二进制名称，那么类加载器会试图查找或生成构成类定义的效据：一般策略是将名称转换为某个文件名，然后从文件系统读取该名称的“类文件”。</p><p>每个 Class 对象都包含一个对定义它的 ClassLoader 的引用。</p><p>应用程序需要实现Classloader的子类，以扩展Java虚拟机动态加载类的方式。</p></blockquote><p>loder和interfaces基本就是决定了这个类到底是个怎么样的类。</p><h2 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h2><p><code>InvocationHandler</code>作用就是，当代理对象的原本方法被调用的时候，会绑定执行一个方法，这个方法就是<code>InvocationHandler</code>里面定义的内容，同时会替代原本方法的结果返回。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在Spring项目中用的注解，例如依赖注入的@Bean、@Autowired，事务注解@Transactional等都有用到，换言之就是Srping的AOP（切面编程）。</p><p>这种场景的使用是动态代理最佳的落地点，可以非常灵活地在某个类，某个方法，某个代码点上切入我们想要的内容，就是动态代理其中的内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通过&lt;code&gt;Class&lt;/code&gt;实例获取&lt;code&gt;class&lt;/code&gt;信息的方法称为反射。通过反射，即便我们对某个实例一无所知，但仍可以在程序运行期间获取该对象的所有信息。&lt;/p&gt;
&lt;h1 id=&quot;Class类&quot;&gt;&lt;a href=&quot;#Class类&quot; class</summary>
      
    
    
    
    <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>「selenium」基础</title>
    <link href="http://yoursite.com/2021/06/02/Selenium/Selenium-0/"/>
    <id>http://yoursite.com/2021/06/02/Selenium/Selenium-0/</id>
    <published>2021-06-01T16:21:22.000Z</published>
    <updated>2021-06-02T15:07:26.553Z</updated>
    
    <content type="html"><![CDATA[<p>Selenium是一个用于Web应用程序测试的工具。</p><p>Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE（7, 8, 9, 10, 11），Firefox，Safari，Chrome，Opera等。</p><p>这个工具的主要功能包括：测试与浏览器的兼容性——测试你的应用程序看是否能够很好得工作在不同浏览器和操作系统之上。测试系统功能——创建回归测试检验软件功能和用户需求。</p><p>而用在爬虫上则是模拟正常用户访问网页并获取数据。</p><p>这里记录<code>Selenium2</code>的基础知识。</p><h1 id="Pre"><a href="#Pre" class="headerlink" title="Pre"></a>Pre</h1><p>安装chromedriver &amp;&amp; selenium 库</p><p>一个简单的实例：</p><p>打开百度首页，在输入框中输入python，点击搜索</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开一个Chrome浏览器</span></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 请求百度首页</span></span><br><span class="line">browser.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="comment"># 找到输入框位置</span></span><br><span class="line"><span class="built_in">input</span> = WebDriverWait(browser, <span class="number">10</span>).until(</span><br><span class="line">                EC.presence_of_element_located((By.XPATH, <span class="string">&#x27;//*[@id=&quot;kw&quot;]&#x27;</span>))</span><br><span class="line">            )</span><br><span class="line"><span class="comment"># 在输入框中输入Python</span></span><br><span class="line"><span class="built_in">input</span>.send_keys(<span class="string">&#x27;Python&#x27;</span>)</span><br><span class="line"><span class="comment"># 找到输入按钮</span></span><br><span class="line">button = WebDriverWait(browser, <span class="number">10</span>).until(</span><br><span class="line">                EC.element_to_be_clickable(</span><br><span class="line">                    (By.XPATH, <span class="string">&#x27;//*[@id=&quot;su&quot;]&#x27;</span>))</span><br><span class="line">            )</span><br><span class="line"><span class="comment"># 点击一次输入按钮</span></span><br><span class="line">button.click()</span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure><h1 id="Chrome启动选项"><a href="#Chrome启动选项" class="headerlink" title="Chrome启动选项"></a>Chrome启动选项</h1><p>在<code>Selenium</code>中使用不同的<code>Webdriver</code>可能会有不一样的方法，有些相同的操作会得到不一样的结果，这里记录的是<code>Chrome()</code>的使用方法。</p><h2 id="Chrome-Options"><a href="#Chrome-Options" class="headerlink" title="Chrome Options"></a>Chrome Options</h2><p>一个Chrome的参数对象，在此对象中使用<code>add_argument()</code>方法可以添加启动参数，添加完毕后可以在初始化Webdriver对象时将此Options对象传入，则可以实现以特定参数启动Chrome。</p><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个启动参数对象</span></span><br><span class="line">chrome_options = Options()</span><br><span class="line"><span class="comment"># 添加启动参数</span></span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--window-size=1366,768&#x27;</span>)</span><br><span class="line"><span class="comment"># 将参数对象传入Chrome，则启动了一个设置了窗口大小的Chrome</span></span><br><span class="line">browser = webdriver.Chrome(chrome_options=chrome_options)</span><br></pre></td></tr></table></figure><p><strong>常用启动参数：</strong></p><table><thead><tr><th align="center">启动参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">–user-agent=””</td><td align="center">设置请求头的User-Agent</td></tr><tr><td align="center">–window-size=1366,768</td><td align="center">设置浏览器分辨率</td></tr><tr><td align="center">–headless</td><td align="center">无界面运行</td></tr><tr><td align="center">–start-maximized</td><td align="center">最大化运行</td></tr><tr><td align="center">–incognito</td><td align="center">隐身模式</td></tr><tr><td align="center">–disable-javascript</td><td align="center">禁用javascript</td></tr><tr><td align="center">–disable-infobars</td><td align="center">禁用浏览器正在被自动化程序控制的提示</td></tr></tbody></table><p><a href="https://peter.sh/experiments/chromium-command-line-switches/">https://peter.sh/experiments/chromium-command-line-switches/</a></p><p><strong>禁用图片加载</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prefs = &#123;</span><br><span class="line">    <span class="string">&#x27;profile.default_content_setting_values&#x27;</span> : &#123;</span><br><span class="line">        <span class="string">&#x27;images&#x27;</span> : <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;prefs&#x27;</span>,prefs)</span><br></pre></td></tr></table></figure><p><strong>禁用浏览器弹窗</strong></p><p>使用浏览器时常常会有弹窗弹出，以下选项可以禁止弹窗：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prefs = &#123;  </span><br><span class="line">    <span class="string">&#x27;profile.default_content_setting_values&#x27;</span> :  &#123;  </span><br><span class="line">        <span class="string">&#x27;notifications&#x27;</span> : <span class="number">2</span>  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;prefs&#x27;</span>,prefs)</span><br></pre></td></tr></table></figure><h2 id="Chrome-WebDriver"><a href="#Chrome-WebDriver" class="headerlink" title="Chrome WebDriver"></a>Chrome WebDriver</h2><h3 id="指定chromedriver-exe的位置"><a href="#指定chromedriver-exe的位置" class="headerlink" title="指定chromedriver.exe的位置"></a>指定chromedriver.exe的位置</h3><p>chromedriver.exe一般可以放在环境文件中，但是有时候为了方便部署项目，或者为了容易打包，我们可以将chromedriver.exe放到我们的项目目录中，然后在初始化Chrome Webdriver对象时，传入chromedriver.exe的路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome(executable_path=<span class="string">&#x27;chromedriver.exe&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="Remote-Webdriver"><a href="#Remote-Webdriver" class="headerlink" title="Remote Webdriver"></a>Remote Webdriver</h1><p><code>selenium.webdriver.remote.webdriver.WebDriver</code> 这个类其实是所有其他Webdriver的父类，例如<code>Chrome Webdriver</code>，<code>Firefox Webdriver</code>都是继承自这个类。这个类中实现了每个Webdriver间相通的方法。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Selenium是一个用于Web应用程序测试的工具。&lt;/p&gt;
&lt;p&gt;Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE（7, 8, 9, 10, 11），Firefox，Safari，Chrome，Opera等。&lt;/p&gt;
&lt;p&gt;这个工具的</summary>
      
    
    
    
    <category term="selenium" scheme="http://yoursite.com/categories/selenium/"/>
    
    
    <category term="selenium" scheme="http://yoursite.com/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>「OS」文件管理（磁盘组织与管理）</title>
    <link href="http://yoursite.com/2021/06/01/OperatingSystem/OS-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86-%E7%A3%81%E7%9B%98/"/>
    <id>http://yoursite.com/2021/06/01/OperatingSystem/OS-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86-%E7%A3%81%E7%9B%98/</id>
    <published>2021-06-01T07:07:00.000Z</published>
    <updated>2021-06-03T15:55:44.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h1><h2 id="磁盘-磁道-扇区"><a href="#磁盘-磁道-扇区" class="headerlink" title="磁盘/磁道/扇区"></a>磁盘/磁道/扇区</h2><p><img src="https://pic.imgdb.cn/item/60b7aaea39f6859bc2a5e0d7.png"></p><h2 id="盘面-柱面-物理地址"><a href="#盘面-柱面-物理地址" class="headerlink" title="盘面/柱面/物理地址"></a>盘面/柱面/物理地址</h2><p><img src="https://pic.imgdb.cn/item/60b7ab3039f6859bc2a99ef1.png"></p><h2 id="磁盘分类"><a href="#磁盘分类" class="headerlink" title="磁盘分类"></a>磁盘分类</h2><p><img src="https://pic.imgdb.cn/item/60b7ab4039f6859bc2aa5a6d.png"></p><p><img src="https://pic.imgdb.cn/item/60b7ab4d39f6859bc2aae476.png"></p><h1 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h1><h2 id="读写时间"><a href="#读写时间" class="headerlink" title="读写时间"></a>读写时间</h2><p><img src="https://pic.imgdb.cn/item/60b8eed78355f7f718dbe59e.png"></p><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p><strong>先来先服务(FCFS)</strong></p><p>根据进程请求访问磁盘的先后顺序调度 </p><p>公平；如果大量进程访问的磁道很分散，效率会很差</p><p><strong>最短寻道时间优先(SSTF)</strong></p><p>优先处理当前磁头最近的磁道，保证寻道时间最短（眼前最优，未必整体最优） </p><p>性能较好，但是可能产生饥饿现象（离磁头远的请求长时间得不到满足）</p><p><strong>扫描算法(SCAN)</strong></p><p>又叫电梯算法，在SSTF算法的基础上，规定磁头只有移动到磁道尽头（最外侧或者最内侧）才能往回移动 </p><p>性能较好，不会饥饿；但是只能扫描到最边上的磁道才能改变磁头方向，越外侧的的磁道，响应频率越高</p><p><strong>LOOK调度算法</strong></p><p>改进SCAN算法，磁头边移动边观察(LOOK)，如果移动方向没有请求了，就不必继续扫描，直接调头</p><p><strong>循环扫描算法(C-SCAN)</strong></p><p>只有磁头朝着某个方向移动（比如磁道号增大方向）时才处理访问请求，移动到最边上后直接返回到另一边（0号磁道），返回途中不处理请求 </p><p>相比SACN算法，各个位置的磁道响应频率很平均</p><p><strong>C-LOOK算法</strong></p><p>改进C-SCAN算法，磁头移动方向上如果没有请求了，就直接返回到最靠近另一侧边缘的请求磁道即可</p><h1 id="减少磁盘延时"><a href="#减少磁盘延时" class="headerlink" title="减少磁盘延时"></a>减少磁盘延时</h1><p><strong>交替编号</strong></p><p>一个盘面上，让逻辑相邻的扇区在物理上有一定间隔，使读取连续逻辑扇区所需的延迟时间更小 </p><p>（如果没有间隔，读入N号扇区时数据时需要一些时间处理，导致错过N+1号扇区，磁盘需要再转一圈才能读到N+1）</p><p><strong>磁盘物理地址设计</strong></p><p><img src="https://pic.imgdb.cn/item/60b8f0788355f7f7180705b4.png"></p><p><img src="https://pic.imgdb.cn/item/60b8f0848355f7f71808065e.png"></p><p><strong>错位命名</strong></p><p><img src="https://pic.imgdb.cn/item/60b8f0b88355f7f7180d23b2.png"></p><p><img src="https://pic.imgdb.cn/item/60b8f0c18355f7f7180e1551.png"></p><h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><h2 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h2><p><img src="https://pic.imgdb.cn/item/60b8fb268355f7f718eac3dc.png"></p><h2 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h2><p><img src="https://pic.imgdb.cn/item/60b8fb578355f7f718edea89.png"></p><h2 id="坏块管理"><a href="#坏块管理" class="headerlink" title="坏块管理"></a>坏块管理</h2><p><img src="https://pic.imgdb.cn/item/60b8fb7c8355f7f718f0325a.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;磁盘结构&quot;&gt;&lt;a href=&quot;#磁盘结构&quot; class=&quot;headerlink&quot; title=&quot;磁盘结构&quot;&gt;&lt;/a&gt;磁盘结构&lt;/h1&gt;&lt;h2 id=&quot;磁盘-磁道-扇区&quot;&gt;&lt;a href=&quot;#磁盘-磁道-扇区&quot; class=&quot;headerlink&quot; title=&quot;磁</summary>
      
    
    
    
    <category term="OperatingSystem" scheme="http://yoursite.com/categories/OperatingSystem/"/>
    
    
    <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>「OS」文件管理（文件系统）</title>
    <link href="http://yoursite.com/2021/05/26/OperatingSystem/OS_%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2021/05/26/OperatingSystem/OS_%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</id>
    <published>2021-05-26T07:07:00.000Z</published>
    <updated>2021-06-02T05:53:57.569Z</updated>
    
    <content type="html"><![CDATA[<p>文件就是一组有意义的信息/数据的集合</p><h1 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h1><ul><li>文件名<br>  主要是给用户看，同一个目录下不允许重名文件</li><li>标识符<br>  一个系统内各文件标识符唯一，对用户毫无可读性，给操作系统看的</li><li>类型<br>  文件扩展名</li><li>位置<br>  文件存放路径，给用户看的；外存中的存放地址，操作系统可见</li><li>大小</li><li>创建时间</li><li>上次修改/访问时间</li><li>所有者信息</li><li>保护信息</li></ul><h1 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h1><h2 id="什么是逻辑结构"><a href="#什么是逻辑结构" class="headerlink" title="什么是逻辑结构"></a>什么是逻辑结构</h2><p>逻辑结构：在用户看来，文件内部的数据是如何组织起来</p><p>物理结构：操作系统看来，文件的数据如何存放在外存中</p><h2 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h2><p>又叫流式文件，比如<code>.txt</code>，文件内部的数据由一些二进制或者字符流组成</p><h2 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h2><p>又叫记录式文件，比如数据库表，由一组相似的记录组成<br>​记录是一组相关数据项的集合，每条记录有一个数据项可作为关键字<br>根据各条记录的长度是否相等，分为：定长记录，可变长记录</p><h3 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h3><p>文件中的记录顺序排列（逻辑上），记录可以定长或可变长。各记录在物理上可以顺序存储或链式存储</p><p><strong>链式存储</strong>：</p><p>逻辑上相邻的记录，在物理上离散存储。<br>​无论是定长/可变长记录，都无法实现随机存取，只能从链头开始遍历</p><p><strong>顺序存储</strong>：</p><p>逻辑上相邻的记录，在物理上也相邻。<br>没有说明的情况下，顺序文件指采用顺序存储的顺序文件</p><ul><li><p>可变长记录</p><p>  无法实现随机存取</p></li><li><p>定长记录</p><p>  可以实现随机存储。</p><p>  如果采用串结构(记录顺序与关键字无关)，无法快速找到某个关键字对应的记录，如果采用顺序结构(记录按关键字排序的)，可以使用折半查找等方法快速找到记录</p></li></ul><h3 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h3><p>索引表本身是定长记录的顺序文件，索引表项包含索引号，长度，指针，真正的记录可以在物理上离散存储。<br>可以用不同的数据项建立多个索引表</p><h3 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h3><p>将记录分组，每一个组对应一个索引表项<br>检索记录时先顺序检索索引表，找到分组，再顺序查找分组查找记录<br>记录过多时，可以建立多级索引表。<small>例如，对于一个含$10^6$个记录的文件，可先为该文件建立一张低级索引表，每100个记录为一组，故低级索引表中共有10000个表项（即10000个定长记录），再把这10000个定长记录分组，每组100个，为其建立顶级索引表，故顶级索引表中共有100个表项。平均查找 150 次</small></p><h1 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h1><p><img src="https://pic.imgdb.cn/item/60af0ae608f74bc1590e63c3.jpg"><br>目录文件中的一条记录就是一个文件控制块（FCB），一个文件对应一个 FCB，一个FCB就是一个目录项，FCB的有序集合叫“文件目录”<br>FCB包含了文件的基本信息，存取控制信息，使用信息等等。<br> FCB 实现了文件名和文件之间的映射。<br>对目录的操作:搜索、创建文件、删除文件、显示文件、修改文件</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><strong>单级目录结构</strong>：<br><img src="https://pic.imgdb.cn/item/60af0ccd08f74bc15920f962.png"><br><strong>二级目录结构</strong>：<br><img src="https://pic.imgdb.cn/item/60af13ba08f74bc159620f16.png"><br><strong>多级（树形）目录结构</strong>：<br><img src="https://pic.imgdb.cn/item/60af14d408f74bc1596be485.png"><br>通过引入”当前目录”和”相对路径”，可以减少磁盘的 I/O 次数，提升访问文件的效率。<br><strong>无环图目录结构</strong>：<br><img src="https://pic.imgdb.cn/item/60af167708f74bc1597aaf92.png"></p><h2 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h2><p>索引节点是对 FCB 的改进，使每个目录项长度减小，从而每个磁盘块可以存放更多目录项，减少检索文件时的磁盘 I/O 次数。<br><img src="https://pic.imgdb.cn/item/60af17cf08f74bc159863f5f.png"></p><h1 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h1><h2 id="文件块-物理块"><a href="#文件块-物理块" class="headerlink" title="文件块/物理块"></a>文件块/物理块</h2><p><img src="https://pic.imgdb.cn/item/60b22fa808f74bc159d56027.png"></p><h2 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h2><p>优点：支持随机访问；顺序访问时速度最快（移动磁头所需的时间短）<br>缺点：不方便文件扩展，每次扩展都得迁移到一段连续的空间，代价大；存储空间利用率低，产生磁盘碎片</p><h2 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h2><p>链接分配采取离散分配方式，可以为文件分配离散的磁盘块。</p><h3 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h3><p>除文件最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块指针和最后一块指针。</p><p>方便拓展，磁盘利用率高</p><p>不支持随机访问，查找效率低</p><h3 id="显式链接"><a href="#显式链接" class="headerlink" title="显式链接"></a>显式链接</h3><p>把用于链接文件各物理块的指针显式存在一张表中，即文件分配表（FAT）。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。</p><p><img src="https://pic.imgdb.cn/item/60b24c6708f74bc15945d68e.png"></p><p>方便拓展，磁盘利用率高。支持随机访问，相比隐式链接，地址转换无需访问磁盘，文件访问效率更高。</p><p>文件分配表需要占用存储空间。</p><h2 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h2><p>每一个文件建立一张索引表，其中记录文件的逻辑块对应的物理块。存放索引表的磁盘块叫索引块，存放文件数据的磁盘块叫数据块。</p><p>注：文件分配表是一个磁盘对应一张，而索引表是一个文件对应一张。</p><p><img src="https://pic.imgdb.cn/item/60b25cbe08f74bc15966ca02.jpg"></p><p>如果索引表太大，一个索引块装不下，我们可以：</p><ol><li>链接方案：在前一个块中存指向下一个块的指针。</li><li>多层索引：类似多级页表</li></ol><p><img src="https://pic.imgdb.cn/item/60b261d708f74bc159b92997.jpg"></p><ol start="3"><li>混合索引：多种索引分配方式的结合</li></ol><p><img src="https://pic.imgdb.cn/item/60b262b708f74bc159c74767.jpg"></p><h1 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h1><h2 id="存储空间划分与初始化"><a href="#存储空间划分与初始化" class="headerlink" title="存储空间划分与初始化"></a>存储空间划分与初始化</h2><p><img src="https://pic.imgdb.cn/item/60b317d408f74bc159d1d76b.jpg"></p><h2 id="存储空间管理"><a href="#存储空间管理" class="headerlink" title="存储空间管理"></a>存储空间管理</h2><h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><p><img src="https://pic.imgdb.cn/item/60b319f408f74bc159f0a1e6.jpg"></p><h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><p><strong>空闲盘块链</strong></p><p><img src="https://pic.imgdb.cn/item/60b32bac39f6859bc21086a6.png"></p><p><strong>空闲盘区链</strong></p><p><img src="https://pic.imgdb.cn/item/60b32bef39f6859bc213b23b.png"></p><h3 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h3><p>(字号, 位号) = (行号, 列号) -&gt; 盘块号 </p><p>字长16 = 一行有 16 个磁盘块，注意 0 开始 还是 1 开始 </p><p>盘块号 = 字长*字号 + 位号</p><p><img src="https://pic.imgdb.cn/item/60b369f739f6859bc21b2e48.png"></p><h3 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h3><p>UNIX系统采用。适用于大型文件系统。</p><p>文件卷的目录区中，专门用一个磁盘块作为超级块，系统启动时读入内存，并且保持内外存超级块数据同步</p><p><strong>超级块的作用</strong></p><p><img src="https://pic.imgdb.cn/item/60b36a9439f6859bc2215964.png"></p><p><strong>分配</strong></p><ol><li>若需要 1 个空闲磁盘块</li></ol><p><img src="https://pic.imgdb.cn/item/60b36b8339f6859bc22a3ad0.png"></p><ol start="2"><li>若需要 100 个空闲磁盘块</li></ol><p><img src="https://pic.imgdb.cn/item/60b36c0439f6859bc22f0aa7.png"></p><p><strong>回收</strong></p><p>第一个分组没有达到上限，加到其末尾即可</p><p>达到上限：</p><p><img src="https://pic.imgdb.cn/item/60b36c6b39f6859bc232813b.png"></p><p><img src="https://pic.imgdb.cn/item/60b36c7e39f6859bc2331f43.png"></p><h1 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h1><p><strong>创建文件</strong></p><ol><li><p>在外存中找到文件所需的空间 </p></li><li><p>根据文件路径找到对应目录文件，在目录中创建文件对应的目录项</p></li></ol><p><strong>删除文件</strong></p><ol><li><p>根据路径找到目录文件，找到文件名对应的目录项 </p></li><li><p>回收文件占用的磁盘块 </p></li><li><p>从目录表中删除文件对应的目录项</p></li></ol><p><strong>打开文件</strong></p><ol><li><p>根据路径找到目录文件，找到文件名对应的目录项，检测用户权限 </p></li><li><p>将目录项复制到该进程在内存中的打开文件表中，返回表目编号(索引号/文件描述符)。之后用户使用打开文件表的编号来指明要操作的文件。</p></li></ol><p>打开文件表有：进程的打开文件表，系统的打开文件表</p><p><img src="https://pic.imgdb.cn/item/60b37a8e39f6859bc2b85ed1.png"></p><p><strong>关闭文件</strong></p><ol><li>删除进程的打开文件表中对应项 </li><li>回收分配给该文件的内存空间等资源 </li><li>系统打开文件表的打开计数器count-=1(归零时删除该项)</li></ol><p><strong>读文件</strong></p><p>进程使用read系统调用完成读操作。需要指明是哪个文件(在支持“打开文件”操作的系统中,只需要提供文件在打开文件表中的索引号即可)，还需要指明要读入多少数据、指明读入的数据要放在内存中的什么位置。</p><p>操作系统在处理read系统调用时,会从读指针指向的外存中,将用户指定大小的数据读入用户指定的内存区域中</p><p><strong>写文件</strong></p><p>需要提供打开文件表中的索引号，写出的数据量，写回外存的数据位置(写指针指向)</p><h1 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h1><h2 id="基于索引结点的共享-硬链接"><a href="#基于索引结点的共享-硬链接" class="headerlink" title="基于索引结点的共享(硬链接)"></a>基于索引结点的共享(硬链接)</h2><p><img src="https://pic.imgdb.cn/item/60b65a5639f6859bc2529632.png"></p><h2 id="基于符号链的共享-软链接"><a href="#基于符号链的共享-软链接" class="headerlink" title="基于符号链的共享(软链接)"></a>基于符号链的共享(软链接)</h2><p><img src="https://pic.imgdb.cn/item/60b65a7539f6859bc2545a0c.png"></p><h1 id="文件共享-1"><a href="#文件共享-1" class="headerlink" title="文件共享"></a>文件共享</h1><h2 id="口令保护"><a href="#口令保护" class="headerlink" title="口令保护"></a>口令保护</h2><p>FCB中保存口令，访问时与用户提供的口令对比</p><p>开销小，但是不够安全</p><h2 id="加密保护"><a href="#加密保护" class="headerlink" title="加密保护"></a>加密保护</h2><p>用密码对文件数据流加密，访问时用密码解密，比如异或加密 </p><p>保密性强，不需要存储密码，但是加密/解密要花费一定的时间</p><p><img src="https://pic.imgdb.cn/item/60b716d939f6859bc2517587.jpg"></p><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>每一个文件的FCB（或索引结点）中增加一个访问控制表(ACL)，控制各用户的访问权限 </p><p>精简的访问列表：以组为单位，标记其访问权限。</p><p><img src="https://pic.imgdb.cn/item/60b717b939f6859bc262b2ff.jpg"></p><h1 id="文件系统层次结构"><a href="#文件系统层次结构" class="headerlink" title="文件系统层次结构"></a>文件系统层次结构</h1><p><img src="https://pic.imgdb.cn/item/60b71c0e39f6859bc2a45772.png"></p><p>eg：</p><p><img src="https://pic.imgdb.cn/item/60b71c6539f6859bc2a90a70.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文件就是一组有意义的信息/数据的集合&lt;/p&gt;
&lt;h1 id=&quot;文件的属性&quot;&gt;&lt;a href=&quot;#文件的属性&quot; class=&quot;headerlink&quot; title=&quot;文件的属性&quot;&gt;&lt;/a&gt;文件的属性&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;文件名&lt;br&gt;  主要是给用户看，同一个目录下不允许</summary>
      
    
    
    
    <category term="OperatingSystem" scheme="http://yoursite.com/categories/OperatingSystem/"/>
    
    
    <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>「OOP」JML</title>
    <link href="http://yoursite.com/2021/05/25/ObjectOriented/%E3%80%8COO%E3%80%8D-JML/"/>
    <id>http://yoursite.com/2021/05/25/ObjectOriented/%E3%80%8COO%E3%80%8D-JML/</id>
    <published>2021-05-25T11:18:06.000Z</published>
    <updated>2021-05-30T11:59:36.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="规格"><a href="#规格" class="headerlink" title="规格"></a>规格</h1><h2 id="什么是规格"><a href="#什么是规格" class="headerlink" title="什么是规格"></a>什么是规格</h2><p>对一个方法/类/程序的外部<strong>可感知</strong>行为的抽象表示 </p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><ul><li>规格把设计与实现有效分离</li><li>准确理解一个方法的行为，是多人协同开发时的交互基础</li><li>可以以逻辑方式来验证代码实现的正确性</li><li>作为开展测试设计的依据。我们不能只在黑盒层次开展测试，也需要对类、方法和接口进行测试</li></ul><h2 id="如何表示规格"><a href="#如何表示规格" class="headerlink" title="如何表示规格"></a>如何表示规格</h2><p>由许多研究，比如形式化语言。<br>要表示规格，需要实现：</p><ul><li>方法规格抽象<ul><li>执行前对输入的要求—-前置条件(precondition)</li><li>执行过程中对于环境(参数、所在this)的改变描述—-副作用(Side-Effects)</li><li>执行后返回结果应该满足的约束—-后置条件(postcondition)</li></ul></li><li>数据规格抽象(类型抽象)<ul><li>数据状态应该满足的要求—-不变式(invariant)</li><li>数据状态变化应该满足的要求—-约束(constraint)</li></ul></li></ul><h2 id="类型层次下的规格关系"><a href="#类型层次下的规格关系" class="headerlink" title="类型层次下的规格关系"></a>类型层次下的规格关系</h2><p>子类重写方法可以减弱父类方法规定的Requires,或者加强父类方法规定的Ensures</p><p>子类可以对父类进行扩充，但需要保持父类的规格仍然成立</p><p>LSP替换原则：在任何父类型对象出现的地方使用子类对象都不会破坏user程序的行为</p><h1 id="JML"><a href="#JML" class="headerlink" title="JML"></a>JML</h1><p>JML (Java Modeling Language) 是一种行为接口规格语言（Behavior Interface Specification Language，BISL），基于 Larch 方法构建。通过 JML 及其支持工具，不仅可以基于规格自动构造测试用例，并整合了 SMT Solver 等工具以静态方式来检查代码实现对规格的满足情况。</p><p>一般而言，JML 有两种主要的用法：</p><p>（1）开展规格化设计。这样交给代码实现人员的将不是可能带有内在模糊性的自然语言描述，而是逻辑严格的规格。</p><p>（2）针对已有的代码实现，书写其对应的规格，从而提高代码的可维护性。这在遗留代码的维护方面具有特别重要的意义。</p><p>JML 的设计考虑到了未来扩展需要，把语言分成了几个层次。其中 level 0 是最核心的语言特征，要求所有的 JML 工具都要支持。这里记录 level 0 中最核心和最常用的一些要素。</p><h2 id="1-注释结构"><a href="#1-注释结构" class="headerlink" title="1. 注释结构"></a>1. 注释结构</h2><p>JML 以 javadoc 注释的方式来表示规格，每行都以 @ 起头。有两种注释方式，行注释和块注释。其中行注释的表示方式为 <code>//@annotation</code>，块注释的方式为 <code>/* @ annotation @*/</code>。按照 Javadoc 习惯， JML 注释一般放在被注释成分的紧邻上部，如下面的例子所示。其中有效的 Java 代码为 line1，line 3，line 15，line18 和 line19。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jmlspecs.samples.jmlrefman;               <span class="comment">// line 1</span></span><br><span class="line">                                                      <span class="comment">// line 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntHeap</span> </span>&#123;                       <span class="comment">// line 3</span></span><br><span class="line">                                                      <span class="comment">// line 4</span></span><br><span class="line">    <span class="comment">//@ public model non_null int [] elements;        // line 5</span></span><br><span class="line">                                                      <span class="comment">// line 6</span></span><br><span class="line">    <span class="comment">/*@ public normal_behavior                        // line 7</span></span><br><span class="line"><span class="comment">      @   requires elements.length &gt;= 1;              // line 8</span></span><br><span class="line"><span class="comment">      @   assignable \nothing;                        // line 9</span></span><br><span class="line"><span class="comment">      @   ensures \result                             // line 10</span></span><br><span class="line"><span class="comment">      @        == (\max int j;                        // line 11</span></span><br><span class="line"><span class="comment">      @               0 &lt;= j &amp;&amp; j &lt; elements.length;  // line 12</span></span><br><span class="line"><span class="comment">      @               elements[j]);                   // line 13</span></span><br><span class="line"><span class="comment">      @*/</span>                                             <span class="comment">// line 14</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="comment">/*@ pure @*/</span> <span class="function"><span class="keyword">int</span> <span class="title">largest</span><span class="params">()</span></span>;       <span class="comment">// line 15</span></span><br><span class="line">                                                      <span class="comment">// line 16</span></span><br><span class="line">    <span class="comment">//@ ensures \result == elements.length;           // line 17</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="comment">/*@ pure @*/</span> <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;          <span class="comment">// line 18</span></span><br><span class="line">&#125;;                                                    <span class="comment">// line 19 </span></span><br></pre></td></tr></table></figure><p>在上面的例子中，定义了一个抽象类 <code>IntHeap</code> 。该类提供了两个抽象方法，<code>largest()</code> 和 <code>size()</code>。第 15 行和第 18 行的 JML 规格表示这两个方法都是纯粹查询方法（<code>/*@ pure @ */</code>），即方法的执行不会有任何副作用。这两个方法的规格必须建立在 <code>IntHeap</code> 所管理的数据规格上，因此为了准确说明这两个方面的规格，首先给出了 <code>IntHeap</code> 所管理的数据规格，如第 5 行所示。其中的 <code>model</code> 表示后面的 <code>int[] elements</code> 仅仅是规格层次的描述，并不是这个类的声明组成部分，此外也不意味该类的实现人员必须提供这样的属性定义，<code>non_null</code> 的意义是 <code>elements</code> 这个数组对象引用不能为 <code>null</code>。有了这个基础， 第 17 行给出了 <code>size</code> 方法的后置条件 (post-condition)，即任何时候该方法的执行都会返回 <code>IntHeap</code> 中存储的元素个数(<code>elements.length</code>)，其中的 <code>\result</code> 是 JML 的关键词，表示方法的执行返回结果。<code>largest</code> 的规格通过从第 7 行到第 14 行的注释块来定义，包括三个部分：</p><p>（1）<code>requires</code> 子句定义该方法的前置条件(pre-condition)，<code>elements.length&gt;=1</code>，即 <code>IntHeap</code> 中管理着至少一个元素；</p><p>（2）副作用范围限定，<code>assignable</code> 列出这个方法能够修改的类成员属性，<code>\nothing</code> 是个关键词，表示这个方法不对任何成员属性进行修改，所以是一个 <code>pure</code> 方法。</p><p>（3）<code>ensures</code> 子句定义了后置条件，即 <code>largest</code> 方法的返回结果等于 <code>elements</code> 中存储的所有整数中的最大的那个(<code>\max</code> 也是一个关键词)。</p><p>需要注意的是，规格中的每个子句都必须以分号结尾，否则会导致 JML 工具无法解析。相比较而言，largest 方法的规格复杂，而<code>size</code>方法的规格则相对简略。在 JML 中对应着两类规格写法，前者适用于前置条件不是恒真的场景，后者则适用于无需描述其前置条件的场景。</p><p>最后还要补充说明一下规格变量的声明。按照 JML 的语法，可以区分两类规格变量，静态或实例。如果是在 Interface 中声明规格变量，则要求明确变量的类别。针对上面的例子，如果是静态规格变量，则声明为 <code>//@public static model non_null int []elements</code>；如果是实例规格变量，则可声明为 <code>//@public instance model non_null int []elements</code>。</p><h2 id="2-JML表达式"><a href="#2-JML表达式" class="headerlink" title="2. JML表达式"></a>2. JML表达式</h2><p>JML 的表达式是对 Java 表达式的扩展，新增了一些操作符和原子表达式。同样 JML 表达式中的操作符也有优先级的概念。请参见 JML 语言手册 12.3 节 (Expression) 获得完整的优先级列表。需要提醒的是，JML 相对于 Java 新增的表达式成分仅用于 JML 中的断言 (assertion) 语句和其他相关的注释体。特别需要提醒，在 JML 断言中，不可以使用带有赋值语义的操作符，如 <code>++，--，+=</code> 等操作符，因为这样的操作符会对被限制的相关变量的状态进行修改，产生副作用。</p><h3 id="2-1-原子表达式"><a href="#2-1-原子表达式" class="headerlink" title="2.1 原子表达式"></a>2.1 原子表达式</h3><p><code>\result</code> 表达式：表示一个非 <code>void</code> 类型的方法执行所获得的结果，即方法执行后的返回值。<code>\result</code> 表达式的类型就是方法声明中定义的返回值类型。如针对方法：<code>public boolean equals (Object o)</code>，<code>\result</code> 的类型是 <code>boolean</code>，任意传递一个 <code>Object</code> 类型的对象来调用该方法，可以使用 <code>\result</code> 来表示 <code>equals</code> 的执行结果（<code>true </code>表示 <code>this</code> 和 <code>o</code> 相等；<code>false </code>表示不相等）。</p><p><code>\old(expr)</code> 表达式：用来表示一个表达式 <code>expr</code> 在相应方法执行前的取值。该表达式涉及到评估 <code>expr</code> 中的对象是否发生变化，遵从 Java 的引用规则，即针对一个对象引用而言，只能判断引用本身是否发生变化，而不能判断引用所指向的对象实体内容是否发生变化。假设一个类有属性 <code>v</code> 为 <code>HashMap</code>，假设在方法执行前 <code>v</code> 的取值为 <code>0x952ab340</code>，即指向了存储在该地址的具体 <code>HashMap</code> 对象，则 <code>\old(v)</code> 的值就是这个引用地址。如果方法执行过程中没有改变 <code>v</code> 指向的对象，则 <code>v</code> 和 <code>\old(v)</code> 有相同的取值，即使方法在执行过程中对 <code>v</code> 指向的 <code>HashMap</code> 执行了插入或删除操作。因此 <code>v.size()</code> 和 <code>\old(v).size()</code> 也有相同的结果。很多情况下，我们希望获得 <code>v</code> 在方法执行前所管理的对象个数，这时应使用 <code>\old(v.size()</code>)。作为一般规则，任何情况下，都应该使用 <code>\old</code> 把关心的表达式取值整体括起来。</p><p><code>\not_assigned(x,y,...)</code> 表达式：用来表示括号中的变量是否在方法执行过程中被赋值。如果没有被赋值，返回为 <code>true</code>，否则返回 <code>false</code>。实际上，该表达式主要用于后置条件的约束表示上，即限制一个方法的实现不能对列表中的变量进行赋值。</p><p><code>\not_modified(x,y,...)</code> 表达式：与上面的 <code>\not_assigned</code> 表达式类似，该表达式限制括号中的变量在方法执行期间的取值未发生变化。</p><p><code>\nonnullelements(container)</code> 表达式：表示 <code>container</code> 对象中存储的对象不会有 <code>null</code>，等价于下面的断言，其中 <code>\forall</code> 是 JML 的关键词，表示针对所有 <code>i</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">container != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">(\forall <span class="keyword">int</span> i; <span class="number">0</span> &lt;= i &amp;&amp; i &lt; container.length;</span><br><span class="line">                container[i] != <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure><p><code>\type(type)</code> 表达式：返回类型 <code>type</code> 对应的类型 (Class)，如 <code>type(boolean)</code> 为 <code>Boolean.TYPE</code>。<code>TYPE</code> 是 JML 采用的缩略表示，等同于 Java 中的<code>java.lang.Class</code>。</p><p><code>\typeof(expr)</code> 表达式：该表达式返回 <code>expr</code> 对应的准确类型。如 <code>\typeof(false)</code> 为 <code>Boolean.TYPE</code>。</p><h3 id="2-2-量化表达式"><a href="#2-2-量化表达式" class="headerlink" title="2.2 量化表达式"></a>2.2 量化表达式</h3><p><code>\forall</code> 表达式：全称量词修饰的表达式，表示对于给定范围内的元素，每个元素都满足相应的约束。<code>(\forall int i,j; 0 &lt;= i &amp;&amp; i &lt; j &amp;&amp; j &lt; 10; a[i] &lt; a[j])</code>，意思是针对任意 <code>0 &lt;= i &lt; j &lt; 10，a[i] &lt; a[j]</code>。这个表达式如果为真 (<code>true</code>)，则表明数组 <code>a</code> 实际是升序排列的数组。</p><p><code>\exists</code> 表达式：存在量词修饰的表达式，表示对于给定范围内的元素，存在某个元素满足相应的约束。<code>(\exists int i; 0 &lt;= i &amp;&amp; i &lt; 10; a[i] &lt; 0)</code>，表示针对 <code>0 &lt;= i &lt; 10</code>，至少存在一个 <code>a[i]&lt;0</code>。</p><p><code>\sum</code> 表达式：返回给定范围内的表达式的和。<code>(\sum int i; 0 &lt;= i &amp;&amp; i &lt; 5; i)</code>，这个表达式的意思计算 <code>[0,5)</code> 范围内的整数 <code>i</code> 的和，即 <code>0 + 1 + 2 + 3 + 4 = 10</code>。注意中间的 <code>0 &lt;= i &amp;&amp; i &lt; 5</code> 是对 <code>i</code> 范围的限制，求和表达式为最后面的那个 <code>i</code>。同理，我们构造表达式 <code>(\sum int i; 0 &lt;= i &amp;&amp; i &lt; 5; i*i)</code>，则返回的结果为 <code>1 + 4 + 9 + 16</code>。</p><p><code>\product</code> 表达式：返回给定范围内的表达式的连乘结果。<code>(\product int i; 0 &lt; i &amp;&amp; i &lt; 5; i)</code>，这个表达式的意思是针对 <code>(0,5)</code> 范围的整数的连乘结果，即 <code>1* 2* 3 * 4</code> 。</p><p><code>\max</code> 表达式：返回给定范围内的表达式的最大值。<code>(\max int i; 0 &lt;= i &amp;&amp; i &lt; 5; i)</code>，这个表达式返回 <code>[0,5)</code> 中的最大的整数，即 <code>4</code>。</p><p><code>\min</code> 表达式：返回给定范围内的表达式的最小值。<code>(\min int i; 0 &lt;= i &amp;&amp; i &lt; 5; i)</code>，这个表达式返回 <code>[0,5)</code> 中的最小的整数，即 <code>0</code>。</p><p><code>\num_of</code> 表达式：返回指定变量中满足相应条件的取值个数。<code>(\num_of int x; 0 &lt; x &amp;&amp; x &lt;= 20; x % 2 == 0)</code>，这个表达式给出 <code>(0,20]</code> 以内能够被 <code>2</code> 整除的整数个数，得到的数目为 <code>10</code>。一般的，<code>\num_of</code> 表达式可以写成 <code>(\num_of T x; R(x);P(x))</code>，其中 <code>T</code> 为变量 <code>x</code> 的类型，<code>R(x)</code> 为 <code>x</code> 的取值范围；<code>P(x)</code> 定义了 <code>x</code> 需要满足的约束条件。从逻辑上来看，该表达式也等价于 <code>(\sum T x; R(x) &amp;&amp; P(x); 1)</code>。</p><h3 id="2-3-集合表达式"><a href="#2-3-集合表达式" class="headerlink" title="2.3 集合表达式"></a>2.3 集合表达式</h3><p>集合构造表达式：可以在 JML 规格中构造一个局部的集合（容器），明确集合中可以包含的元素。<code>new JMLObjectSet &#123;Integer i | s.contains(i) &amp;&amp; 0 &lt; i.intValue() &#125; </code>表示构造一个 <code>JMLObjectSet</code> 对象，其中包含的元素类型为 <code>Integer</code>，该集合中的所有元素都在容器集合 <code>s</code> 中出现（注：该容器集合指 Java 程序中构建的容器，比如 <code>ArrayList</code>），且整数值大于 <code>0</code> 。集合构造表达式的一般形式为：<code>new ST &#123;T x | R(x) &amp;&amp; P(x)&#125;</code>，其中的 <code>R(x)</code> 对应集合中 <code>x</code> 的范围，通常是来自于某个既有集合中的元素，如 <code>s.has(x)</code> ，<code>P(x)</code> 对应 <code>x</code> 取值的约束。</p><h3 id="2-4-操作符"><a href="#2-4-操作符" class="headerlink" title="2.4 操作符"></a>2.4 操作符</h3><p>JML 表达式中可以正常使用 Java 语言所定义的操作符，包括算术操作符、逻辑预算操作符等。此外，JML 专门又定义了如下四类操作符。</p><p>(1) 子类型关系操作符：<code>E1&lt;:E2</code>，如果类型 <code>E1</code> 是类型 <code>E2</code> 的子类型 (sub type)，则该表达式的结果为真，否则为假。如果 <code>E1</code> 和 <code>E2</code> 是相同的类型，该表达式的结果也为真，如 <code>Integer.TYPE&lt;:Integer.TYPE </code>为真；但<code>Integer.TYPE&lt;:ArrayList.TYPE </code>为假。需要指出的是，任意一个类 <code>X</code> ，都必然满足 <code>X.TYPE&lt;:Object.TYPE</code>。</p><p>(2) 等价关系操作符：<code>b_expr1&lt;==&gt;b_expr2</code>或者<code>b_expr1&lt;=!=&gt;b_expr2</code>，其中 <code>b_expr1</code> 和 <code>b_expr2</code> 都是布尔表达式，这两个表达式的意思是 <code>b_expr1==b_expr2</code> 或者 <code>b_expr1!=b_expr2</code> 。可以看出，这两个操作符和 Java 中的 <code>==</code> 和 <code>!=</code> 具有相同的效果，按照 JML 语言定义，<code>&lt;==&gt;</code> 比 <code>==</code> 的优先级要低，同样 <code>&lt;=!=&gt;</code> 比 <code>!=</code> 的优先级低。</p><p>(3) 推理操作符：<code>b_expr1==&gt;b_expr2</code> 或者 <code>b_expr2&lt;==b_expr1</code>。对于表达式 <code>b_expr1==&gt;b_expr2</code> 而言，当 <code>b_expr1==false</code>，或者 <code>b_expr1==true</code> 且 <code>b_expr2==true</code> 时，整个表达式的值为 <code>true</code>。</p><p>(4) 变量引用操作符：除了可以直接引用 Java 代码或者 JML 规格中定义的变量外，JML 还提供了几个概括性的关键词来引用相关的变量。<code>\nothing</code> 指示一个空集；<code>\everything</code> 指示一个全集，即包括当前作用域下能够访问到的所有变量。变量引用操作符经常在assignable句子中使用，如 <code>assignable \nothing</code> 表示当前作用域下每个变量都不可以在方法执行过程中被赋值。</p><h2 id="3-方法规格"><a href="#3-方法规格" class="headerlink" title="3. 方法规格"></a>3. 方法规格</h2><p>方法规格是 JML 的重要内容，本手册仅涉及最基础的部分，而不引述 JML 扩展部分的内容。方法规格的核心内容包括三个方面，前置条件、后置条件和副作用约定。其中前置条件是对方法输入参数的限制，如果不满足前置条件，方法执行结果不可预测，或者说不保证方法执行结果的正确性；后置条件是对方法执行结果的限制，如果执行结果满足后置条件，则表示方法执行正确，否则执行错误。副作用指方法在执行过程中对输入对象或 <code>this</code> 对象进行了修改（对其成员变量进行了赋值，或者调用其修改方法）。课程区分两类方法：全部过程和局部过程。前者对应着前置条件恒为真，即可以适应于任意调用场景；后者则提供了非恒真的前置条件，要求调用者必须确保调用时满足相应的前置条件。从设计角度，软件需要适应用户的所有可能输入，因此也需要对不符合前置条件的输入情况进行处理，往往对应着异常处理。从规格的角度，JML 区分这两种场景，分别对应正常行为规格 (normal_behavior) 和异常行为规格 (expcetional_behavior)。</p><ul><li>前置条件 (pre-condition)</li></ul><p>前置条件通过 <code>requires</code> 子句来表示：<code>requires P;</code>。其中 <code>requires</code> 是 JML 关键词，表达的意思是“要求调用者确保P为真”。注意，方法规格中可以有多个 <code>requires</code> 子句，是并列关系，即调用者必须同时满足所有的并列子句要求。如果设计者想要表达或的逻辑，则应该使用一个 <code>requires</code> 子句，在其中的谓词 <code>P</code> 中使用逻辑或操作符来表示相应的约束场景：<code>requires P1||P2;</code>。</p><ul><li>后置条件 (post-condition)</li></ul><p>后置条件通过 <code>ensures</code> 子句来表示：<code>ensures P;</code>。其中 <code>ensures</code> 是 JML 关键词，表达的意思是“方法实现者确保方法执行返回结果一定满足谓词P的要求，即确保 <code>P</code> 为真”。同样，方法规格中可以有多个 <code>ensures</code> 子句，是并列关系，即方法实现者必须同时满足有所并列 <code>ensures</code> 子句的要求。如果设计者想要表达或的逻辑，这应该在在一个 <code>ensures</code> 子句中使用逻辑或 （<code>||</code>）操作符来表示相应的约束场景：<code>ensures P1||P2;</code>。</p><ul><li>副作用范围限定 (side-effects)</li></ul><p>副作用指方法在执行过程中会修改对象的属性数据或者类的静态成员数据，从而给后续方法的执行带来影响。从方法规格的角度，必须要明确给出副作用范围。JML 提供了副作用约束子句，使用关键词 <code>assignable</code> 或者 <code>modifiable</code>。从语法上来看，副作用约束子句共有两种形态，一种不指明具体的变量，而是用JML关键词来概括；另一种则是指明具体的变量列表。下面是几种经常出现的副作用约束子句形态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerSet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> ArrayList&lt;Integer&gt; elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> Integer max;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> Integer min;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*@</span></span><br><span class="line"><span class="comment">    @ ...</span></span><br><span class="line"><span class="comment">    @ assignable \nothing;</span></span><br><span class="line"><span class="comment">    @ assignable \everything;</span></span><br><span class="line"><span class="comment">    @ modifiable \nothing;</span></span><br><span class="line"><span class="comment">    @ modifiable \everthing;</span></span><br><span class="line"><span class="comment">    @ assignable elements;</span></span><br><span class="line"><span class="comment">    @ modifiable elements;</span></span><br><span class="line"><span class="comment">    @ assignable elements, max, min;</span></span><br><span class="line"><span class="comment">    @ modifiable elements, max, min;</span></span><br><span class="line"><span class="comment">    @*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如该例子所述，<code>assignble </code>表示可赋值，而 <code>modifiable</code> 则表示可修改。虽然二者有细微的差异，在大部分情况下，二者可交换使用。其中 <code>\nothing</code> 和 <code>\everything</code> 是两个关键词，前者表示当前作用域内可见的所有类成员变量和方法输入对象都不可以赋值或者修改；后者表示当前作用域内可见的所有类成员变量和方法输入对象都可以赋值或者修改。也可以指明具体可修改的变量列表，一个变量或多个变量，如果是多个则通过逗号分隔，如 <code>@ assignable elements, max, min;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注<span class="number">1</span>：JML不允许在副作用约束子句中指定规格声明的变量数据，因为这样的声明只是为了描述规格，并不意味实现者一定要实现这样的数据。</span><br><span class="line">注<span class="number">2</span>：默认情况下，方法的规格对调用者可见，但是方法所在类的成员变量一般都声明为 <span class="keyword">private</span> ,对调用者不可见。有时方法规格不得不使用类的成员变量来限制方法的行为，比如上面例子中的副作用范围限定，这就和类对相应成员变量的私有化保护产生了冲突。为了解决这个问题，JML提供了 <span class="comment">/*@spec_public@*/</span> 来注释一个类的私有成员变量，表示在规格中可以直接使用，从而调用者可见。</span><br></pre></td></tr></table></figure><p>设计中会出现某些纯粹访问性的方法，即不会对对象的状态进行任何改变，也不需要提供输入参数，这样的方法无需描述前置条件，也不会有任何副作用，且执行一定会正常结束。对于这类方法，可以使用简单的（轻量级）方式来描述其规格，即使用 <code>pure</code> 关键词：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//@ ensures \result == bachelor || \result == master;</span></span><br><span class="line"><span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="function"><span class="keyword">int</span> <span class="title">getStatus</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//@ ensures \result &gt;= 0;</span></span><br><span class="line"><span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="function"><span class="keyword">int</span> <span class="title">getCredits</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>针对上面的三个例子，<code>getName</code> 甚至不需要做任何限定，是一种极简的场景；<code>getStatus</code> 例子则限定了返回值 <code>\result</code> 要么 <code>==bachelor</code>，要么 <code>==master</code>；<code>getCredits</code> 的例子则限定了返回值必须大于等于 <code>0</code> ：<code>\result &gt;=0</code>。</p><p>在方法规格中，有些前置条件可以引用 <code>pure</code> 方法返回的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ requires c &gt;= 0;</span></span><br><span class="line"><span class="comment">@ ensures getCredits() == \old(getCredits()) + c;</span></span><br><span class="line"><span class="comment">@*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCredits</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure><p>有时候，前置条件或后置条件需要对不止一个变量进行约束，往往是需要对一个容器中的所有元素进行约束，这时就需要使用 <code>\forall</code> 或者 <code>\exists</code> 表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ requires size &lt; limit &amp;&amp; !contains(elem);</span></span><br><span class="line"><span class="comment">@ ensures \result == true;</span></span><br><span class="line"><span class="comment">@ ensures contains(elem);</span></span><br><span class="line"><span class="comment">@ ensures (\forall int e;</span></span><br><span class="line"><span class="comment">@ e != elem;</span></span><br><span class="line"><span class="comment">@ contains(e) &lt;==&gt; \old(contains(e)));</span></span><br><span class="line"><span class="comment">@ ensures size == \old(size) + 1;</span></span><br><span class="line"><span class="comment">@*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> elem)</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br></pre></td></tr></table></figure><p>上面的这个例子要求调用 <code>add</code> 方法之前，调用者必须确保当前对象管理的元素（整数）数目不能超过限制(<code>limit</code>)，同时不能重复加入相同的整数（<code>!contains(elem)</code>）。该方法的规格有三个并列的后置条件，<code>ensures contains(elem)</code> 要求 <code>add</code> 方法一定要把参数 <code>elem</code> 对应的整数加入到容器中；<code>ensures size == \old(size) + 1 </code>要求容器中管理的整数数目增加一个；中间的那个后置条件要求原来容器中包含的整数仍然在容器中，使用 <code>\forall </code>表达式来表示。</p><p>更进一步，假设带有规模限制的整数容器还提供了一个 <code>remove</code> 方法，这个方法要求：（1）如果输入参数在容器中，则移除该整数；（2）任何情况下，都不能移除容器中不等于输入参数的任何整数。要对这个方法的后置条件进行设计，需要从两个方面进行限制，一个是方法运行结果中不包含输入的整数，同时容器原来不等于输入参数的整数仍然还在容器中；另一方面需要对象容器的规模进行限制，如果输入参数在容器中，则容器存储的整数数目减少一个，否则保持不变。按照这个设计，可以得到如下完整的方法规格：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ ensures !contains(elem);</span></span><br><span class="line"><span class="comment">@ ensures (\forall int e;</span></span><br><span class="line"><span class="comment">@ e != elem;</span></span><br><span class="line"><span class="comment">@ contains(e) &lt;==&gt; \old(contains(e)));</span></span><br><span class="line"><span class="comment">@ ensures \old(contains(elem)) ==&gt; size == \old(size) - 1;</span></span><br><span class="line"><span class="comment">@ ensures !\old(contains(elem)) ==&gt; size == \old(size);</span></span><br><span class="line"><span class="comment">@*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> elem)</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br></pre></td></tr></table></figure><p>如前所述，为了有效的区分方法的正常功能行为和异常行为，JML 提供了这两类行为的区分机制，可以明确按照这两类行为来分别描述方法的规格，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">@ requires z &lt;= 99;</span></span><br><span class="line"><span class="comment">@ assignable \nothing;</span></span><br><span class="line"><span class="comment">@ ensures \result &gt; z;</span></span><br><span class="line"><span class="comment">@ also</span></span><br><span class="line"><span class="comment">@ public exceptional_behavior</span></span><br><span class="line"><span class="comment">@ requires z &lt; 0;</span></span><br><span class="line"><span class="comment">@ assignable \nothing;</span></span><br><span class="line"><span class="comment">@ signals (IllegalArgumentException e) true;</span></span><br><span class="line"><span class="comment">@*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">cantBeSatisfied</span><span class="params">(<span class="keyword">int</span> z)</span> <span class="keyword">throws</span> IllegalArgumentException；</span></span><br></pre></td></tr></table></figure><p>其中 <code>public normal_behavior </code>表示接下来的部分对 <code>cantBeSatisfied(int z)</code> 方法的正常功能给出规格。所谓正常功能，一般指输入或方法关联this对象的状态在正常范围内时所指向的功能。与正常功能相对应的是异常功能，即 <code>public exceptional_behavior</code> 下面所定义的规格。其中的 <code>public</code> 指相应的规格在所在包范围内的所有其他规格处都可见。需要说明的是，如果一个方法没有异常处理行为，则无需区分正常功能规格和异常功能规格，因而也就不必使用这两个关键词。</p><p>上面例子中出现了一个关键词 <code>also</code>，它的意思是除了正常功能规格外，还有一个异常功能规格。需要说明的是，按照JML语言规范定义，有两种使用 <code>also</code> 的场景：（1）父类中对相应方法定义了规格，子类重写了该方法，需要补充规格，这时应该在补充的规格之前使用 <code>also</code> ；（2）一个方法规格中涉及多个功能规格描述，正常功能规格或者异常功能规格，需要使用 <code>also</code> 来分隔。</p><p>我们仔细看上面的例子，实际上存在逻辑矛盾，即正常功能的前置条件蕴含了异常功能的前置条件（<code>&#123;z &lt;= 99&#125; </code>与 <code>&#123;z &lt; 0&#125;</code> 有交集），因此对于这个例子的规格而言，任何实现都不可能满足该规格。这样的矛盾规格是严重的设计错误，要避免。作为一种重要的设计检查原则，同一个方法的正常功能前置条件和异常功能前置条件一定不重叠。对于上面的例子而言，如果正常功能前置条件修改为 <code>z &gt;= 0</code> 就能满足这个要求。可以看出不论是正常功能规格，或者是异常功能规格，都包括前置条件、后置条件和副作用声明。不同的是，异常功能规格中，后置条件常常表示为抛出异常，使用 <code>signals</code> 子句来表示。</p><ul><li>signals 子句</li></ul><p>signals 子句的结构为 <code>signals (***Exception e) b_expr;</code>，意思是当 <code>b_expr</code> 为 <code>true</code> 时，方法会抛出括号中给出的相应异常 <code>e</code>。对于上面的例子而言，只要输入满足 <code>z &lt; 0</code>，就一定会抛出异常 <code>IllegalArgumentException</code>。需要注意的是，所抛出的既可以是 Java 预先定义的异常类型，也可以是用户自定义的异常类型。此外，还有一个注意事项，如果一个方法在运行时会抛出异常，一定要在方法声明中明确指出（使用 Java 的 <code>throws</code> 表达式），且必须确保 signals 子句中给出的异常类型一定等同于方法声明中给出的异常类型，或者是后者的子类型。</p><p>还有一个简化的 signals 子句，即 signals_only 子句，后面跟着一个异常类型。signals 子句强调在对象状态满足某个条件时会抛出符合相应类型的异常；而 signals_only 则不强调对象状态条件，强调满足前置条件时抛出相应的异常。</p><p>有时候，为了更加明确的区分异常，会针对输入参数的取值范围抛出不同的异常，从而提醒调用者进行不同的处理。这时可以使用多个 exceptional_behavior：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="comment">/** A specification that can&#x27;t be satisfied. */</span></span><br><span class="line">  <span class="comment">//@ public model non_null int[] credits; </span></span><br><span class="line">  <span class="comment">/*@ normal_behavior</span></span><br><span class="line"><span class="comment">    @ requires z &gt;=0 &amp;&amp; z &lt;= 100;</span></span><br><span class="line"><span class="comment">    @ assignable \nothing;</span></span><br><span class="line"><span class="comment">    @ ensures \result == credits.length;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    @ also</span></span><br><span class="line"><span class="comment">    @ exceptional_behavior</span></span><br><span class="line"><span class="comment">@ requires z &lt; 0;</span></span><br><span class="line"><span class="comment">@ assignable \nothing;</span></span><br><span class="line"><span class="comment">@ signals_only IllegalArgumentException;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@ also</span></span><br><span class="line"><span class="comment">    @ exceptional_behavior</span></span><br><span class="line"><span class="comment">@ requires z &gt; 100;</span></span><br><span class="line"><span class="comment">@ assignable \nothing;</span></span><br><span class="line"><span class="comment">@ signals_only OverFlowException;</span></span><br><span class="line"><span class="comment">    @*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">recordCredit</span><span class="params">(<span class="keyword">int</span> z)</span> <span class="keyword">throws</span> IllegalArgumentException, OverFlowException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子是针对 <code>Student</code> 类提供的 <code>recordCredit(int z)</code> 方法，从规格角度定义了一个规格数据 <code>int[] credits</code>，并提供了三个功能规格，使用两个 <code>also</code> 进行了分隔。注意看三个功能规格的 <code>requires</code> 子句，在一起覆盖了方法输入参数的所有看取值范围，而且彼此没有交叉。这是功能规格设计的基本要求，同学们一定要小心这一点。其中两个异常功能规格使用 signals_only 子句分别抛出相应的异常。需要指出的是，在异常功能规格中，除了抛出异常，也一样可以正常使用 ensures 子句来描述方法执行产生的其他结果。</p><h2 id="4-类型规格"><a href="#4-类型规格" class="headerlink" title="4. 类型规格"></a>4. 类型规格</h2><p>类型规格指针对 Java 程序中定义的数据类型所设计的限制规则，一般而言，就是指针对类或接口所设计的约束规则。从面向对象角度来看，类或接口包含数据成员和方法成员的声明及或实现。不失一般性，一个类型的成员要么是静态成员 (static member)，要么是实例成员 (instance member)。一个类的静态方法不可以访问这个类的非静态成员变量（即实例变量）。静态成员可以直接通过类型来引用，而实例成员只能通过类型的实例化对象来引用。因此，在设计和表示类型规格时需要加以区分。</p><p>JML 针对类型规格定义了多种限制规则，从课程的角度，我们主要涉及两类，不变式限制 (invariant) 和约束限制 (constraints)。无论哪一种，类型规格都是针对类型中定义的数据成员所定义的限制规则，一旦违反限制规则，就称相应的状态有错。</p><ul><li>不变式 invariant</li></ul><p>不变式（invariant）是要求在所有<strong>可见状态</strong>下都必须满足的特性，语法上定义 <code>invariant P</code>，其中 <code>invariant </code>为关键词，<code>P </code>为谓词。对于类型规格而言，<strong>可见状态 (visible state)</strong> 是一个特别重要的概念。下面所述的几种时刻下对象 <code>o</code> 的状态都是可见状态：</p><ul><li><p>对象的有状态构造方法（用来初始化对象成员变量初值）的执行结束时刻</p></li><li><p>在调用一个对象回收方法（finalize 方法）来释放相关资源开始的时刻</p></li><li><p>在调用对象 <code>o</code> 的非静态、有状态方法（non-helper）的开始和结束时刻</p></li><li><p>在调用对象 <code>o</code> 对应的类或父类的静态、有状态方法的开始和结束时刻</p></li><li><p>在未处于对象 <code>o</code> 的构造方法、回收方法、非静态方法被调用过程中的任意时刻</p></li><li><p>在未处于对象 <code>o</code> 对应类或者父类的静态方法被调用过程中的任意时刻</p></li></ul><p>由上面的定义可知，凡是会修改成员变量（包括静态成员变量和非静态成员变量）的方法执行期间，对象的状态都不是可见状态。这里的可见不是一般意义上的能否见到，而是带有完整可见的意思。在会修改状态的方法执行期间，对象状态不稳定，随时可能会被修改。换句话说，在方法执行期间，对象的不变式有可能不满足。因此，类型规格强调在任意可见状态下都要满足不变式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Path</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> ArrayList &lt;Integer&gt; seq_nodes;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> Integer start_node;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> Integer end_node;</span><br><span class="line">    <span class="comment">/*@ invariant seq_nodes != null &amp;&amp; </span></span><br><span class="line"><span class="comment">      @ seq_nodes[0] == start_node &amp;&amp; </span></span><br><span class="line"><span class="comment">      @ seq_nodes[seq_nodes.length-1] == end_node &amp;&amp; </span></span><br><span class="line"><span class="comment">      @ seq_nodes.length &gt;=2;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的例子所示，<code>Path</code> 类的不变式定义了 <code>seq_nodes</code> 不能为 <code>null</code> ，且任意一个 <code>path</code> 对象至少包括两个节点，一个起始节点 (<code>start_node</code>) 和一个终止节点 (<code>end_node</code>) 。一个类可以包括多个不变式，相互独立。如果一个对象的可见状态不满足不变式，则称该对象的状态有错。实际工程中，如果一个类中有两个产生逻辑矛盾的不变式（即二者不可能同时为真），则出现了规格设计缺陷。需要指出的是，不变式中可以直接引用 <code>pure</code> 形态的方法。</p><p>对应类成员变量有静态和非静态之分，JML 区分两类不变式，静态不变式 (static invariant) 和实例不变式 (instance invariant)。其中静态不变式只针对类中的静态成员变量取值进行约束，而实例不变式则可以针对静态成员变量和非静态成员变量的取值进行约束。可以在不变式定义中明确使用 <code>instance invariant </code>或 <code>static invariant </code>来表示不变式的类别。</p><ul><li>状态变化约束 constraint</li></ul><p>对象的状态在变化时往往也许满足一些约束，这种约束本质上也是一种不变式。JML 为了简化使用规则，规定invariant 只针对可见状态(即当下可见状态)的取值进行约束，而是用 constraint 来对前序可见状态和当前可见状态的关系进行约束。如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceCounter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> <span class="keyword">long</span> counter;</span><br><span class="line">    <span class="comment">//@ invariant counter &gt;= 0;</span></span><br><span class="line">    <span class="comment">//@ constraint counter == \old(counter)+1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类 <code>ServiceCounter</code> 拥有一个成员变量 <code>counter</code> ，包含一个不变式和一个状态变化约束。不变式指出<code>counter &gt;= 0</code>，而 constraint 不同，约束每次修改 <code>counter</code> 只能加 <code>1</code>。虽然这个约束可以在可能对 <code>counter</code> 进行修改的方法中通过后置条件来表示，但是每个可能修改 <code>counter</code> 的方法都需要加上这样的后置条件，远不如 constraint 这样的表示来的方便。不仅如此，invariant 和 constraint 可以直接被子类继承获得。</p><p>和不变式一样，JML 也根据类的静态成员变量区分了两类约束：static constraint 和 instance constraint。其中static constraint 只涉及类的静态成员变量，而 instance constraint 则可以涉及类的静态成员变量和非静态成员变量。同样，也可以在规格中通过关键词来明确加以区分：<code>static constraint P </code>和 <code>instance constraint P</code>。</p><ul><li>方法与类型规格的关系</li></ul><p>如果一个类是不可变类，其实就没必要定义其不变式，只需要在构造方法中明确其初始状态应该满足的后置条件即可。当然，也可以反过来，定义不变式，而不定义构造方法的后置条件。事实上，在大部分情况下，一个类有几种不同类别的方法：静态初始化（不是方法，但也是一种行为）、有状态静态方法、有状态构造方法、有状态非静态方法。下表给出了两类不变式与这些方法的关系：</p><table><thead><tr><th align="center"></th><th align="center">静态成员初始化</th><th align="center">有状态静态方法</th><th align="center">有状态构造方法</th><th align="center">有状态非静态方法</th></tr></thead><tbody><tr><td align="center">static invariant</td><td align="center">建立</td><td align="center">保持</td><td align="center">保持</td><td align="center">保持</td></tr><tr><td align="center">instance invariant</td><td align="center">(无关)</td><td align="center">(无关)</td><td align="center">建立</td><td align="center">保持，除非是finalizer方法</td></tr></tbody></table><p>注：“建立”的含义是静态成员建立了满足相应不变式的类或对象状态。“保持”的含义是如果方法执行前不变式满足，执行后还应该满足相应的不变式。</p><p>同理，JML 也对 constraint 与方法之间的关系进行了约定：</p><table><thead><tr><th align="center"></th><th align="center">静态成员初始化</th><th align="center">有状态静态方法</th><th align="center">有状态构造方法</th><th align="center">有状态非静态方法</th></tr></thead><tbody><tr><td align="center">static constraint</td><td align="center">(无关)</td><td align="center">遵从</td><td align="center">遵从</td><td align="center">遵从</td></tr><tr><td align="center">instance constraint</td><td align="center">(无关)</td><td align="center">(无关)</td><td align="center">(无关)</td><td align="center">遵从</td></tr></tbody></table><p>注：“遵从”的含义是成员变量的当前取值和上一个取值之间的关系满足 constraint 的规定，即“遵从规定”。</p><h2 id="5-一个完整例子"><a href="#5-一个完整例子" class="headerlink" title="5. 一个完整例子"></a>5. 一个完整例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="comment">/*@ spec_public @*/</span> String name;</span><br><span class="line"><span class="comment">//@ public invariant credits &gt;= 0;</span></span><br><span class="line"><span class="keyword">private</span> <span class="comment">/*@ spec_public @*/</span> <span class="keyword">int</span> credits;</span><br><span class="line"><span class="comment">/*@ public invariant credits &lt; 180 ==&gt; !master &amp;&amp;</span></span><br><span class="line"><span class="comment">  @ credits &gt;= 180 ==&gt; master;</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="comment">/*@ spec_public @*/</span> <span class="keyword">boolean</span> master;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*@ requires sname != null;</span></span><br><span class="line"><span class="comment">  @ assignable \everything;</span></span><br><span class="line"><span class="comment">  @ ensures name == sname &amp;&amp; credits == 0 &amp;&amp; master == false;</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span> <span class="params">(String sname)</span> </span>&#123;</span><br><span class="line">name = sname;</span><br><span class="line">credits = <span class="number">0</span>;</span><br><span class="line">master = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ requires c &gt;= 0;</span></span><br><span class="line"><span class="comment">  @ ensures credits == \old(credits) + c;</span></span><br><span class="line"><span class="comment">  @ assignable credits, master;</span></span><br><span class="line"><span class="comment">  @ ensures (credits &gt;= 180) ==&gt; master</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCredits</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">updateCredits(c);</span><br><span class="line"><span class="keyword">if</span> (credits &gt;= <span class="number">180</span>) &#123;</span><br><span class="line">changeToMaster();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ requires c &gt;= 0;</span></span><br><span class="line"><span class="comment">  @ ensures credits == \old(credits) + c;</span></span><br><span class="line"><span class="comment">  @ assignable credits;</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateCredits</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">credits += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ requires credits &gt;= 180;</span></span><br><span class="line"><span class="comment">  @ ensures master;</span></span><br><span class="line"><span class="comment">  @ assignable master;</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">changeToMaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">master = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ ensures this.name == name;</span></span><br><span class="line"><span class="comment">  @ assignable this.name;</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ ensures \result == name;</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个针对 <code>Student</code> 类的完整例子。该类提供了三个私有成员变量：<code>private String name</code>、<code>private int credits </code> 和<code>private boolean master</code>。如前所述，因为这三个是私有成员，规格中是不可见的，JML 通过使用 <code>/*@ spec_public @*/</code> 来解决这个问题。</p><p>对比看一下 <code>addCredits(c)</code> 方法和 <code>updateCredits(c)</code> 方法的规格，二者的共同效果是 <code>credits == \old(credits) + c</code>（如果 <code>c &gt;= 0</code>）。<code>(credits &gt;= 180) ==&gt; master </code>给出了 <code>addCredits(c)</code> 方法的差异化功能，即不仅仅改变学分，还会判断学分情况，从而及时改变 <code>master</code> 变量的取值。如果忽略掉了这个后置条件，实际上就隐藏了设计错误。注意方法的规格不对什么情况调用什么方法做出规定（这实际上是非常细节的实现问题），虽然 JML 提供了 callable 子句来规定一个方法在执行过程可能会调用哪些方法，但是并不会对方法执行的后置条件产生实质影响。</p><p>针对从给定方法实现中来提取规格的场景，实践中往往会有方法调用，这时需要把被调用方法的后置条件附加到当前方法，并增加关于该方法被调用条件的约束。可以很清楚的看到，<code>addCredits</code> 规格合并了 <code>changeToMaster</code> 的后置条件，但增加了相应的调用条件约束（<code>credits &gt;= 180</code>）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;规格&quot;&gt;&lt;a href=&quot;#规格&quot; class=&quot;headerlink&quot; title=&quot;规格&quot;&gt;&lt;/a&gt;规格&lt;/h1&gt;&lt;h2 id=&quot;什么是规格&quot;&gt;&lt;a href=&quot;#什么是规格&quot; class=&quot;headerlink&quot; title=&quot;什么是规格&quot;&gt;&lt;/a&gt;什么是规</summary>
      
    
    
    
    <category term="ObjectOriented" scheme="http://yoursite.com/categories/ObjectOriented/"/>
    
    
    <category term="OOP" scheme="http://yoursite.com/tags/OOP/"/>
    
    <category term="JML" scheme="http://yoursite.com/tags/JML/"/>
    
  </entry>
  
  <entry>
    <title>「OS」IO管理</title>
    <link href="http://yoursite.com/2021/05/19/OperatingSystem/OS-IO%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2021/05/19/OperatingSystem/OS-IO%E7%AE%A1%E7%90%86/</id>
    <published>2021-05-19T08:46:00.000Z</published>
    <updated>2021-05-26T15:51:20.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="I-O-设备"><a href="#I-O-设备" class="headerlink" title="I/O 设备"></a>I/O 设备</h1><p>可以将数据输入到计算机，或接收计算机输出数据的外部设备。</p><p>UNIX 系统将外部设备抽象为一种特殊的文件 ，用户可以使用与文件操作相同的方式对外部设备进行操作。</p><p><strong>总线（<code>Bus</code>）</strong>是接入 I/O 设备的主要方式  </p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>按使用特性：人机交互类、存储类、网络通信类</p><p>按信息交换单位 ：</p><ul><li>块设备：数据传输单位为块，传输速率高，可寻址。如磁盘</li><li>字符设备：数据传输单位为字符，一般采用中断驱动。如鼠标键盘等。</li></ul><h1 id="I-O-控制器"><a href="#I-O-控制器" class="headerlink" title="I/O 控制器"></a>I/O 控制器</h1><p>CPU 通过一个电子部件——I/O 控制器来实现 CPU 对设备的控制。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>接受和识别 CPU 发出的指令。I/O 寄存器有相应的<strong>控制寄存器</strong>来存放命令和参数。</li><li>向 CPU 报告设备的状态。I/O 控制器有相应的<strong>状态寄存器</strong>记录 I/O 设备当前的状态。</li><li>数据交换。I/O 控制器中会设置相应的数据寄存器。输出时，数据寄存器用于暂存C PU发来的数据，之后再由控制器传送备。输入时，数据寄存器用于暂存设备发来的数据，之后C PU从数据寄存器中取走数据。</li><li>地址识别。类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的“地址”。I/O控制器通过CPU提供的“地址”来判断CPU要读／写的是哪个寄存器<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2></li></ul><p><img src="https://pic.imgdb.cn/item/60a4ec656ae4f77d35e5b4e8.jpg"></p><ul><li>一个 I/O 控制器可能对应多个设备</li><li>相应的，数据寄存器、控制寄存器、状态寄存器也会有多个。有的计算机在内存地址后继续编址，称为<strong>内存映像 I/O</strong>。有的采用 I/O 专用地址，即寄存器<strong>独立编址</strong></li></ul><p>内存映像 I/O 简化了指令，可以采用对内存进行操作的指令对控制器进行操作。而独立编址则需要设置专门的指令来实现。</p><h1 id="I-O-控制方式"><a href="#I-O-控制方式" class="headerlink" title="I/O 控制方式"></a>I/O 控制方式</h1><h2 id="程序直接控制"><a href="#程序直接控制" class="headerlink" title="程序直接控制"></a>程序直接控制</h2><p>读操作：</p><ol><li>CPU 向 I/O 控制器发出读指令，设备启动，状态寄存器设为 1（未就绪）</li><li>CPU <strong>轮询</strong>检查 I/O 控制器的状态</li><li>输入设备准备好数据后将数据传给控制器，报告自身状态</li><li>控制器将输入的数据放到数据寄存器当中，将状态改为 0（已就绪）</li><li>CPU 发现设备已就绪，就将数据寄存器中的内容读入 CPU 的寄存器中，再将 CPU 寄存器中的内容放入内存。</li></ol><p>数据传输单位：每次读写一个字</p><p>数据流向：</p><ul><li>读：I/O 设备 -&gt; CPU -&gt; 内存</li><li>写：内存 -&gt; CPU -&gt; I/O 设备</li></ul><p>缺点：</p><ul><li>CPU 长期处于”忙等”状态，利用率低</li></ul><h2 id="中断驱动"><a href="#中断驱动" class="headerlink" title="中断驱动"></a>中断驱动</h2><p>在CPU发出读／写命令后，将等待 I/O 的进程阻塞，切换到别的进程执行。当 I/O 完成后，控制器会向CPU发出一个中断信号，CPU检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。处理中断的过程中，CPU从 I/O 控制器读一个字的数据传送到CPU寄存器，再写入主存。接着，CPU恢复等待I/O的进程（或其他进程）的运行环境，然后继续执行。</p><ul><li>CPU会在每个指令周期的末尾检查中断； </li><li>如果中断发生的频率太高，也会降低系统性能。</li></ul><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>DMA方式（Direct Memory Access，直接存储器存取。主要用于块设备的 I/O 控制），由一个专门的控制器来完成数据从内存到设备或者是从设备到内存的传输工作。</p><ul><li>数据的传送单位是“块”。</li><li>数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU作为中转。</li><li>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</li></ul><p><img src="https://pic.imgdb.cn/item/60a4f8ab6ae4f77d353227a5.jpg"></p><ul><li>DR （Data Register，数据寄存器）：暂存从设备到内存，或从内存到设备的数据。</li><li>MAR （Memory Address Register，内存地址寄存器）：在输入时，MAR表示数据应放到内存中的什么位置；输出时MAR表示要输出的数据放在内存中的什么位置。</li><li>DC（Data Counter，数据计数器）：表示剩余要读/写的字节数。</li><li>CR（Command Register，命令／状态寄存器）：用于存放CPU发来的I/O命令，或设备的状态信息。</li></ul><p>首先，CPU指明此次要进行的操作，并说明要读入多少数据、数据要存放在内存的什么位置、数据在外部设备上的地址（如：在磁盘上的地址）</p><p>控制器会根据CPU提出的要求完成数据的读／写工作，整块数据的传输完成后，才向CPU发出中断信号</p><p>CPU干预的频率：</p><ul><li>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</li></ul><p>数据传送的单位：</p><ul><li>每次读/写一个或多个块（注意：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）</li></ul><p>数据的流向（不再需要经过CPU）</p><ul><li>读操作（数据输入）：I/O设备→内存</li><li>写操作（数据输出）：内存→ I/O设备</li></ul><p>缺点：CPU每发出一条 I/O 指令，只能读／写一个或多个连续的数据块。如果要读／写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条 I/O 指令，进行多次中断处理才能完成。</p><h2 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h2><p>通道：一种硬件，可以识别并执行一系列通道指令</p><p>流程：</p><ul><li>CPU向通道发出I/O指令。指明通道程序在内存中的位置，并指明要操作的是哪个 I/O 设备。之后CPU就切换到其他进程执行了</li><li>通道执行内存中的通道程序（其中指明了要读入／写出多少数据，读／写的数据应放在内存的什么位置等信息）</li><li>通道执行完规定的任务后，向CPU发出中断信号，之后CPU对中断进行处理</li></ul><p>CPU干预的频率：极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读／写后才需要发出中断信号，请求CPU干预。</p><p>数据传送的单位：每次读/写一组数据块</p><p>缺点：实现复杂，需要专门的通道硬件支持<br>优点：CPU、通道、I/O 设备可并行工作，资源利用率很高。</p><h1 id="I-O-软件层次结构"><a href="#I-O-软件层次结构" class="headerlink" title="I/O 软件层次结构"></a>I/O 软件层次结构</h1><p><img src="https://pic.imgdb.cn/item/60a506536ae4f77d35a2e295.jpg"></p><ul><li>用户层软件：用户可直接使用该层提供的与 I/O 操作相关的库函数（Windows API）对设备进行操作；同时通过“系统调用”请求操作系统内核的服务</li><li>设备独立性软件：与设备硬件特性无关的功能基本均在这一层实现<ol><li>向上层提供统一的调用接口</li><li>设备保护。原理类似文件保护，不同用户对设备的访问权限也不同</li><li>差错处理。对一些设备的错误进行的处理。</li><li>设备的分配与回收。</li><li>数据缓冲区管理。通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</li><li>建立逻辑设备名到物理设备名的映射，根据设备类型选择调用相的驱动程序。这是根据<strong>逻辑设备表</strong>（LUT）来实现的。<br>操作系统系统可以采用两种方式管理逻辑设备表（LUT）：第一种：整个系统只设置一张LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。第二种：为每个用户设置一张LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。</li></ol></li><li>设备驱动程序：主要负责对硬件设备的具体控制，将上层命令转化为特定设备可执行的一系列操作，如设置设备寄存器、检查设备状态等。<br>  由于不同的 I/O 设备往往有不同的硬件特性 ，因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序</li><li>中断处理程序：进行中断处理</li><li>硬件</li></ul><p>设备独立性：</p><p>​    应用程序独立于具体使用的物理设备。为了实现设备独立性而引入了逻辑设备和物理设备这两个概念。在应用程序中， 使用逻辑设备名称来请求使用某类设备；而系统在实际执行时， 还必须使用物理设备名称。因此，系统须具有将逻辑设备名称转换为某物理设备名称的功能。</p><h1 id="I-O-核心子系统"><a href="#I-O-核心子系统" class="headerlink" title="I/O 核心子系统"></a>I/O 核心子系统</h1><h2 id="I-O调度"><a href="#I-O调度" class="headerlink" title="I/O调度"></a>I/O调度</h2><p>磁盘调度：（先来先服务算法、最短寻道优先算法、SCAN算法、C-SCAN算法、LOOK算法、C-LOOK算法）。当多个磁盘 I/O请求到来时，用某种调度算法确定满足 I/O 请求的顺序。</p><h2 id="设备保护"><a href="#设备保护" class="headerlink" title="设备保护"></a>设备保护</h2><p>每个设备也有对应的 FCB，当用户请求访问某个设备时，系统根据 FCB 中记录的信息来判断该用户是否有相应的访问权限，从而实现”设备保护”</p><h2 id="假脱机技术（SPOOLing）"><a href="#假脱机技术（SPOOLing）" class="headerlink" title="假脱机技术（SPOOLing）"></a>假脱机技术（SPOOLing）</h2><p><strong>脱机技术</strong>：</p><p>脱机技术指的是脱离主机的控制进行输入输出操作。很久以前是纸带输入，速度太慢，于是通过外围控制机将纸带数据输入到磁带，再输入主机，输出同理。<br>作用：​缓解CPU与慢速I/O设备的速度矛盾，实现预输入、缓输出。</p><p><strong>假脱机技术</strong>：利用软件的方式模拟脱机技术。可以把一台物理设备虚拟成逻辑上的多台设备。</p><h3 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h3><p><img src="https://pic.imgdb.cn/item/60a50e616ae4f77d35e8a72d.jpg"><br>输入井和输出井：模拟脱机输入/输出时的磁带</p><p>输入进程和输出进程：模拟脱机输入/输出时的外围控制机</p><h3 id="共享打印机原理"><a href="#共享打印机原理" class="headerlink" title="共享打印机原理"></a>共享打印机原理</h3><p><img src="https://pic.imgdb.cn/item/60a510256ae4f77d35f8298f.jpg"></p><p>虽然系统中只有一台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。</p><h2 id="设别的分配与回收"><a href="#设别的分配与回收" class="headerlink" title="设别的分配与回收"></a>设别的分配与回收</h2><p>设备分配时应考虑的因素有：</p><ul><li>设备的固有属性<ul><li>独占设备：一个时间段只能分配给一个进程（如打印机）</li><li>共享设备：可同时分配给多个进程（如磁盘），但各进程往往是宏观上同时共享使用设备，而微观上交替使用</li><li>虚拟设备：采用 SPOOLing 技术将独占设备改造成虚拟的共享设备</li></ul></li><li>设备分配算法</li><li>设备分配中的安全性<ul><li>安全分配方式：为进程分配一个设备后就将进程阻塞， I/O 完成再唤醒。一个时段内每个进程只能使用一个设备<br>  优点：破坏了“请求和保持”条件，不会死锁<br>  缺点：对于一个进程来说，CPU和 I/O 设备只能串行工作        </li><li>不安全分配方式：进程请求I/O，操作系统负责分配设备，进程可以继续执行或者请求新的I/O，直到某个I/O无法满足才阻塞进程。<br>  优点：进程的计算任务和 I/O 任务可以并行处理，使进程迅速推进<br>  缺点：有可能发生死锁</li></ul></li></ul><h3 id="静态分配和动态分配"><a href="#静态分配和动态分配" class="headerlink" title="静态分配和动态分配"></a>静态分配和动态分配</h3><p>静态分配：进程运行前为其分配全部所需资源，结束后归还。（破坏”请求和保持”条件，不会死锁）</p><p>动态分配：进程运行过程中动态申请设备资源</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>一个通道控制多个设备控制器，一个设备控制器控制多个设备。<br>因此系统为每个设备配置一张设备控制表（DCT）用于记录设备情况<br><img src="https://pic.imgdb.cn/item/60a608526ae4f77d354fee62.jpg"></p><p>每个设备控制器都会对应一张控制器控制表（COCT）。<br><img src="https://pic.imgdb.cn/item/60a608f46ae4f77d3555edd7.jpg"></p><p>每个通道对应一张通道控制表（CHCT）。</p><p>系统中还有系统设备表（SDT），记录了系统中全部设备的情况。</p><p><img src="https://pic.imgdb.cn/item/60a609df6ae4f77d355f2472.jpg"></p><p> <strong>分配过程</strong>：</p><p><img src="https://pic.imgdb.cn/item/60a60ab16ae4f77d356732d2.png"></p><p>注：只有设备、控制器、通道三者都分配成功，此次设备分配才算成功，之后便可启动 I/O 设备进行数据传送</p><p><strong>分配过程改进</strong>：</p><p><img src="https://pic.imgdb.cn/item/60a60cbb6ae4f77d357a894a.png"></p><p>逻辑设备表（LUT）建立了逻辑设备名与物理设备名之间的映射关系。</p><p>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项。</p><p>如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址。</p><p>逻辑设备表的设置问题：</p><ul><li>整个系统只有一张LUT：各用户所用的逻辑设备名不允许重复，适用于单用户操作系统</li><li>每个用户一张LUT：不同用户的逻辑设备名可重复，适用于多用户操作系统</li></ul><h2 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h2><p>缓冲区是一个存储区域， 可以使用专门的硬件寄存器实现，成本高容量小（如 TLB）<br>更多时候使用内存做缓冲区<br>作用：</p><ul><li>缓和CPU与I/O的速度矛盾</li><li>减少对CPU的中断频率，放宽对CPU中断的时间限制（中断驱动的字符型设备）</li><li>解决数据粒度不匹配的问题（输出进程每次生成一块数据，但 I/O 设备每次只能输出一个字符）</li><li>提高CPU与I/O的并行性</li></ul><h3 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h3><p>假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）。</p><p>注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。<br><img src="https://pic.imgdb.cn/item/60a756946ae4f77d35fa425e.png"><br><img src="https://pic.imgdb.cn/item/60a756a96ae4f77d35fadc46.jpg"></p><h3 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h3><p>顾名思义，在主存分配两个缓冲区。<br><img src="https://pic.imgdb.cn/item/60a761b86ae4f77d355a7bd3.png"><br><img src="https://pic.imgdb.cn/item/60a761b86ae4f77d355a7c29.jpg"></p><p>管道通信中的”管道”就是缓冲区。因此要实现数据双向传输，就必须设置两个管道</p><h3 id="循环缓冲区"><a href="#循环缓冲区" class="headerlink" title="循环缓冲区"></a>循环缓冲区</h3><p>将多个大小相等的缓冲区链接成一个循环队列。</p><p><img src="https://pic.imgdb.cn/item/60ac4de608f74bc15916ca0c.jpg"></p><h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为：空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。</p><p>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：用于收容输入数据的工作缓冲区（hin）、用于提取输入数据的工作缓冲区（sin）、用于收容输出数据的工作缓冲区（hout）、用于提取输出数据的工作缓冲区（sout）</p><p><img src="https://pic.imgdb.cn/item/60ac4f5f08f74bc15922cdf3.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;I-O-设备&quot;&gt;&lt;a href=&quot;#I-O-设备&quot; class=&quot;headerlink&quot; title=&quot;I/O 设备&quot;&gt;&lt;/a&gt;I/O 设备&lt;/h1&gt;&lt;p&gt;可以将数据输入到计算机，或接收计算机输出数据的外部设备。&lt;/p&gt;
&lt;p&gt;UNIX 系统将外部设备抽象为一种特</summary>
      
    
    
    
    <category term="OperatingSystem" scheme="http://yoursite.com/categories/OperatingSystem/"/>
    
    
    <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>「C++ 内存管理」</title>
    <link href="http://yoursite.com/2021/05/18/cpp/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2021/05/18/cpp/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-05-18T01:00:15.000Z</published>
    <updated>2021-05-23T13:42:32.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h1><p><img src="https://pic.imgdb.cn/item/60a25ffe6ae4f77d35e76384.jpg"></p><ul><li><strong>代码段</strong>：程序的所有指令会存放在这个区域，这是已经编译后的机器码。</li><li><strong>字面量池</strong>：程序初始化时的一些字符串字面量，在程序中用于显示文字</li><li><strong>全局数据段</strong>：程序初始化时的常量和全局/静态的变量。C/C++ 用<code>global/static</code>声明的变量都存放在这个区域，对所有函数公开可见。</li><li><strong>堆</strong>：这里保存的数据只是为了临时存储一些值而创建的，而我们可能在程序运行过程中可能会回收此内存。因为我们在程序执行期间不需要很长时间，所以使用C中的<code>new</code>或<code>malloc</code>这类内存分配程序来为我们所需的特定数据类型提供新的空间，并且随着我们要求越来越多的动态数据空间而该区域不断扩大，并且在内存中逐渐增长到更高的地址。</li><li><strong>栈</strong>：存储着该程序 “上下文”，它将从内存的高层地址开始，然后向另一个方向向下扩展。<strong>上下文</strong>其实就是程序中各个函数之间调用的<strong>先后顺序</strong>。</li></ul><h1 id="程序栈帧"><a href="#程序栈帧" class="headerlink" title="程序栈帧"></a>程序栈帧</h1><p>帧（<code>frame</code>），在进程中每个函数被调用时分别从这个栈占用一段区域，就称为帧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存布局&quot;&gt;&lt;a href=&quot;#内存布局&quot; class=&quot;headerlink&quot; title=&quot;内存布局&quot;&gt;&lt;/a&gt;内存布局&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://pic.imgdb.cn/item/60a25ffe6ae4f77d35e76384.j</summary>
      
    
    
    
    <category term="C++ 内存管理" scheme="http://yoursite.com/categories/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
    <category term="内存管理" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>「C++ 基础」泛型与模板</title>
    <link href="http://yoursite.com/2021/05/16/cpp/4%20-%20%E6%B3%9B%E5%9E%8B%E4%B8%8E%E6%A8%A1%E6%9D%BF/"/>
    <id>http://yoursite.com/2021/05/16/cpp/4%20-%20%E6%B3%9B%E5%9E%8B%E4%B8%8E%E6%A8%A1%E6%9D%BF/</id>
    <published>2021-05-16T01:00:15.000Z</published>
    <updated>2021-05-23T13:46:23.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b&lt;a?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T是模板的**模板参数(Template Parameter)**，可以表示一个具体的数据类型，例如<code>int</code>,<code>double</code>,<code>std::string</code></p><p><code>typename</code>关键字来定义模板参数，也可以使用<code>class</code>关键字替换</p><p><code>T a, T b</code>称<strong>调用参数</strong></p><p>函数体称<strong>模板函数</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数模板&quot;&gt;&lt;a href=&quot;#函数模板&quot; class=&quot;headerlink&quot; title=&quot;函数模板&quot;&gt;&lt;/a&gt;函数模板&lt;/h1&gt;&lt;h2 id=&quot;术语&quot;&gt;&lt;a href=&quot;#术语&quot; class=&quot;headerlink&quot; title=&quot;术语&quot;&gt;&lt;/a&gt;术语&lt;/h</summary>
      
    
    
    
    <category term="C++ 基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>「C++ 基础」重载</title>
    <link href="http://yoursite.com/2021/05/15/cpp/3%20-%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2021/05/15/cpp/3%20-%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2021-05-15T01:00:15.000Z</published>
    <updated>2021-05-26T15:03:35.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><p>为方便使用，C++ 允许在同一个作用域内，声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，不能仅通过返回类型的不同来重载函数。 </p><p>当调用一个<strong>重载函数</strong>或<strong>重载运算符</strong>时，编译器通过把所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为<strong>重载决策</strong>。 </p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，不能仅通过返回类型的不同来重载函数。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">printData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;整数为: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c[])</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字符串为: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   printData pd;</span><br><span class="line">   <span class="comment">// 输出整数</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="number">5</span>);</span><br><span class="line">   <span class="comment">// 输出字符串</span></span><br><span class="line">   <span class="keyword">char</span> c[] = <span class="string">&quot;Hello C++&quot;</span>;</span><br><span class="line">   pd.<span class="built_in">print</span>(c);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>允许程序使用表达式而不是命名函数，可以编写和阅读更容易。</p><p>重载函数的函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。 </p><p>将多个合法操作符连接也是合法的。如可以定义一个<code>operator **</code>来用于幂运算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp;);</span><br></pre></td></tr></table></figure><p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp;, <span class="keyword">const</span> Box&amp;);</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        Box box;</span><br><span class="line">        box.length = <span class="keyword">this</span>-&gt;length + b.length;</span><br><span class="line">        box.breadth = <span class="keyword">this</span>-&gt;breadth + b.breadth;</span><br><span class="line">        box.height = <span class="keyword">this</span>-&gt;height + b.height;</span><br><span class="line">        <span class="keyword">return</span> box;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> length;</span><br><span class="line">    <span class="keyword">double</span> breadth;</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Box3 = Box1 + Box2;</span><br><span class="line">    volume = Box3.<span class="built_in">getVolume</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Volume of Box3 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可重载的运算符列表：</p><table><thead><tr><th>双目算术运算符</th><th>+ (加)，-(减)，*(乘)，/(除)，% (取模)</th></tr></thead><tbody><tr><td>关系运算符</td><td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于)</td></tr><tr><td>逻辑运算符</td><td>||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td></tr><tr><td>单目运算符</td><td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td></tr><tr><td>自增自减运算符</td><td>++(自增)，–(自减)</td></tr><tr><td>位运算符</td><td>| (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td></tr><tr><td>赋值运算符</td><td>=, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=</td></tr><tr><td>空间申请与释放</td><td>new, delete, new[ ] , delete[]</td></tr><tr><td>其他运算符</td><td><code>()</code>(函数调用)，<code>-&gt;</code>(成员访问)，<code>,</code>(逗号)，<code>[]</code>(下标)</td></tr></tbody></table><p>不可重载的运算符列表：</p><ul><li><code>.</code>：成员访问运算符</li><li><code>.*</code>  <code>-&gt;*</code>：成员指针访问运算符</li><li><code>::</code>：域运算符</li><li><code>sizeof</code>：长度运算符</li><li><code>?:</code>：条件运算符</li><li><code>#</code>： 预处理符号</li></ul><h3 id="一元运算符重载"><a href="#一元运算符重载" class="headerlink" title="一元运算符重载"></a>一元运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Distance</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> feet;   <span class="comment">// 0 到无穷</span></span><br><span class="line">    <span class="keyword">int</span> inches; <span class="comment">// 0 到 12</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 所需的构造函数</span></span><br><span class="line">    <span class="built_in">Distance</span>() &#123;</span><br><span class="line">        feet = <span class="number">0</span>;</span><br><span class="line">        inches = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Distance</span>(<span class="keyword">int</span> f, <span class="keyword">int</span> i) &#123;</span><br><span class="line">        feet = f;</span><br><span class="line">        inches = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 显示距离的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayDistance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;F: &quot;</span> &lt;&lt; feet &lt;&lt; <span class="string">&quot; I:&quot;</span> &lt;&lt; inches &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载负运算符（ - ）</span></span><br><span class="line">    Distance <span class="keyword">operator</span>-()</span><br><span class="line">    &#123;</span><br><span class="line">        feet = -feet;</span><br><span class="line">        inches = -inches;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Distance</span>(feet, inches);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Distance D1(11, 10), D2(-5, 11);</span><br><span class="line"></span><br><span class="line">    -D1;                  <span class="comment">// 取相反数</span></span><br><span class="line">    D1.<span class="built_in">displayDistance</span>(); <span class="comment">// 距离 D1</span></span><br><span class="line"></span><br><span class="line">    -D2;                  <span class="comment">// 取相反数</span></span><br><span class="line">    D2.<span class="built_in">displayDistance</span>(); <span class="comment">// 距离 D2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h3><p>上上例</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Distance</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Distance &amp;d) &#123;</span><br><span class="line">        <span class="keyword">if</span> (feet &lt; d.feet) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (feet == d.feet &amp;&amp; inches &lt; d.inches) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Distance D1(11, 10), D2(5, 11);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (D1 &lt; D2) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;D1 is less than D2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输入输出运算符重载"><a href="#输入输出运算符重载" class="headerlink" title="输入输出运算符重载"></a>输入输出运算符重载</h3><p> C++ 能够使用流提取运算符 &gt;&gt; 和流插入运算符 &lt;&lt; 来输入和输出内置的数据类型。 可以重载流提取运算符和流插入运算符来操作对象等用户自定义的数据类型。 </p><p><strong>注意：</strong> 我们需要把运算符重载函数声明为类的友元函数，这样我们就能不用创建对象而直接调用函数。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Distance</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> feet;   <span class="comment">// 0 到无穷</span></span><br><span class="line">    <span class="keyword">int</span> inches; <span class="comment">// 0 到 12</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 所需的构造函数</span></span><br><span class="line">    <span class="built_in">Distance</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        feet = <span class="number">0</span>;</span><br><span class="line">        inches = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Distance</span>(<span class="keyword">int</span> f, <span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        feet = f;</span><br><span class="line">        inches = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;output, <span class="keyword">const</span> Distance &amp;D)</span><br><span class="line">    &#123;</span><br><span class="line">        output &lt;&lt; <span class="string">&quot;F : &quot;</span> &lt;&lt; D.feet &lt;&lt; <span class="string">&quot; I : &quot;</span> &lt;&lt; D.inches;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;input, Distance &amp;D)</span><br><span class="line">    &#123;</span><br><span class="line">        input &gt;&gt; D.feet &gt;&gt; D.inches;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Distance D1(11, 10), D2(5, 11), D3;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the value of object : &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; D3;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;First Distance : &quot;</span> &lt;&lt; D1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Second Distance :&quot;</span> &lt;&lt; D2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Third Distance :&quot;</span> &lt;&lt; D3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;重载&quot;&gt;&lt;a href=&quot;#重载&quot; class=&quot;headerlink&quot; title=&quot;重载&quot;&gt;&lt;/a&gt;重载&lt;/h1&gt;&lt;p&gt;为方便使用，C++ 允许在同一个作用域内，声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，不能</summary>
      
    
    
    
    <category term="C++ 基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="重载" scheme="http://yoursite.com/tags/%E9%87%8D%E8%BD%BD/"/>
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>「JVM」垃圾回收机制</title>
    <link href="http://yoursite.com/2021/05/14/Java/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2021/05/14/Java/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2021-05-14T02:44:17.000Z</published>
    <updated>2021-05-16T15:14:49.696Z</updated>
    
    <content type="html"><![CDATA[<p>与 C++ 程序设计语言相比，Java 程序设计语言拥有一个独特的语言特性——自动垃圾回收机制 (Garbage Collection)。在 Java 和 C++ 中，新创建一个对象都需要使用 <code>new</code> 运算符。然而，在 C++ 中，程序员需要人工管理内存，对于不再使用的对象使用 <code>delete</code> 运算符显式地回收内存；在 Java 中，程序员无需人工管理内存，JVM 会自动触发垃圾回收，将没有被引用的对象占据的内存空间释放。</p><h2 id="基本垃圾回收机制"><a href="#基本垃圾回收机制" class="headerlink" title="基本垃圾回收机制"></a>基本垃圾回收机制</h2><p>基本的 Java 垃圾回收机制如下：</p><p>首先，垃圾回收器会找出当前哪些对象是正在使用中的，并将其标记为存活对象；以及哪些对象是没有被引用的，并将其标记为未引用对象，这一步称为<strong>标记</strong> 。下图显示了一个标记前后的内存图的样式：</p><p><img src="https://oscimg.oschina.net/oscnet/1459c0fb17fd074a53898d29839ebfaf5ac.jpg" alt="img"></p><p>其次，垃圾回收器会将当前所有未引用对象删除，也就是上图中橙色的部分。</p><p><img src="https://oscimg.oschina.net/oscnet/e6c1fbbf3a3d2d31365d5b74ae5d111333b.jpg" alt="img"></p><p>最后，为了提升性能，在删除完未引用对象后，通常还会采取<strong>压缩</strong>操作，将内存中的存活对象放置在一起，以便后续能够更加高效快捷地分配新的对象。</p><p><img src="https://oscimg.oschina.net/oscnet/01b56829ee40fe72ebca25d554f1adcefce.jpg" alt="img"></p><h2 id="分代垃圾回收机制"><a href="#分代垃圾回收机制" class="headerlink" title="分代垃圾回收机制"></a>分代垃圾回收机制</h2><p>在实际的程序中，如果完全采用上面的基本垃圾回收机制，会导致垃圾回收非常低效，这是因为每一次垃圾回收都需要标记所有的对象并进行删除和压缩；垃圾回收的耗时与分配的对象数量成正相关的联系。</p><p>实际上，对一个程序运行过程中所有对象的存活时间进行统计，可以得到下面的图：</p><p><img src="https://oscimg.oschina.net/oscnet/711116febb97b1ca9f7d75dd6688b06dafe.jpg" alt="img"></p><p>横轴代表程序运行时间，纵轴代表分配的字节</p><p>从图中我们可以看出，大部分对象的存活时间都比较短(聚集在左侧)，存活的对象随着程序的运行逐渐减少，因此，利用对象存活时间的规律对内存中的对象进行分代，可以加快垃圾回收的效率。</p><p>JVM的分代将堆分为如下几个部分：</p><p><img src="https://oscimg.oschina.net/oscnet/805cb061ab8aa9b4f13c372855f13c8b854.jpg" alt="img"></p><p>图中红色部分和橙色部分为新生代，用来存储刚分配的对象和分配不久的对象；蓝色部分为老年代，用来存储存活了一定时期的对象；绿色部分为永久代，主要用来存放类和元数据的信息。</p><p>在 JVM 分代的设计下，垃圾回收被重新设计为如下过程：</p><p>首先，任何新分配的对象都存放于 <code>eden</code> 内存中，此时两个 <code>Survivor</code> 都是空的。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geqksgniujj315g0nk0vl.jpg" alt="image-20200513094116818"></p><p>当新分配的对象达到一定数量时，会将 <code>eden</code> 的空间填满，此时会触发**次垃圾回收(小型垃圾回收)**，我们称之为 <strong><code>MinorGC</code><strong>。具体地，<code>MinorGC</code> 采用的是</strong>标记-复制算法</strong>，首先对 <code>eden</code> 和 <code>FromSurvivorSpace</code> 中的对象进行标记，然后将存活对象复制到 <code>ToSurvivorSpace</code> 中去，随之清空 <code>eden</code> 和 <code>FromSurvivorSpace</code> 中的对象，并将 <code>FromSurvivorSpace</code> 和 <code>ToSurvivorSpace</code> 区域调换，如下图所示：</p><p><img src="https://oscimg.oschina.net/oscnet/bea90b63a47b9fdfae7a31fb3cd8595c894.jpg" alt="img"></p><p>在下一次的 <code>MinorGC</code> 时，会重复同样的操作，<code>Survivor</code> 区会再次发生交换：</p><p><img src="https://oscimg.oschina.net/oscnet/66c2ecf7a0fb11fdca60651c033bbac02d3.jpg" alt="img"></p><p>注意到：从 <code>eden</code> 区迁移到 <code>Survivor</code> 区的对象此时开始有年龄 <code>Age </code>的概念，这里的 <code>Age</code> 是用来表示对象的存活时间，每经过一次 <code>MinorGC</code>，对象的 <code>Age</code> 增加 <code>1</code>。</p><p>经过了一定次数的 <code>MinorGC</code> 后，有些对象的年龄会达到一定的阈值，图中示例为 <code>8</code>，此时这些年龄达到阈值的对象会被转移到老年区 <code>tenured</code> 中，表示为常使用的对象：</p><p><img src="https://oscimg.oschina.net/oscnet/a813815a4e8e6a3601c75ebfc2ae80d9dc7.jpg" alt="img"></p><p>对于老年代中的对象而言，未引用的对象不会在 <code>MinorGC</code> 中被回收，而是在**主垃圾回收 (大型垃圾回收)**，我们称之为 <strong><code>MajorGC</code></strong> 中被回收。</p><p><code>MinorGC</code> 的作用范围是新生代，<code>MajorGC</code> 的作用范围是老年代，<code>MinorGC</code> 发生的频率高，而 <code>MajorGC</code> 发生的频率则较低。老年代中的对象普遍比较稳定，通常会长期存在，所以变化不是特别频繁。<code>MajorGC</code> 采用的是<strong>标记-压缩算法</strong>，也就是上面提到的基本垃圾回收机制。</p><h2 id="代码模拟"><a href="#代码模拟" class="headerlink" title="代码模拟"></a>代码模拟</h2><p>以下是一个简单的垃圾回收机制模拟：</p><ul><li><code>MyObject</code><ul><li>模拟创建的对象</li></ul></li><li><code>MyHeap</code><ul><li>普通小顶堆</li></ul></li><li><code>JvmHeap</code><ul><li>JVM 中的堆，<code>eden</code>、<code>survivor</code>、<code>tenured </code> 均使用堆来实现，继承自<code>MyHeap</code>。</li></ul></li><li><code>MyJvm</code><ul><li>模拟的 JVM，负责管理堆、创建对象、删除对象引用和垃圾回收</li></ul></li><li><code>Main</code><ul><li>模拟程序的输入输出，输入方式为先输入指令名称，换行后再输入参数。</li><li>输入有以下几条指令：<ul><li><code>CreateObject</code> ：创建新的对象，换行后输入创建对象的个数</li><li><code>SetUnreferenced</code> ：将对象设置为未引用，换行后输入删除引用的对象id，用空格分隔</li><li><code>RemoveUnreferenced</code>：直接在堆中移除未引用的对象</li><li><code>MinorGC</code> ：小型垃圾回收</li><li><code>MajorGC</code> ：大型垃圾回收</li><li><code>SnapShot</code> ：查看当前 JVM 中堆的快照</li></ul></li></ul></li></ul><p><code>MyObject.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">MyObject</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> totalId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> <span class="keyword">boolean</span> referenced;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    MyObject() &#123;</span><br><span class="line">        id = totalId;<span class="comment">// 保证创建新对象的id不重复</span></span><br><span class="line">        totalId++;</span><br><span class="line">        referenced = <span class="keyword">true</span>;</span><br><span class="line">        age = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ assignable age;</span></span><br><span class="line"><span class="comment">      @ ensures age == newAge;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> newAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = newAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ ensures \result == age;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ ensures \result == id;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ assignable referenced;</span></span><br><span class="line"><span class="comment">      @ ensures referenced == newReferenced;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReferenced</span><span class="params">(<span class="keyword">boolean</span> newReferenced)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.referenced = newReferenced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ ensures \result == referenced;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function"><span class="keyword">boolean</span> <span class="title">getReferenced</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> referenced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires this == o;</span></span><br><span class="line"><span class="comment">      @ ensures \result == true;</span></span><br><span class="line"><span class="comment">      @ also</span></span><br><span class="line"><span class="comment">      @ requires this != o &amp;&amp; (o == null || !(o instanceof MyObject));</span></span><br><span class="line"><span class="comment">      @ ensures \result == false;</span></span><br><span class="line"><span class="comment">      @ also</span></span><br><span class="line"><span class="comment">      @ requires this != o &amp;&amp; o != null &amp;&amp; o instanceof MyObject;</span></span><br><span class="line"><span class="comment">      @ ensures \result == (id == (MyObject) o.getId() &amp;&amp;</span></span><br><span class="line"><span class="comment">      @         referenced == (MyObject) o.getReferenced() &amp;&amp;</span></span><br><span class="line"><span class="comment">      @         age == (MyObject) o.getAge());</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> MyObject)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        MyObject myObject = (MyObject) o;</span><br><span class="line">        <span class="keyword">return</span> id == myObject.getId() &amp;&amp; referenced == myObject.getReferenced()</span><br><span class="line">                &amp;&amp; age == myObject.getAge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(id, referenced, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires object != null;</span></span><br><span class="line"><span class="comment">      @ ensures ((age &lt; object.age) || (age == object.age &amp;&amp; id &lt; object.id)) ==&gt; (\result == -1);</span></span><br><span class="line"><span class="comment">      @ ensures ((age &gt; object.age) || (age == object.age &amp;&amp; id &gt;= object.id)) ==&gt; (\result == 1);</span></span><br><span class="line"><span class="comment">      @ also</span></span><br><span class="line"><span class="comment">      @ public exceptional_behavior</span></span><br><span class="line"><span class="comment">      @ requires object == null;</span></span><br><span class="line"><span class="comment">      @ signals (NullPointerException e) object == null;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(MyObject object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((age &lt; object.age) || (age == object.age &amp;&amp; id &lt; object.id)) &#123;</span><br><span class="line">        <span class="comment">// 年龄小的更小；年龄相同，则创建早的更小</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyHeap.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gcsimulation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHeap</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;<span class="comment">// 下标从1开始</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;   <span class="comment">// 初始划分的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;   <span class="comment">// 实际堆的大小</span></span><br><span class="line"></span><br><span class="line">    MyHeap(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        elementData = <span class="keyword">new</span> Object[capacity + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ ensures \result == size;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ ensures \result == elementData</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> Object[] getElementData() &#123;</span><br><span class="line">        <span class="keyword">return</span> elementData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires index &gt;= 1 &amp;&amp; index &lt;= getSize();</span></span><br><span class="line"><span class="comment">      @ assignable elementData;</span></span><br><span class="line"><span class="comment">      @ ensures (\forall int i; 1 &lt;= i &amp;&amp; i &lt;= getSize() &amp;&amp; i != index;</span></span><br><span class="line"><span class="comment">      @          \not_modified(elementData[i]));</span></span><br><span class="line"><span class="comment">      @ ensures elementData[index] == element;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="comment">// 置换 index 处数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElementData</span><span class="params">(<span class="keyword">int</span> index, T element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[index] = element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ assignable size;</span></span><br><span class="line"><span class="comment">      @ ensures size == 0;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="comment">// 清除堆的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires newSize &gt;= 0;</span></span><br><span class="line"><span class="comment">      @ assignable size;</span></span><br><span class="line"><span class="comment">      @ ensures size == newSize;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires indexA &gt;= 1 &amp;&amp; indexA &lt;= getSize() &amp;&amp; indexB &gt;= 1 &amp;&amp; indexB &lt;= getSize();</span></span><br><span class="line"><span class="comment">      @ assignable elementData;</span></span><br><span class="line"><span class="comment">      @ ensures (\forall int i; 1 &lt;= i &amp;&amp; i &lt;= getSize() &amp;&amp; i != indexA &amp;&amp; i != indexB;</span></span><br><span class="line"><span class="comment">      @          \not_modified(elementData[i]));</span></span><br><span class="line"><span class="comment">      @ ensures elementData[indexA] == \old(elementData[indexB]);</span></span><br><span class="line"><span class="comment">      @ ensures elementData[indexB] == \old(elementData[indexA]);</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> indexA, <span class="keyword">int</span> indexB)</span> </span>&#123;</span><br><span class="line">        T temp = (T) elementData[indexA];</span><br><span class="line">        elementData[indexA] = elementData[indexB];</span><br><span class="line">        elementData[indexB] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T newElement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">            Object[] oldElementData = elementData.clone();</span><br><span class="line">            <span class="comment">// 现有大小达到划分的容量，动态扩容</span></span><br><span class="line">            capacity = capacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            elementData = <span class="keyword">new</span> Object[capacity + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; i++) &#123;</span><br><span class="line">                elementData[i] = oldElementData[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        elementData[++size] = newElement;</span><br><span class="line">        <span class="keyword">int</span> tempIndex = size;</span><br><span class="line">        <span class="comment">// 将新添加元素向上调整，使其满足小顶堆性质（父节点大于子节点）</span></span><br><span class="line">        <span class="keyword">while</span> (tempIndex / <span class="number">2</span> != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                ((T) elementData[tempIndex]).compareTo((T) elementData[tempIndex / <span class="number">2</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(tempIndex, tempIndex / <span class="number">2</span>);</span><br><span class="line">            tempIndex /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;No element found in list.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除堆顶常规方法，将最后一个元素置换到堆顶，再一路往下调整满足堆结构</span></span><br><span class="line">        elementData[<span class="number">1</span>] = elementData[size--];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; size) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左右儿子都有，那么如果不满足小于两个儿子的小顶堆性质，要保证换到父节点的儿子小于另一个儿子</span></span><br><span class="line">            <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">1</span> &lt;= size) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((T) elementData[index]).compareTo((T) elementData[index * <span class="number">2</span>]) &gt; <span class="number">0</span> ||</span><br><span class="line">                        ((T) elementData[index]).compareTo((T) elementData[index * <span class="number">2</span> + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (((T) elementData[index * <span class="number">2</span> + <span class="number">1</span>]).compareTo(</span><br><span class="line">                            (T) elementData[index * <span class="number">2</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        swap(index * <span class="number">2</span>, index);</span><br><span class="line">                        index = <span class="number">2</span> * index;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        swap(index * <span class="number">2</span> + <span class="number">1</span>, index);</span><br><span class="line">                        index = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index * <span class="number">2</span> &lt;= size) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((T) elementData[index]).compareTo((T) elementData[index * <span class="number">2</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    swap(index * <span class="number">2</span>, index);</span><br><span class="line">                    index = <span class="number">2</span> * index;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JvmHeap.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gcsimulation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmHeap</span> <span class="keyword">extends</span> <span class="title">MyHeap</span>&lt;<span class="title">MyObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    JvmHeap(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传入要设置为未引用的 id list，将id在该list中的对象状态置为未引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUnreferencedId</span><span class="params">(List&lt;Integer&gt; objectId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> id : objectId) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="keyword">this</span>.getSize(); i++) &#123;</span><br><span class="line">                MyObject myObject = (MyObject) <span class="keyword">this</span>.getElementData()[i];</span><br><span class="line">                <span class="keyword">if</span> (myObject.getId() == id) &#123;</span><br><span class="line">                    myObject.setReferenced(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">this</span>.setElementData(i, myObject);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ assignable elementData, size;</span></span><br><span class="line"><span class="comment">      @ ensures size == (\sum int i; 1 &lt;= i &amp;&amp; i &lt;= \old(size) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @                              \old(elementData[i].getReferenced()) == true; 1);</span></span><br><span class="line"><span class="comment">      @ ensures (\forall int i; 1 &lt;= i &amp;&amp; i &lt;= \old(size);</span></span><br><span class="line"><span class="comment">      @          \old(elementData[i].getReferenced()) == true ==&gt;</span></span><br><span class="line"><span class="comment">      @           (\exist int j; 1 &lt;= j &amp;&amp; j &lt;= size; elementData[j].equals(\old(elementData[i]))))</span></span><br><span class="line"><span class="comment">      @ ensures (\forall int i; 1 &lt;= i &amp;&amp; i &lt;= \old(size);</span></span><br><span class="line"><span class="comment">      @          \old(elementData[i].getReferenced()) == false ==&gt;</span></span><br><span class="line"><span class="comment">      @           (\forall int j; 1 &lt;= j &amp;&amp; j &lt;= size;</span></span><br><span class="line"><span class="comment">      @           !elementData[j].equals(\old(elementData[i]))))</span></span><br><span class="line"><span class="comment">      @ ensures (\forall int i; 1 &lt;= i &amp;&amp; i &lt;= size;</span></span><br><span class="line"><span class="comment">      @          (\exists int j; 1 &lt;= j &amp;&amp; j &lt;= \old(size);</span></span><br><span class="line"><span class="comment">      @          elementData[i].equals(\old(elementData[j]))));</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="comment">// 移除 Jvm 堆中所有未标记的元素。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeUnreferenced</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可对原有的堆进行克隆，并通过 clear 方法将堆的 size 置为 0</span></span><br><span class="line">        Object[] oldElementData = <span class="keyword">this</span>.getElementData().clone();</span><br><span class="line">        <span class="keyword">int</span> oldSize = <span class="keyword">this</span>.getSize();</span><br><span class="line">        clear();</span><br><span class="line"><span class="comment">// 遍历原有的堆中的各个对象，调用 add 方法将其中已标记的对象加入至新堆中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= oldSize; i++) &#123;</span><br><span class="line">            MyObject myObject = (MyObject) oldElementData[i];</span><br><span class="line">            <span class="keyword">if</span> (myObject.getReferenced() == <span class="keyword">true</span>) &#123;</span><br><span class="line">                add(myObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires size &gt; 0;</span></span><br><span class="line"><span class="comment">      @ ensures (\exist int i; 1 &lt;= i &amp;&amp; i &lt;= size;</span></span><br><span class="line"><span class="comment">      @          (\forall int j; 1 &lt;= j &amp;&amp; j &lt;= size &amp;&amp; j != i;</span></span><br><span class="line"><span class="comment">      @            elementData[i].compareTo(elementData[j]) == -1) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @           \result == elementData[i]);</span></span><br><span class="line"><span class="comment">      @ also</span></span><br><span class="line"><span class="comment">      @ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires size == 0;</span></span><br><span class="line"><span class="comment">      @ ensures \result == null;</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="comment">// 根据小顶堆性质，堆顶就是年龄最小的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@pure@*/</span> <span class="function">MyObject <span class="title">getYoungestOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getSize() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (MyObject) getElementData()[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyJvm.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gcsimulation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJvm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_TENURING_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JvmHeap eden;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;JvmHeap&gt; survive = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fromSurviveSpace = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> JvmHeap tenured;</span><br><span class="line"></span><br><span class="line">    MyJvm() &#123;</span><br><span class="line">        eden = <span class="keyword">new</span> JvmHeap(DEFAULT_CAPACITY);</span><br><span class="line">        survive.add(<span class="keyword">new</span> JvmHeap(DEFAULT_CAPACITY));</span><br><span class="line">        survive.add(<span class="keyword">new</span> JvmHeap(DEFAULT_CAPACITY));</span><br><span class="line">        tenured = <span class="keyword">new</span> JvmHeap(DEFAULT_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createObject</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            MyObject newObject = <span class="keyword">new</span> MyObject();</span><br><span class="line">            eden.add(newObject);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (eden.getSize() == DEFAULT_CAPACITY) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Eden reaches its capacity,triggered Minor Garbage Collection.&quot;</span>);</span><br><span class="line">                <span class="comment">// 填满eden时，会触发小型垃圾回收机制</span></span><br><span class="line">                minorGC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUnreferenced</span><span class="params">(List&lt;Integer&gt; objectId)</span> </span>&#123;</span><br><span class="line">        eden.setUnreferencedId(objectId);</span><br><span class="line">        survive.get(fromSurviveSpace).setUnreferencedId(objectId);</span><br><span class="line">        tenured.setUnreferencedId(objectId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeUnreferenced</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        eden.removeUnreferenced();</span><br><span class="line">        survive.get(fromSurviveSpace).removeUnreferenced();</span><br><span class="line">        tenured.removeUnreferenced();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">minorGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Eden 中已标记的对象变为 1 岁并转移到 ToSurvivorSpace；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= eden.getSize(); i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) eden.getElementData()[i];</span><br><span class="line">            <span class="keyword">if</span> (!mo.getReferenced()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mo.setAge(mo.getAge() + <span class="number">1</span>);</span><br><span class="line">            survive.get(<span class="number">1</span> - fromSurviveSpace).add(mo);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// FromSurvivorSpace 中已标记的对象老一岁后，若未超过年龄阈值 8，则转移到 ToSurvivorSpace，反之转移到老年区 Tenured；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= survive.get(fromSurviveSpace).getSize(); i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) survive.get(fromSurviveSpace).getElementData()[i];</span><br><span class="line">            <span class="keyword">if</span> (!mo.getReferenced()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mo.setAge(mo.getAge() + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (mo.getAge() &gt; MAX_TENURING_THRESHOLD) &#123;</span><br><span class="line">                tenured.add(mo);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                survive.get(<span class="number">1</span> - fromSurviveSpace).add(mo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 清空 FromSurvivorSpace 和 Eden ，并交换 FromSurvivorSpace 与 ToSurvivorSpace。</span></span><br><span class="line">        eden.setSize(<span class="number">0</span>);</span><br><span class="line">        survive.get(fromSurviveSpace).setSize(<span class="number">0</span>);</span><br><span class="line">        fromSurviveSpace = <span class="number">1</span> - fromSurviveSpace;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">majorGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 拷贝老年区对象副本，清空老年区，将仍在引用状态的对象还回老年区中，相当于移除了未引用对象</span></span><br><span class="line">        Object[] oldElement = tenured.getElementData().clone();</span><br><span class="line">        <span class="keyword">int</span> oldSize = tenured.getSize();</span><br><span class="line">        tenured.setSize(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= oldSize; i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) oldElement[i];</span><br><span class="line">            <span class="keyword">if</span> (!mo.getReferenced()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tenured.add(mo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSnapShot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Eden: &quot;</span> + eden.getSize());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= eden.getSize(); i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) eden.getElementData()[i];</span><br><span class="line">            System.out.print(mo.getId() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Survive 0: &quot;</span> + survive.get(<span class="number">0</span>).getSize());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= survive.get(<span class="number">0</span>).getSize(); i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) survive.get(<span class="number">0</span>).getElementData()[i];</span><br><span class="line">            System.out.print(mo.getId() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MyObject youngestInSurvive0 = survive.get(<span class="number">0</span>).getYoungestOne();</span><br><span class="line">        <span class="keyword">if</span> (youngestInSurvive0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;, the youngest one &quot;</span> + youngestInSurvive0.getId() +</span><br><span class="line">                    <span class="string">&quot;&#x27;s age is &quot;</span> + youngestInSurvive0.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Survive 1: &quot;</span> + survive.get(<span class="number">1</span>).getSize());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= survive.get(<span class="number">1</span>).getSize(); i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) survive.get(<span class="number">1</span>).getElementData()[i];</span><br><span class="line">            System.out.print(mo.getId() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MyObject youngestInSurvive1 = survive.get(<span class="number">1</span>).getYoungestOne();</span><br><span class="line">        <span class="keyword">if</span> (youngestInSurvive1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;, the youngest one &quot;</span> + youngestInSurvive1.getId() +</span><br><span class="line">                    <span class="string">&quot;&#x27;s age is &quot;</span> + youngestInSurvive1.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Tenured: &quot;</span> + tenured.getSize());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tenured.getSize(); i++) &#123;</span><br><span class="line">            MyObject mo = (MyObject) tenured.getElementData()[i];</span><br><span class="line">            System.out.print(mo.getId() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MyObject youngestInTenured = tenured.getYoungestOne();</span><br><span class="line">        <span class="keyword">if</span> (youngestInTenured != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;, the youngest one &quot;</span> + youngestInTenured.getId() +</span><br><span class="line">                    <span class="string">&quot;&#x27;s age is &quot;</span> + youngestInTenured.getAge());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n---------------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Main.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gcsimulation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyJvm myJvm = <span class="keyword">new</span> MyJvm();</span><br><span class="line">        System.out.println(<span class="string">&quot;Start JVM Garbage Collection Simulation.&quot;</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String operation = scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (operation.equals(<span class="string">&quot;CreateObject&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = scanner.nextInt();</span><br><span class="line">                myJvm.createObject(count);</span><br><span class="line">                System.out.println(<span class="string">&quot;Create &quot;</span> + count + <span class="string">&quot; Objects.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">&quot;SetUnreferenced&quot;</span>)) &#123;</span><br><span class="line">                List&lt;Integer&gt; unrefList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span> (scanner.hasNextInt()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> id = scanner.nextInt();</span><br><span class="line">                    unrefList.add(id);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Set id: &quot;</span> + id + <span class="string">&quot; Unreferenced Object.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                myJvm.setUnreferenced(unrefList);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">&quot;RemoveUnreferenced&quot;</span>)) &#123;</span><br><span class="line">                myJvm.removeUnreferenced();</span><br><span class="line">                System.out.println(<span class="string">&quot;Remove Unreferenced Object.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">&quot;MinorGC&quot;</span>)) &#123;</span><br><span class="line">                myJvm.minorGC();</span><br><span class="line">                System.out.println(<span class="string">&quot;Execute Minor Garbage Collection.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">&quot;MajorGC&quot;</span>)) &#123;</span><br><span class="line">                myJvm.majorGC();</span><br><span class="line">                System.out.println(<span class="string">&quot;Execute Major Garbage Collection.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">&quot;SnapShot&quot;</span>)) &#123;</span><br><span class="line">                myJvm.getSnapShot();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Invalid operation.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;End of JVM Garbage Collection Simulation.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;与 C++ 程序设计语言相比，Java 程序设计语言拥有一个独特的语言特性——自动垃圾回收机制 (Garbage Collection)。在 Java 和 C++ 中，新创建一个对象都需要使用 &lt;code&gt;new&lt;/code&gt; 运算符。然而，在 C++ 中，程序员需要人工管</summary>
      
    
    
    
    <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>「C++ 基础」继承 &amp; 多态 内存原理</title>
    <link href="http://yoursite.com/2021/05/14/cpp/2%20-%20%E7%BB%A7%E6%89%BF%20&amp;%20%E5%A4%9A%E6%80%81/"/>
    <id>http://yoursite.com/2021/05/14/cpp/2%20-%20%E7%BB%A7%E6%89%BF%20&amp;%20%E5%A4%9A%E6%80%81/</id>
    <published>2021-05-14T01:00:15.000Z</published>
    <updated>2021-05-26T15:45:37.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承可以重用代码功能和提高执行效率的效果。 </p><p>一个类可以派生自多个类。类派生列表以一个或多个基类命名，形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>-<span class="keyword">class</span>:</span> access-specifier base-<span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure><p>未使用访问修饰符 access-specifier，则默认为 private。 </p><p>一个派生类继承的基类方法不包括如下几种：</p><ul><li>基类的构造函数、析构函数和拷贝构造函数。</li><li>基类的重载运算符。</li><li>基类的友元函数。</li></ul><h2 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h2><p>通常使用 <code>public</code> 继承</p><ul><li><strong>public 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中均不变</li><li><strong>protected 继承：</strong>基类 public 成员的访问属性在派生类中变成 protected。其他两种访问属性不变。</li><li><strong>private 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中均变成 private</li></ul><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>即一个子类可以有多个父类，它继承了多个父类的特性。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;</span>派生类名&gt;:&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类 Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line">      <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类 PaintCost</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintCost</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getCost</span><span class="params">(<span class="keyword">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> area * <span class="number">70</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line">   <span class="keyword">int</span> area;</span><br><span class="line"> </span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">   area = Rect.<span class="built_in">getArea</span>();</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total paint cost: $&quot;</span> &lt;&lt; Rect.<span class="built_in">getCost</span>(area) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>首先明确虚函数的目的：让不同的派生类将继承自父类的同一个虚成员函数(接口)，根据派生类的功能需求进行不同行为的实现，以此达到不同的派生类提供调用层的决策代码同一个函数接口的不同实现版本，从而保持对调用层代码逻辑无需变动,而且隐藏了同一个函数接口的不同版本的实现细节。</p><p>在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。在程序中任意点可以根据所调用的对象类型来选择调用的函数，即<strong>动态链接</strong>。虚函数必须被实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> ReturnType <span class="title">FunctionName</span><span class="params">(Parameter)</span></span>;</span><br></pre></td></tr></table></figure><p>尽管C++编译器允许父类和子类中定义<strong>相同名称</strong>的非虚成员函数，但这是一种不良的设计，因为一个适当的函数名标识了它要实现某个具体的功能。当我们在多个类中要为不同的类实现某个具体功能的不同版本，就应该使用虚函数。</p><p><img src="https://pic.imgdb.cn/item/60ae6c5c08f74bc1591adf07.jpg"></p><p>虚表中存放的是虚函数的地址。</p><p>类的虚表会被这个类的所有对象所共享。类的对象的虚表指针都指向同一个虚表，从这个意义上说，我们可以把虚表简单理解为类的静态数据成员。值得注意的是，虽然虚表是共享的，但是虚表指针并不是，类的每一个对象有一个属于它自己的虚表指针。</p><p>虚指针也是在构造函数里面初始化的，因此构造函数不可能是虚函数，没有初始化的虚指针无法调用虚函数。</p><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>如果在基类中不能对虚函数给出有意义的实现，就会用到纯虚函数。其声明为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funtion1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。</p><p>友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。</p><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p>多继承(环状继承)，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&#123;</span>......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> A&#123;.....&#125;;</span><br></pre></td></tr></table></figure><p>这个菱形继承中，D 的成员变量和成员函数继承到类 A 中变成了两份，这样就可能会产生命名冲突。我们需要在冲突成员前指明它具体来自哪个类：<code>B::chengyuan</code>。</p><p>为解决多继承时的命名冲突和冗余数据问题，c++提出了虚继承，使得在派生类中只保留一份间接基类的成员。</p><p><code>class 类名: virtual 继承方式 父类名</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&#123;</span>......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> A&#123;.....&#125;;</span><br></pre></td></tr></table></figure><p>虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 D 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p><p>此外，如果虚基类的成员只被一条派生路径覆盖，那么仍然可以直接访问这个被覆盖的成员。但是如果该成员被两条或多条路径覆盖了，那就不能直接访问了，此时必须指明该成员属于哪个类。</p><p>假设 D 定义了一个名为 x 的成员变量，当我们在 A 中直接访问 x 时，会有三种可能性：</p><ul><li>如果 B 和 C 中都没有 x 的定义，那么 x 将被解析为 D 的成员，此时不存在二义性。</li><li>如果 B 或 C 其中的一个类定义了 x，也不会有二义性，派生类的 x 比虚基类的 x 优先级更高。</li><li>如果 B 和 C 中都定义了 x，那么直接访问 x 将产生二义性问题。</li></ul><p>可以看到，使用多继承经常会出现二义性问题，必须十分小心。也因此c++之后很多面向对象编程语言都不支持多继承。</p><p>C++标准库中的 iostream 类就是一个虚继承的实际应用案例。iostream 从 istream 和 ostream 直接继承而来，而 istream 和 ostream 又都继承自一个共同的名为 base_ios 的类，是典型的菱形继承。此时 istream 和 ostream 必须采用虚继承，否则将导致 iostream 类中保留两份 base_ios 类的成员。</p><h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p><img src="https://pic.imgdb.cn/item/60a0db976ae4f77d35ba3413.jpg"></p><p>首先，每个使用虚函数的类或从基类派生的虚函数的类都被赋予自己的虚表。该表只是C++编译器在<strong>编译时</strong>设置的<strong>静态数组</strong>。虚表包含当前类中所有虚成员函数的函数指针的相关条目，那么填入虚表的虚成员函数指针有四种来源：</p><ul><li><p>派生类本身原创定义的虚函数。</p></li><li><p>从父类继承的虚成员函数，且该函数未被派生类重写。</p></li><li><p>从父类继承的虚成员函数，但该函数已被派生类重写。需要注意的是，<strong>虚表的虚成员函数指针始终指向该类中的最新的派生版本的虚成员函数</strong>。也就是说重写后，派生类虚表中存的该函数的地址是重写后该函数在内存中的地址。</p></li><li><p>若当前类定义了虚析构函数，那么该类的虚析构函数的函数的地址会“成双成对”地填入虚表中。按照惯例,由于定义类时优先定义解构函数，再实现其他成员函数，因此该虚解构函数对的地址通常会出现在表中头两行。</p><p>为什么是两个函数？</p><ul><li>第一个析构函数，称为**完整对象析构函数(complete object destructor)**，执行销毁操作时无需在对象上调用delete()。</li><li>第二个解构函数称<strong>删除析构函数</strong>( deleting destructor)，在销毁对象后调用delete()。</li><li>两者都摧毁了任何虚拟基类。一个独立的非虚函数称为<strong>基类对象解构函数</strong>(base object destructor)，执行对象的销毁操作，但不执行其<strong>虚拟基类子对象</strong>的销毁操作，并且不调用delete()。</li></ul></li></ul><p>然后，当类对象实例化时，会将<code>*_vptr</code>设置为指向该类的虚表。</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>编译时，多态性是通过<strong>类成员函数重写</strong>和<strong>operator函数重载</strong>实现的。</p><p>运行时，多态性是通过使用继承和虚函数实现的。C++编译器在运行时，根据决策逻辑判断传入对象的类型，然后查找并根据该类虚表中的虚成员函数的地址，进行动态调度目标类中的成员函数。</p><h2 id="静态绑定-amp-动态绑定"><a href="#静态绑定-amp-动态绑定" class="headerlink" title="静态绑定 &amp; 动态绑定"></a>静态绑定 &amp; 动态绑定</h2><p><strong>绑定：</strong>是指将<strong>变量</strong>和<strong>函数名</strong>转换为地址的过程。</p><p><strong>静态绑定</strong>（前绑定）：在程序执行之前，程序编译阶段就确定的绑定。</p><ul><li>早期绑定意味着绑定的函数或者变量，该语句在编译阶段已经被编译成 <strong><code>call 函数地址</code></strong> 或 <strong><code>callq 函数地址</code></strong> 这样的汇编指令格式，并且这些汇编指令中的函数地址在程序编译后是固定不变的。</li><li>优点是效率高、编译器会帮你检查。非虚函数、静态函数都属于静态绑定。</li></ul><p><strong>动态绑定</strong>（后绑定）：是指在运行时才确定的函数调用。</p><ul><li>在一些带有决策性的业务逻辑的代码中，要等到用户的反馈，直到运行时，根据决策的结果才能知道将调用哪个函数。这称为后期绑定(或动态绑定)，动态绑定的技术的本源就是函数指针。在C ++中<strong>运行时多态</strong>正是使用的就是函数指针。</li><li>优点是不用申明类型，运行时方便修改。python 的动态语言特性（无需考虑变量类型）就是因为 Python 的解析器的底层就是用到了运行时的一系列<strong>类型检测</strong>和<strong>类型检测后的内存分配</strong>以及C的<strong>函数指针</strong>的<strong>间接调用</strong>等技术完成了对Python代码的解析和资源初始化，这一切是以低性能为代价的。</li></ul><p>C++编译器仅当遇到如下条件才会做动态绑定：</p><ul><li>通过类型指针,该指针是<code>upcast</code>操作的指针</li><li>该类型指针调用的是虚函数</li></ul><p>体现在汇编中，比如 <code>callq *%rdx</code>，就是调用寄存器中缓存的虚函数指针所指向的虚函数。而如果是静态绑定，那么就会是这样的汇编语句：<code>callq 0x401384</code> </p><h2 id="Upcasting-amp-downcasting"><a href="#Upcasting-amp-downcasting" class="headerlink" title="Upcasting &amp; downcasting"></a>Upcasting &amp; downcasting</h2><p>将派生类对象赋值给基类对象、将派生类指针赋值给基类指针、将派生类引用赋值给基类引用，这在 C++ 中称为向上转型（<code>Upcasting</code>）。向上转型无需强制类型转换，但会丢失精度。</p><p>所谓向下转型（<code>downcasting</code>），即父类对象转换为子类对象，需要类型转换。</p><p>强制类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// false</span></span><br><span class="line">Person p=<span class="keyword">new</span> <span class="built_in">Person</span>();</span><br><span class="line">Student stu=(Student)p;</span><br><span class="line"><span class="comment">// right</span></span><br><span class="line">Person p=<span class="keyword">new</span> <span class="built_in">Student</span>();</span><br><span class="line">Student stu=(Student)p; </span><br></pre></td></tr></table></figure><p>动态类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">destType* dstObj=<span class="keyword">dynamic_cast</span>&lt;destType*&gt;(src)</span><br></pre></td></tr></table></figure><p><code>dynamic_cast</code>是运行时处理的，运行时要进行运行时类型检查。转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。</p><p>如果要进行动态类型转换，基类中一定要有虚函数，因为运行时类型检查需要 “ <strong>运行时类型信息</strong>（<code>Runtime type information，RTTI</code>)”，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表。某些语言实现仅保留有限的类型信息，例如 [ 继承树 ] 信息，而某些实现会保留较多信息，例如对象的属性及方法信息。这确实增加了开销。但是RTTI可以确保进行类型转换(包含隐式转换和动态类型转换)之类的操作可以安全地进行。</p><p>如果运行时<code>src</code>和<code>destType</code>所引用的对象是相同类型，或者存在<code>is-a</code>关系(public继承)则转换成功；否则转换失败。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span>       </span><br><span class="line">    <span class="function">virtualvoid <span class="title">func</span><span class="params">()</span></span>&#123;&#125;           </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&#123;      </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;      </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Derived *pd = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    Base *pb = pd;</span><br><span class="line">Derived *pd2 = <span class="keyword">dynamic_cast</span>&lt;derived*&gt;(pb); <span class="comment">//向下转型，仍然有效地得到一个Derived类实例副本</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类的转换时，在类层次间进行上行转换时，<code>dynamic_cast</code>和<code>static_cast</code>的效果是一样的。在进行下行转换时，<code>dynamic_cast</code>具有类型检查的功能，比 <code>static_cast</code>更安全。</p><h2 id="内存原理"><a href="#内存原理" class="headerlink" title="内存原理"></a>内存原理</h2><p>首先，我们知道对于我们的自定义类型，如果我们没有重载<code>=</code>，是无法强制将一个类型对象类型转换并赋值给另一个类型的对象的。因为当我们尝试执行<code>a=b</code>，那么其实质就是调用了对象 a 的<code>operator=()</code>操作符函数，即等价于如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="keyword">operator</span>=(<span class="keyword">const</span> B &amp;b);</span><br></pre></td></tr></table></figure><p>而对于类实例的指针，我们是可以强制转换并赋值的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span><span class="keyword">int</span> i=<span class="number">1</span>;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span><span class="keyword">double</span> k=<span class="number">1.1</span>;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    A *p=&amp;a;</span><br><span class="line">    B *q=&amp;b;</span><br><span class="line">    p=(A*)q;<span class="comment">// 编译器允许</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若从大尺寸的类B强制类型转换类A，内存会将拷贝低地址位的内存数据，而丢弃高地址位的内存数据。若小尺寸到大尺寸转换，则源操作数的所有字节数据会按低地址到高地址的顺序依次拷贝到目标操作数，目标操作数超出源操作数尺寸的剩余高地址部分数据，编译器会以0填充。</p><p><strong>继承链</strong></p><p>继承动作的实质其实是：派生类通过继承得到类成员函数在内存中的地址。</p><p>父类公开或受保护的成员函数(包括虚函数)同样是被派生类继承，但继承的只是父类成员函数的<strong>调用权</strong>，在继承关系中，派生类从基类继承的成员函数实质上继承的是存储在代码段(<strong>Code Segment</strong>)内存区中，基类可共享的成员函数的内存地址，因为每个成员函数都有一个唯一的<strong>内存地址</strong>。</p><p>而所谓类型，其实就是规定这个类型的变量对哪部分内存拥有操作权限。</p><p>在继承中，派生类都从父类获得一份公开(public)或受保护(protected)的父类数据成员(属性)的副本，也就是说，每个派生类对象内部都持有一份“特殊版本”的父类实例的信息。所以父类类型指针，规定访问的是父类大小的内存区域，若我们将继承类实例化的对象赋给该指针，自然而然父类副本外的内存（即继承类的自定义部分）无法被父类指针访问。</p><p>因此，<code>Upcast</code>操作仅仅是拷贝了派生类中的基类实例副本，派生类所属的内存区域对于基类对象是一无所知的。这也产生了一个问题 —— “**对象切片(<code>Object Slicing</code>)**”，即当拷贝时，派生类原创的成员(属性和方法)会被编译器”阉割”掉。</p><p>在对象切片的作用下可能出现以下情况：</p><ul><li><p>对于非虚成员函数来说，基类对象只能得到基类原创定义且可被继承的成员函数的地址，派生类原创定义的成员函数的地址，对于 upcast 操作后的基类对象是不可见的。</p></li><li><p>对于虚成员函数来说，如下三种情况。对于基类对象运行时绑定哪个虚成员函数的地址，是依据填入基类的虚表的函数地址来判断的。</p><ul><li>若该函数是派生类原创定义的，对于upcast操作后的基类对象是不可见的。</li><li>若该函数是基类原创定义且未被派生类重写，对于 upcast 操作后的基类对象，该基类版本的虚函数可见。</li><li>若该函数是基类原创定义且已被派生类重写，对于 upcast 操作后的基类对象，该派生类版本的虚成员函数可见。</li></ul></li></ul><p><small>注：所谓内存访问限制，访存本身其实是没什么限制的，只是越界了会访问到无效数据而已（比如栈上的对象越界访问可能会访问到其他局部变量，堆上的对象越界访问可能会访问到堆块对齐的部分）编译器能做的只是从语法层面去限制生成越界的访存机器码，而不是防止访存的行为本身（即便编译器也能被骗过）</small></p><p>参考：<a href="https://zhuanlan.zhihu.com/p/192178632">https://zhuanlan.zhihu.com/p/192178632</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h1&gt;&lt;p&gt;继承可以重用代码功能和提高执行效率的效果。 &lt;/p&gt;
&lt;p&gt;一个类可以派生自多个类。类派生列表以一个或多个基类命名，形式如下：&lt;/p&gt;
&lt;f</summary>
      
    
    
    
    <category term="C++ 基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
    <category term="OOP" scheme="http://yoursite.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>「OS」进程管理</title>
    <link href="http://yoursite.com/2021/05/06/OperatingSystem/OS-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2021/05/06/OperatingSystem/OS-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2021-05-06T09:14:23.530Z</published>
    <updated>2021-06-09T07:35:56.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>进程：</strong>为了揭示多道程序、分时系统引发的动态特性（执行-暂停 -执行），而引入了进程。定义可参看内存管理。<br><strong>并发：</strong>有两个活动a1和a2，如果在某一时刻t，无论它们是在同一处理机上还是在不同的处理机上执行，只要都处在各自的起点和终点之间的某一处，则称a1和a2是并发执行的。<br><strong>并行：</strong>两个程序在同一时间度量下同时运行在不同的处理机上，则称这两个程序是并行执行的<br><strong>竞争：</strong>多个进程在读写一个共享数据时结果依赖于它们执行的相对时间<br><strong>竞争条件：</strong>多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关，称为竞争（发生）条件。<br><strong>Bernstein条件：</strong>满足该条件，则程序并发执行结果可再现。该条件可简单理解为两个程序只可以同时读。</p><p><strong>响应时间：</strong>进程到达直至进程结束之间的时间。响应比=响应时间/运行时间</p><h2 id="进程与程序"><a href="#进程与程序" class="headerlink" title="进程与程序"></a>进程与程序</h2><ul><li><strong>进程是动态的，程序是静态的</strong>：程序是有序代码的集合；进程是程序的执行。通常进程不可在计算机之间迁移；而程序通常对应着文件，静态和可以复制。</li><li><strong>进程是暂时的，程序是永久的</strong>：进程是一个状态变化的过程，程序可长久保存。</li><li>进程与程序的<strong>对应关系</strong>：通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。</li></ul><h2 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h2><blockquote><p>由若干条指令所组成的指令序列，来实现某个特定的操作功能<br>原语是操作系统核心组成部分，必须在管态（内核态）下执行，且常驻内存。其指令序列的执行是连续的、不可分割的。</p></blockquote><h3 id="创建原语"><a href="#创建原语" class="headerlink" title="创建原语"></a>创建原语</h3><ul><li>fork<br>创建子进程。一次调用有两个返回值。<br>在fork函数执行完毕后，子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID，如果出现错误则返回负值。</li><li>exec<br>程序替换。<br>当子进程调用exec函数来运行另一个程序时，这个进程的地址空间代码和数据都被新程序的代码和数据刷新替换。<h3 id="撤销原语"><a href="#撤销原语" class="headerlink" title="撤销原语"></a>撤销原语</h3></li><li>kill<br>释放资源、撤销子进程、重新调度<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2></li></ul><p><strong>就绪状态</strong>：进程已获得除处理机外的所需资源，只要分配CPU就可执行。</p><p><strong>执行状态</strong>：占用处理机资源；处于此状态的进程的数目小于等于CPU的数目。在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的idle进程（相当于空操作）。</p><p><strong>阻塞状态</strong>：正在执行的进程，由于发生某种事件而暂时无法执行，便放弃处理机处于暂停状态。</p><p><img src="https://img.imgdb.cn/item/60914edfd1a9ae528ffe8e3e.png"></p><h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h2><p>进程控制的主要任务是<strong>创建</strong>和<strong>撤销</strong>进程，以及实现进程的<strong>状态转换</strong>。</p><p>系统为每个进程定义了一个数据结构：进程控制块<strong>PCB</strong>。在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>进程的创建与撤销。是进程的唯一标志。</p><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ul><li><strong>进程标识符</strong>：每个进程都必须有一个唯一的标识符。Linux系统中是一个整型数。 在进程创建时由系统赋予。</li><li><strong>现场保护区：</strong>进程阻塞释放CPU时，要将CPU的各种状态信息保存</li><li><strong>互斥与同步机制：</strong>用于实现进程间互斥、同步和通信所需的信号量等</li><li>程序和数据地址，当前状态，优先级，资源清单，链接字（指出该进程所在队列中下一个进程PCB的首地址）</li></ul><h3 id="组织方式"><a href="#组织方式" class="headerlink" title="组织方式"></a>组织方式</h3><ul><li>线性表</li></ul><p>不论进程的状态如何，将所有的PCB连续地存放在内存的系统区</p><ul><li>索引方式</li></ul><p>系统按照进程的状态分别建立就绪索引表、 阻塞索引表等</p><ul><li>链接表方式</li></ul><p>系统按照进程的状态将进程的 PCB 组成队列，从而形成就绪队列、阻塞队列、运行队列等。</p><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p><strong>进程上下文</strong>，即一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈上的内容。</p><p>当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。这些内容被保存在任务自己的堆栈中, 入栈工作完成后就把下一个将要运行的任务的当前状况从该任务的栈中重新装入CPU寄存器, 并跳转到下一个进程被中断时的PC，开始下一个任务的运行, 这一过程就是<code>context switch</code>。</p><p>而陷入/退出内核（模态切换 <code>Mode Switch</code>），是由中断、异常、Trap指令（系统调用）引起。系统调用涉及到进程从用户态到内核态的切换（<code>mode switch</code>），此时涉及到的切换主要是寄存器上下文的切换，和通常所说的进程上下文切换（<code>Process Context Switch</code>）不同，mode switch 的消耗相对要小很多。</p><p>注：处理器总处于以下状态中的一种：</p><ol><li>内核态，运行于进程上下文，内核代表进程运行于内核空间；</li><li>内核态，运行于中断上下文，内核代表硬件运行于内核空间；</li><li>用户态，运行于用户空间。</li></ol><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><blockquote><p>线程（<code>thread</code>）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。<br>现代操作系统将资源拥有者称为进程，将可执行单元称为线程。</p></blockquote><h2 id="进程-amp-线程"><a href="#进程-amp-线程" class="headerlink" title="进程 &amp; 线程"></a>进程 &amp; 线程</h2><ul><li>线程间共享相同的地址空间，方便共享资源（也有栈、PC 等私有资源）。而进程地址空间相互独立，同步需要借助消息通信机制。</li><li>进程切换涉及虚拟地址空间的切换而线程不会，有效减少切换造成的开销。</li><li>进程创建/撤销时需要分配/回收大量资源，线程更轻量，开销更少</li><li>多线程并发度更高<h2 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h2><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3></li></ul><blockquote><p><code>User level threads(ULT)</code>，线程在用户空间，是通过 library 模拟的 thread，不需要或仅需要极少的 kernel 支持。由用户程序自行调用、调度和维护。</p></blockquote><p>典型的有：</p><ul><li><code>POSIX Pthreads</code><br>用于线程创建和同步的 POSIX 标准API , 可在用户级或者内核级实现。该 API 规定了线程库的行为，但不限定实现方法，在类 UNIX 系统（Solaris, Linux, Mac OS X）中很常见。</li><li><code>Java Threads</code></li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>线程的创建、撤消和调度不需要OS内核的支持，是在语言或用户库这一级处理，容易进行优化</li><li>可运行在任何操作系统上，只需要线程库的支持<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>用户级线程执行系统调用指令时将导致其所属进程被中断，内核会因此而阻塞所有相关的线程。</li><li>内核只能将处理器分配给进程，即使有多个处理器，也无法实现一个进程中的多个线程的并行执行。<h3 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h3><blockquote><p><code>Kernel level threads (KLT)</code>，kernel 有好几个分身, 一个分身可以处理一件事。支持内核线程的操作系统内核称作<strong>多线程内核</strong></p></blockquote><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4></li><li>CPU调度以线程为单位，由OS的线程调度程序负责线程的调度。内核可以在多个处理器上调度一个进程的多个线程实现同步并行执行</li><li>系统调用导致的阻塞只发生在线程级别</li><li>内核中的一些处理可以通过多线程实现<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4></li><li>一个进程中的线程切换需要内核参与，线程的切换涉及到两个模式的切换（进程-进程、线程-线程）</li><li>效率降低<h3 id="混合的线程实现方式"><a href="#混合的线程实现方式" class="headerlink" title="混合的线程实现方式"></a>混合的线程实现方式</h3><blockquote><p>线程在用户空间创建和管理，实现从用户空间线程到内核空间线程的映射</p></blockquote><h4 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h4>实现用户级线程和内核级线程的连接方式</li><li>Many-to-One Model<br>多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。</li><li>One-to-one Model<br>每个用户级线程映射到一个内核级线程。并发能力较强，但对应用程序性能影响大</li><li>Many-to-Many Model<br>n 个用户级线程映射到 m 个内核级线程上（m $\le$ n）<h1 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2></li></ul><p><strong>临界资源：</strong>一次仅允许一个进程访问的资源</p><p><strong>临界区：</strong>每个进程中访问临界资源的那段代码称为临界区</p><p><strong>进程互斥：</strong>两个或两个以上的进程，不能同时进入关于同一组共享资源的临界区，否则可能发生与时间有关的错误</p><p><strong>进程同步：</strong>系统中各进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性的过程。让本来异步并发的进程相互配合，有序推进。</p><h2 id="临界区管理"><a href="#临界区管理" class="headerlink" title="临界区管理"></a>临界区管理</h2><p><strong>空闲让进：</strong>临界资源处于空闲状态，允许进程进入临界区。临界区内仅有一个进程运行。<br><strong>忙则等待：</strong>临界区有正在执行的进程，所有其他进程则不可以进入临界区。<br><strong>有限等待：</strong>对要求访问临界区的进程，应保证在有限时间内进入自己的临界区，避免死等。<br><strong>让权等待：</strong>当进程（长时间）不能进入自己的临界区时，应立即释放处理机，尽量避免忙等。</p><h2 id="基于信号量的同步与互斥"><a href="#基于信号量的同步与互斥" class="headerlink" title="基于信号量的同步与互斥"></a>基于信号量的同步与互斥</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><blockquote><p>一个确定的二元组(s, q)，其中s是一个具有非负初值的整型变量，q是一个初始状态为空的队列程序。对其访问都是原子操作，且只允许对它进行P(信号变量)和V(信号变量)操作。它用来累计唤醒次数，由 Dijkstra 提出。</p></blockquote><p><strong>semWait 操作（P操作）</strong>：</p><ul><li>使信号量减1。若值为负，则执行 semWait 的进程被阻塞。否则进程继续执行。</li><li>有进程被阻塞时就会进入 q 队列</li></ul><p><strong>semSignal操作（V操作）</strong></p><ul><li>使信号量加1。若值小于或等于零，则被semWait操作阻塞的进程被解除阻塞。<br>PV 操作简单但不安全，使用不当会出现死锁。</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>二元信号量：取值仅为“0”或“1”，主要用作实现互斥。</li><li>一般信号量：初值为可用物理资源的总数，用于进程间的协作同步问题。</li></ul><h3 id="在并发中的应用"><a href="#在并发中的应用" class="headerlink" title="在并发中的应用"></a>在并发中的应用</h3><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>常使用二元信号量的PV操作实现两个进程的互斥。<br>信号量初值为 1，⼀个进程在进⼊临界区之前执⾏semWait操作，退出临界区后再执⾏⼀个semSignal操作。</p><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>想要先执行<code>code1 &amp; code2</code>，再执行<code>code 4</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>; <span class="comment">// 同步信号量初值为 0</span></span><br><span class="line"><span class="built_in">p1</span>() &#123;</span><br><span class="line">    code <span class="number">1</span>;</span><br><span class="line">    code <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">V</span>(S);</span><br><span class="line">    code <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">p2</span>() &#123;</span><br><span class="line">    <span class="built_in">P</span>(S);</span><br><span class="line">    code <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前驱关系"><a href="#前驱关系" class="headerlink" title="前驱关系"></a>前驱关系</h4><p>在”前操作”之后对相应同步变量执行 V 操作</p><p>在”后操作”之前对相应的同步变量执行 P 操作</p><p>例如：<code>S1-&gt;S2, S1-&gt;S3</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">semaphore a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">p1() &#123;</span><br><span class="line">...</span><br><span class="line">S1;</span><br><span class="line">V(a);</span><br><span class="line">V(b);</span><br><span class="line">&#125;</span><br><span class="line">p2() &#123;</span><br><span class="line">...</span><br><span class="line">P(a);</span><br><span class="line">S2;</span><br><span class="line">&#125;</span><br><span class="line">p3() &#123;</span><br><span class="line">...</span><br><span class="line">P(b);</span><br><span class="line">S3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有限并发"><a href="#有限并发" class="headerlink" title="有限并发"></a>有限并发</h4><p>指有n（1≤n≤c，c是⼀个常量）个进程并发执⾏⼀个函数或者⼀个资源。⼀个初始值为c 的信号量可以实现这种并发。</p><h3 id="信号量集机制"><a href="#信号量集机制" class="headerlink" title="信号量集机制"></a>信号量集机制</h3><p>信号量集是指同时需要多个资源时的信号量操作</p><h4 id="AND-型"><a href="#AND-型" class="headerlink" title="AND 型"></a>AND 型</h4><p>将进程需要的所有共享资源一次全部分配给它；待该进程使用完后再一起释放。</p><h4 id="一般型"><a href="#一般型" class="headerlink" title="一般型"></a>一般型</h4><p>进程对信号量$S_i$的测试值为$t_i$（用于信号量的判断，即$S_i &gt;= t_i$，资源数量低于ti时，便不予分配），占用值为 $d_i$（用于信 号量的增减，即$S_i = S_i - d_i$ 和 $S_i = S_i + d_i$ ）</p><h2 id="基于管程的同步与互斥"><a href="#基于管程的同步与互斥" class="headerlink" title="基于管程的同步与互斥"></a>基于管程的同步与互斥</h2><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>信号量机制存在的问题：编写困难、易出错</p><blockquote><p>管程是一种高级同步机制，由四部分组成：1. 管程的名称；2. 局部于管程内部的共享数据结构（变量）说明  3. 对该数据结构进行操作的一组互斥执行的过程；4. 对局部于管程内部的共享数据设置初始值的语句</p><p>这么看，管程其实很像</p></blockquote><p><strong>条件变量：</strong>为了区别等待的不同原因，管程引入了条件变量。不同的条件变量，对应不同原因的进程阻塞等待队列，初始时为空。若条件变量名为X，则调用同步原语的形式为<code>wait(X)</code>和<code>signal(X)</code>。</p><p><strong>与信号量区别：</strong></p><ul><li>条件变量的值不可增减，P-V操作的信号量值可增减</li><li>wait操作一定会阻塞当前进程；但P操作只有当信号量的值小于0时才会阻塞。</li><li>如果没有等待的进程，signal将丢失；而V操作增加了信号量的值，不会丢失。</li><li>访问条件变量必须拥有管程的锁<h3 id="Hoare-管程"><a href="#Hoare-管程" class="headerlink" title="Hoare 管程"></a>Hoare 管程</h3></li></ul><p><strong>入口等待队列</strong>：因为管程是互斥进入的，所以当一个进程试图进入一个已被占用的管程时它应当在管程的入口处等待，因而在管程的入口处应当有一个进程等待队列，称作入口等待队列。<br><strong>紧急等待队列</strong>：如果进程Ｐ唤醒进程Ｑ，则Ｐ等待Ｑ继续；Ｑ执行完又唤醒进程Ｒ，则Ｑ等待Ｒ继续，… 如此，在管程内部，由于执行唤醒操作，可能会出现多个等待进程（已被唤醒，但由于管程的互斥进入而等待），这个管程内部的等待队列被称为紧急等待队列，其优先级高于入口等待队列。</p><h4 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h4><ul><li><code>x.wait()</code><br>如果紧急等待队列非空，则唤醒第一个等待者；否则释放管程的使用权，执行此操作的进程排入x队列尾部（紧急等待队列与x队列的关系：紧急等待队列是由于管程的互斥进入而等待的队列，而x队列是因资源被占用而等待的队列）</li><li><code>x.signal()</code><br>如果x队列为空，则相当于空操作，执行此操作的进程继续；否则唤醒第一个等待者，执行<code>x.signal()</code>操作的进程排入紧急等待队列的<h4 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h4></li><li>mutex 用与互斥<br>初值为 1，进程退出管程时应执行V(mutex)开放管程，以便让其他调用者进入。为了使进程在等待资源期间，其他进程能进入管程， 故在wait操作中也必须执行V(mutex)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P(mutex);        &#x2F;&#x2F; 管程入口</span><br><span class="line">…</span><br><span class="line">Body of F</span><br><span class="line">…</span><br><span class="line">If(next_count &gt; 0)</span><br><span class="line">V(next);</span><br><span class="line">Else</span><br><span class="line">V(mutex);        &#x2F;&#x2F; 管程出口    </span><br></pre></td></tr></table></figure></li><li>next 初值为 0<br>凡发出si gnal操作的进程应该用P(next)挂起自己，直到被释放进程退出管程或产生其他等待条件。<br>进程在退出管程的过程前，须检查是否有别的进程在信号量next上等待，若有，则用V(next)唤醒它。next-count（初值为0），用来记录在next上等待的进程个数</li><li>x-sem 初值为 0<br>申请资源得不到满足时，执行P(x-sem)挂起。由于释放资源时，需要知道是否有别的进程在等待资源，用计数器x-count（初值<br>为0）记录等待资源的进程数。<br>执行signal操作时，应让等待资源的诸进程中的某个进程立即恢复运行，而不让其他进程抢先进入管程，这可以用V(x-se m)来实现<h2 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信 IPC"></a>进程间通信 IPC</h2></li></ul><p><strong>低级通信：</strong>只能传递状态和整数值（控制信息），包括进程互斥和同步所采用的信号量和管程机制。<br><strong>高级通信：</strong>适用于分布式系统，基于共享内存的多处理机系统，单处理机系统，能够传送任意数量的数据，可以解决进程的同步问题和通信问题，主要包括三类：管道、共享内存、消息系统。</p><h3 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h3><ul><li>数据只能向一个方向流动；写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。需要双方通信时，需要建立起两个管道；</li><li>只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）</li><li>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，不属于某种文件系统，而是单独构成一种文件系统，并且只存在于内存中。<h3 id="Named-Pipe-FIFO"><a href="#Named-Pipe-FIFO" class="headerlink" title="Named Pipe / FIFO"></a>Named Pipe / FIFO</h3></li><li>克服了”只能用于具有亲缘关系的进程间通信”的限制</li><li>它提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中。这样，只要可以访问该路径，就能够彼此通过FIFO 相互通信<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3>共享内存是指：同一块物理内存被映射到进程A、B各自的进程地址空间。</li><li>共享内存是最有用的进程间通信方式，也是最快的IPC形式（因为它避免了其它形式的IPC必须执行的开销巨大的缓冲复制）。<ul><li>当多个进程共享同一块内存区域，需要同步机制约束（互斥锁和信号量都可以）。<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3>通过两个通信原语（OS系统调用）:    </li></ul></li><li><code>send (destination, &amp;message)</code></li><li><code>receive(source, &amp;message)</code><h2 id="经典进程互斥与同步问题"><a href="#经典进程互斥与同步问题" class="headerlink" title="经典进程互斥与同步问题"></a>经典进程互斥与同步问题</h2><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3></li></ul><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区取出一个产品并使用。</p><p>producer :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">生产一个产品</span><br><span class="line">    <span class="built_in">P</span>(empty);</span><br><span class="line">    <span class="built_in">P</span>(mutex);</span><br><span class="line">    one &gt;&gt; buffer</span><br><span class="line">    <span class="built_in">V</span>(mutex);</span><br><span class="line">    <span class="built_in">V</span>(full);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>consumer : </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">P</span>(full);</span><br><span class="line">    <span class="built_in">P</span>(mutex);</span><br><span class="line">    one &lt;&lt; buffer</span><br><span class="line">    <span class="built_in">V</span>(mutex);</span><br><span class="line">    <span class="built_in">V</span>(empty);</span><br><span class="line">    使用产品;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>P 操作的互换可能会导致死锁（缓冲区无产品，且先执行 consumer；缓冲区满，producer阻塞）</p><p><strong>多生产者-多消费者</strong></p><p>不同类别的生产者生产的物品不同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">// 实现互斥访问盘子（缓冲区）</span></span><br><span class="line">semaphore apple = <span class="number">0</span>;<span class="comment">// 盘子中有几个苹果</span></span><br><span class="line">semaphore orange = <span class="number">0</span>;<span class="comment">// 盘子中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>;<span class="comment">// 盘子中还可以放多少水果</span></span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/609bbe12d1a9ae528f9bd01c.jpg"></p><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><p>对共享资源的读写操作，任一时刻“写者 ”最多只允许一个，而“读者”则允许多个。即”读写互斥”和”写写互斥”。</p><p>为了不令读进程之间也互斥，而读进 程与写进程又必须互斥访问，那么我们可以让第一个访问文件的读进程“加锁”，让最后一个访问完文件的读进程“解锁”。可以设置一个整数量 count 来记录当前有几个读进程在访问文件。</p><p><strong>读进程优先：</strong></p><p><img src="https://pic.imgdb.cn/item/609bd615d1a9ae528f5f909d.jpg"></p><p><strong>读写公平：</strong></p><p><img src="https://pic.imgdb.cn/item/609bd65dd1a9ae528f61e44a.jpg"></p><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>5个哲学家围绕一张圆桌而坐，桌子上放着5支筷子，每两个哲学家之间放一支；哲学家的动作包括思考和进餐，进餐时需要同时拿起他左边和右边的两支筷子，思考时则同时将两支筷子放回原处。如果筷子已在其他人手上，则需要等待。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>（破除资源互斥） 至多只允许四个哲学家同时（尝试）进餐,以保证至少有一个哲学家能够进餐,最终总会释放出他所使用过的两支筷子,从而可使更多的哲学家进餐。设置信号量room=4。</li><li>（破除资源互斥）对筷子进行编号，每个哲学家按编号从低到高拿起筷子。或者对哲学家编号，奇数号哲学家先拿左，再拿右；偶数号相反。</li><li>（破除保持等待）同时拿起两根筷子，否则不拿起。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//互斥地取筷子  </span></span><br><span class="line"><span class="built_in">Pi</span>()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">P</span>(mutex);  </span><br><span class="line">        <span class="built_in">P</span>(chopstick[i]);  </span><br><span class="line">        <span class="built_in">P</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">//拿右  </span></span><br><span class="line">        <span class="built_in">V</span>(mutex);  </span><br><span class="line">        吃饭  </span><br><span class="line">        <span class="built_in">V</span>(chopstick [i]);  </span><br><span class="line">        <span class="built_in">V</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">//放右  </span></span><br><span class="line">        思考</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h</summary>
      
    
    
    
    <category term="OperatingSystem" scheme="http://yoursite.com/categories/OperatingSystem/"/>
    
    
    <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>「OS」内存管理</title>
    <link href="http://yoursite.com/2021/05/03/OperatingSystem/OS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2021/05/03/OperatingSystem/OS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-05-03T10:07:00.000Z</published>
    <updated>2021-06-08T10:07:19.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>地址空间</strong>：一个进程能够用于访问内存的地址集合</p><p><strong>程序</strong>：是静止的，存放在磁盘上的可执行文件，是进程的实体。</p><p><strong>进程</strong>：是动态的，包括进程控制块 PCB，程序和程序处理对象（数据集），是一个程序的执行过程，是资源分配的基本单位。通常把进程分为系统进程和用户进程。</p><p><strong>作业</strong>：用户需要计算机完成的某项任务，是要求计算机所做工作的集合。通常包括程序、数据、操作说明书。</p><p><strong>系统碎片：</strong>内存中无法被利用的存储空间称为碎片</p><p><strong>内部碎片</strong>：分配给作业的存储空间中未被利用的部分</p><p><strong>外部碎片</strong>：系统中无法利用的小的空闲分区，如分区与分区之间存在的碎片。这是造成内存系统性能下降的主要原因，它可以通过<strong>紧凑技术</strong>等被整理后清除。</p><p><strong>紧凑技术：</strong>通过移动作业，把多个分散的小分区拼接成一个大分区。</p><ul><li>时机：找不到足够大的空闲分区，但总空闲分区容量满足要求。</li><li>实现支撑：<strong>动态重定位</strong></li></ul><h1 id="存储管理的功能"><a href="#存储管理的功能" class="headerlink" title="存储管理的功能"></a>存储管理的功能</h1><ul><li>存储分配和回收</li><li>地址变换<br>  可执行文件生成中的链接技术、程序加载时的重定位技术、进程运行时硬件和软件的地址变换技术</li><li>存储共享和保护</li><li>存储器扩充</li></ul><h1 id="分区式内存管理"><a href="#分区式内存管理" class="headerlink" title="分区式内存管理"></a>分区式内存管理</h1><h2 id="分区式分配"><a href="#分区式分配" class="headerlink" title="分区式分配"></a>分区式分配</h2><p>把内存分为大小相等或不等的分区，每个应用程序占用一个或几个分区。</p><h3 id="固定式分区"><a href="#固定式分区" class="headerlink" title="固定式分区"></a>固定式分区</h3><p>系统初始化时，内存划分为若干固定大小（不一定相等）的连续分区。程序适应分区。</p><ul><li>易于实现</li><li>但内碎片会造成浪费，并且分区总数固定，限制了并发执行的程序数目</li><li>采用分区表来记录分区大小和使用情况</li></ul><h3 id="可变式分区"><a href="#可变式分区" class="headerlink" title="可变式分区"></a>可变式分区</h3><p>分区边界可移动</p><ul><li>没有内碎片，但会有外碎片</li></ul><h2 id="闲置空间的管理"><a href="#闲置空间的管理" class="headerlink" title="闲置空间的管理"></a>闲置空间的管理</h2><p>跟踪内存使用情况的方法有：<strong>位图表示法</strong>和<strong>链表表示法</strong></p><h3 id="位图表示法"><a href="#位图表示法" class="headerlink" title="位图表示法"></a>位图表示法</h3><p>给每个分配单元赋予一个二进制数位,用来记录该分配单元是否闲置</p><ul><li>空间开销固定，时间开销低，但没有容错能力。</li></ul><h3 id="链表表示法"><a href="#链表表示法" class="headerlink" title="链表表示法"></a>链表表示法</h3><p>将分配单元按照是否闲置链接起来。</p><ul><li>有一定的容错能力：链表有被占空间和闲置空间的表项，可以相互验证</li></ul><h2 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h2><h3 id="基于顺序搜索"><a href="#基于顺序搜索" class="headerlink" title="基于顺序搜索"></a>基于顺序搜索</h3><h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><p>每个空闲区按其在内存中地址递增的顺序连在一起，在为作业分配存储区域时，从空闲区域链的始端开始查找，选第一个满足请求的空白块。</p><ul><li>导致空闲碎片集中在低地址区</li></ul><h4 id="下次适应算法"><a href="#下次适应算法" class="headerlink" title="下次适应算法"></a>下次适应算法</h4><p>将所有空闲区组织成一个循环链表，每次为存储请求查找合适分区时，总是从上次查找结束的地方开始</p><ul><li>可能会导致缺乏大的空闲分区</li></ul><h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><p>寻找大小最接近作业要求的存储区域</p><ul><li>产生许多难以利用的小空闲碎片</li></ul><h4 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h4><p>总是寻找最大的空闲区</p><ul><li>缺乏大的空闲分区</li></ul><h3 id="基于索引搜索"><a href="#基于索引搜索" class="headerlink" title="基于索引搜索"></a>基于索引搜索</h3><p>比顺序搜索快，一般用于大中型系统</p><h4 id="快速适应算法"><a href="#快速适应算法" class="headerlink" title="快速适应算法"></a>快速适应算法</h4><p>把空闲分区按容量大小进行分类，常用大小的空闲区设立单独的空闲区链表。系统为多个空闲链表设立一张管理索引表。</p><h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>介于固定分区与可变分区之间的动态分区技术。规定：无论已分配分区或空闲分区，其大小均为$2^k(k\in int)$</p><p>目前应用于 Linux 系统和多处理机系统。</p><p><strong>伙伴</strong>：在分配存储块时将一个大的存储块分裂成两个大小相等的小块，这两个小块称为”伙伴”。</p><p><strong>分配流程：</strong><br>当一个长度为 n 的进程申请内存，若$2^{i-1}&lt;n&lt;2^i$，则在空闲分区大小为$2^i$的空闲分区链表中查找<br>若该长度空闲分区耗尽，则查找大小为$2^{i+1}$的一个空闲分区，将其分为相等的两个分区，一个用于分配，一个加入大小为$2^{i}$的空闲链表中。以此向上类推。</p><p><strong>内存释放：</strong>考虑将被释放块与其伙伴和并成一个大的空闲块，然后继续合并直至不能合并为止。</p><h2 id="分区的存储保护"><a href="#分区的存储保护" class="headerlink" title="分区的存储保护"></a>分区的存储保护</h2><h3 id="界限寄存器法"><a href="#界限寄存器法" class="headerlink" title="界限寄存器法"></a>界限寄存器法</h3><ul><li>上下界寄存器<br>对于一个地址，将其与上界寄存器和下界寄存器比较，如果越界就报告地址错误</li><li>基址、限长寄存器<h3 id="存储保护键法"><a href="#存储保护键法" class="headerlink" title="存储保护键法"></a>存储保护键法</h3>给每个存储块赋予一个单独保护键，相当于一把锁；进入系统的每个作业也赋予一个保护键，相当于一把钥匙。<h2 id="内存扩充"><a href="#内存扩充" class="headerlink" title="内存扩充"></a>内存扩充</h2></li></ul><p><strong>覆盖</strong>与<strong>交换</strong>可以解决小的内存空间运行大的作业的问题。(现代 OS 主要用交换）</p><h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><p>把一个程序划分为一系列功能相对独立的程序段，让执行时不要求同时装入内存的程序段组成一组（称为覆盖段），共享主存的同一个区域。</p><p>一般要求作业各模块之间有明确的调用结构，程序员向系统指明覆盖结构，由 os 自动完成覆盖。</p><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>把暂时不用的进程（等待 I/O）及其数据从主存移至辅存，把指定程序或数据从辅存读入主存，让其在系统中运行。</p><p>交换时，需要：1. 保存前一个进程的现场，寄存器 &amp; 堆栈等。2. 创建新进程的运行现场</p><ul><li>覆盖可以减少单个程序运行所需的空间，交换可以减少多个程序同时占用的内存。</li></ul><h1 id="分页式存储管理"><a href="#分页式存储管理" class="headerlink" title="分页式存储管理"></a>分页式存储管理</h1><p>把一个逻辑地址连续的程序分散存放到若干不连续的内存区域内。既可充分利用内存空间，也可减少移动带来的开销。</p><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>页</strong>：把每个作业的地址空间分成一些大小相等的片，称之为页面。</p><p><strong>存储块/页框</strong>：把物理内存的存储空间也分成和页面大小相同的片。</p><p><strong>页表：</strong>存放在内存中，记录进程的内存分配情况，实现进程运行时的动态重定位。</p><p><strong>纯分页系统：</strong>不具备页面对换功能的分页存储管理方式。在调度一个作业时，必须把它的所有页一次装到主存的页框内。若页框数不足，则作业必须等待。</p><p><strong>地址结构：</strong></p><ul><li>逻辑地址：<code>31~页号~12|11~页内偏移~0</code></li><li>物理地址：<code>21~块号~12|11~块内偏移~0</code></li></ul><p><strong>有效内存访问时间：</strong>（对一级页表）<br>$$<br>EAT=(单次内存访问时间+TLB 查询时间)\times TLB 命中率+(2\times 单次内存访问时间+TLB 查询时间)\times(1-TLB 命中率)<br>$$</p><h2 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h2><p>逻辑地址：把相对地址分为页号和页内地址两部分。<br>页表定位：页表始址＋页号 x 页表项长度。<br>查询页表：读出块号。<br>物理地址：块号＋块内地址。（块内地址＝页内地址）</p><h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><p>由于一级页表在划分页面数很多时会导致页表项很多，占用内存多，因此需要多级页表来实现页表分级，从而实现动态调入页表。</p><h3 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h3><p>将页表再进行分页，离散地将各个页表页面存放在不同的物理块中，同时再建立一张外部页表（即<strong>页目录</strong>）用于记录页表页面对应的物理块号。<br>正在运行的进程需要把页目录调入内存，然后将当前所需的二级页表调入内存，其余二级页表待需要时再调入。</p><h2 id="快表-TLB"><a href="#快表-TLB" class="headerlink" title="快表 TLB"></a>快表 TLB</h2><p>页表机制导致内存访问效率下降。不分页时获取数据只需访存 1 次，而一级页表需要访存 2 次，二级页表需要访存 3 次。</p><p>快表是一种特殊的高速缓冲存储器（Cache），内容是页表中的一部分或全部内容。CPU 产生逻辑地址的页号，首先在快表中寻找，若命中就找出其对应的物理块；若未命中，再到页表中找其对应的物理块，并将相应的页表项复制到快表。若快表中内容满，则按某种算法淘汰某些页。</p><p><img src="https://img.imgdb.cn/item/60911bffd1a9ae528ffe47d1.png"></p><h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><ul><li>有的 TLB 在每个 TLB 表项中还保存有 ASID（ASID 可用来唯一标识进程），这样 TLB 就可以同时包含多个进程的条目。否则每当进程切换时，TLB 就需要被 flushed，因为不同的进程虚拟地址空间相同，不冲刷可能会导致解析为其他进程的虚拟页。</li></ul><h2 id="页目录自映射"><a href="#页目录自映射" class="headerlink" title="页目录自映射"></a>页目录自映射</h2><h2 id="哈希页表"><a href="#哈希页表" class="headerlink" title="哈希页表"></a>哈希页表</h2><h2 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h2><h2 id="页共享与保护"><a href="#页共享与保护" class="headerlink" title="页共享与保护"></a>页共享与保护</h2><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>各进程把需要共享的数据/程序的相应页指向相同物理块<br>但如果共享数据与不共享数据在同一块中，不易保密。而事实上也很难只把共享数据与非共享数据隔离，因为”数据共享”是程序处理逻辑层面的需求。</p><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><ul><li>地址越界保护 </li><li>在页表中设置保护位（定义操作权限：只读、读写、执行等）</li></ul><h1 id="段式内存管理"><a href="#段式内存管理" class="headerlink" title="段式内存管理"></a>段式内存管理</h1><p>一个段可定义为一组逻辑信息，每个作业的地址空间是由一些分段构成的。每个段都有自己的段名（一般为段号）且是一段连续的地址空间，其大小不定。</p><p><strong>段表：</strong>保存在内存中，记录了段与内存位置的对应关系。</p><p><strong>地址结构：</strong>逻辑地址由段和段内地址组成。</p><h2 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h2><p>多用户同时使用一个程序时，我们可以将代码共享而将数据分别保存，这要求代码是可重入的。<br><strong>可重入代码：</strong>也称纯代码，是指在多次并发调用时能安全运行的代码。(不能使用全局/静态变量，不能修改代码本身，不能调用其他不可重入代码）</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li>段是逻辑单位，易于实现信息共享与保护</li><li>能够更好的支持动态的内存需求（如编译器、动态链接）<br>缺点：</li><li>辅存中管理不定长度的分段比较困难<h2 id="地址空间的一维与二维"><a href="#地址空间的一维与二维" class="headerlink" title="地址空间的一维与二维"></a>地址空间的一维与二维</h2></li></ul><p>段式存储管理的作业地址空间是二维的，页式存储管理的作业地址空间是一维的。</p><p>因为段号是程序员自己定义的，要想找到某个数据或指令，需要指定段号和位移两个变量，因此是二维的。而页号是系统自动生成的，本身地址是线性连续的，当要访问特定地址时，只需要提供地址即可。系统会自动将地址划分为页号和页内位移，页号对于程序员来说是没有实际意义的，因此是一维的。</p><h1 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h1><p>将用户程序分为若干段，再将每个段分成若干页。</p><p><strong>地址结构：</strong>段号+段内页号+页内偏移量。因此访问一次数据或指令需访问内存 3 次。</p><h2 id="段表与页表"><a href="#段表与页表" class="headerlink" title="段表与页表"></a>段表与页表</h2><p>每个进程有一张段表，每个段有一张页表。<br>段表包含段号、页表始址和页表长度（每个段的页面数不同）。页表包含页号和页框号。</p><h2 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h2><ul><li>首先从 PCB 中取出段表始址和段表长度，装入段表寄存器。</li><li>利用段表始址与段号得到该段表项在段表中的位置，取出该段的页表始址和页表长度</li><li>利用页表始址和页号得到该页表项在页表中的位置。</li><li>取出该页的物理块号，与页内地址拼接得到物理地址<br>（段表长度和页表长度用于发现并产生越界中断）<h2 id="Intel-X86"><a href="#Intel-X86" class="headerlink" title="Intel X86"></a>Intel X86</h2>X86 的地址映射机制分为：</li><li>段映射机制：将逻辑地址映射到线性地址</li><li>页映射机制：将先行地址映射到物理地址</li></ul><h1 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h1><p>覆盖与交换技术虽部分解决了扩大存储空间的问题，但引入了很多额外的开销。引起这些问题的主要原因是一个作业必须存放在一个连续的内存中。</p><p>虚拟内存是计算机系统存储管理的一种技术，它为每个进程提供了一个一致的、连续完整的私有地址空间。采用虚拟存储技术的操作系统只需将当前所需执行的部分页或段读入内存，将内存与外存统一管理，达到扩充内存的目的。局部性原理使得这一技术有了良好的支撑。</p><h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="进程的逻辑空间"><a href="#进程的逻辑空间" class="headerlink" title="进程的逻辑空间"></a>进程的逻辑空间</h3><p>一个进程的逻辑空间的建立是通过链接器（Linker），将构成进程所需要的所有程序及运行所需环境，按照某种规则装配链接而形成的一种规范格式（布局），按字节从0开始编址。也称为进程的虚拟地址空间。</p><h3 id="交换分区"><a href="#交换分区" class="headerlink" title="交换分区"></a>交换分区</h3><p>交换分区是一段连续的磁盘空间（按页划分的），对用户不可见。它的功能是在物理内存不够的情况下，操作系统把内存中暂时不用的数据，存到硬盘的交换空间，留出物理内存让别的程序运行。<br>在 Linux系统中，交换分区为<code>Swap</code>；在 Windows系统中则以文件的形式存在（<code>pagefile.sys</code>）</p><h2 id="虚拟页式存储管理"><a href="#虚拟页式存储管理" class="headerlink" title="虚拟页式存储管理"></a>虚拟页式存储管理</h2><p>需要在页表中增加：驻留位（标识该页在内存中还是外存中）、外存地址。</p><h3 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h3><p>若从页表中查出该页的信息不在主存而在磁盘上时，发生缺页中断。缺页中断流程如下：</p><ol><li>现场保护：陷入内核态，保存必要的信息（OS及用户进程状态相关的信息）</li><li>页面定位：查找出发生缺页中断的虚拟页面（进程地址空间中的页面）。这个虚拟页面的信息通常会保存在一个硬件寄存器中，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析该指令，通过分析找出发生页面中断的虚拟页面。</li><li>权限检查：检查虚拟地址的有效性及安全保护位。如果发生保护错误，则杀死该进程</li><li>新页面调入 1 ：查找一个空闲的页框（物理内存中的页面），如果没有空闲页框则需要通过页面置换算法找到一个需要换出的页框</li><li>旧页面写回：如果找到的页框中的内容被修改了，则需要将修改的内容保存到磁盘上。（注：此时需要将页框置为忙状态，以防页框被其它进程抢占掉）</li><li>新页面调入 2 ：页框“干净”后，操作系统将保持在磁盘上的页面内容复制到该页框中</li><li>更新页表：当磁盘中的页面内容全部装入页框后，向CPU发送一个中断。操作系统更新内存中的页表项，将虚拟页面映的页框号更新为写入的页框，并将页框标记为正常状态</li><li>恢复现场：恢复缺页中断发生前的状态，将 PC 重新指向引起缺页中断的指令，继续执行</li></ol><p><img src="https://pic.imgdb.cn/item/60bf414f844ef46bb2952b0b.png"></p><h3 id="页面调度策略"><a href="#页面调度策略" class="headerlink" title="页面调度策略"></a>页面调度策略</h3><p>虚拟存储器系统通常定义三种策略来规定如何进行页面调度：调入策略、置页策略和置换策略。</p><h4 id="调入策略"><a href="#调入策略" class="headerlink" title="调入策略"></a>调入策略</h4><p>调入策略决定什么时候将一个页由外存调入内存之中。</p><h5 id="请求调页（demand-paging）"><a href="#请求调页（demand-paging）" class="headerlink" title="请求调页（demand paging）"></a>请求调页（demand paging）</h5><p>只调入发生缺页时所需的页面。这种调入策略实现简单，但容易产生较多的缺页中断，造成对外存I/O次数多，时间开销过大，容易产生抖动现象。</p><h5 id="预调页（prepaging）"><a href="#预调页（prepaging）" class="headerlink" title="预调页（prepaging）"></a>预调页（prepaging）</h5><p>在发生缺页需要调入某页时，一次调入该页以及相邻的几个页。这种策略提高了调页的I/O效率，减少了I/O次数。但由于这是一种基于局部性原理的预测，若调入的页在以后很少被访问，则造成浪费。这种方式常在程序装入时使用。</p><h4 id="置页策略"><a href="#置页策略" class="headerlink" title="置页策略"></a>置页策略</h4><p>当线程产生缺页中断时，内存管理器还必须确定将调入的虚拟页放在物理内存的何处。用于确定最佳位置的一组规则称为“<strong>置页策略</strong>”。<br>选择页框应使CPU内存高速缓存不必要的震荡最小。</p><h4 id="置换策略"><a href="#置换策略" class="headerlink" title="置换策略"></a>置换策略</h4><p>如果缺页中断发生时物理内存已满，“置换策略”被用于确定哪个虚页面必须从内存中移出，为新的页面腾出空位，即调整驻留集的大小。</p><h5 id="固定分配局部置换"><a href="#固定分配局部置换" class="headerlink" title="固定分配局部置换"></a>固定分配局部置换</h5><p>为每一进程分配固定的页数的内存空间，在整个运行期间都不再改变。如果进程在运行中出现缺页，则只能从该进程的N个页面中选出一个换出，再调入一页，以保证分配给该进程的内存空间不变。</p><h5 id="可变分配全局置换"><a href="#可变分配全局置换" class="headerlink" title="可变分配全局置换"></a>可变分配全局置换</h5><p>先为系统中的每一进程分配一定数量的物理块，操作系统本身也保持一个空闲物理块队列。当某进程发生缺页时，由系统的空闲物理块队列中取出一物理块分配给该进程。但当空闲物理块队列中的物理块用完时，操作系统才从内存中选择一块调出。该块可能是系统中任意一个进程的页。</p><h5 id="可变分配局部置换"><a href="#可变分配局部置换" class="headerlink" title="可变分配局部置换"></a>可变分配局部置换</h5><p>为每一进程分配一定数目的内存空间。如果进程在运行的过程中，频繁地发生缺页中断，则系统再为该进程分配若干物理块，直到进程的缺页率降低到适当程度为止。</p><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>当主存空间已被装满而又需调入新页，就需要根据算法将已在主存中的一些页淘汰</p><ul><li>最优置换 OPT</li></ul><p>置换掉未来最久不被使用的页。但它需要页面访问序列的先验知识，是无法实现的。通常用于比较性研究。</p><ul><li>先进先出 FIFO</li></ul><p>置换最久的页。性能差，可能会出现 Belady 异常。<br>注：Belady 异常：随着分配的页框增多，缺页率反而上升。</p><ul><li>second chance</li></ul><p>如果被淘汰的页之前被访问过，则给其第二次机会。每个页面会增加一个访问标志位，用于标识此数据装入内存后是否被再次访问过。</p><ul><li> clock</li></ul><p>改进的 second chance。将数据组织成环形队列。</p><p>1）如果没有缺页错误，将所访问页的访问位置1，指针不动；</p><p>2）如果产生缺页错误：</p><p>如果当前页面的访问位是 1 ，首先将当前页面的访问位置0，将指针向前移一个位置；重复这个过程，直到找到访问位为0的页面，然后转下一步。</p><p>如果当前页面的访问位是 0 ，替换当前页面，并将其访问位置为1，并将指针向前移动一个位置。</p><h4 id="页面清除策略"><a href="#页面清除策略" class="headerlink" title="页面清除策略"></a>页面清除策略</h4><p>页面清除策略决定系统何时把被置换页面写回外存。<br>当正在执行的进程发生缺页中断时，需要阻塞，并等待一个页面的写出和另一个页面的读入，这可能降低处理机的使用效率。<br>一种有效的页面清除策略是结合<strong>页缓冲</strong>（<code>Page Buffering</code>）技术。当发生缺页中断时，不必首先写出置换页，而是将被选中的置换页暂时保留在内存的一个缓冲区，在以后某个合适的时候将被置换页批量写出到外存，减少磁盘I/0的次数，提高处理机的效率。</p><h5 id="最近最少使用-LRU"><a href="#最近最少使用-LRU" class="headerlink" title="最近最少使用 LRU"></a>最近最少使用 LRU</h5><p>是局部性原理的合理近似，性能接近 OPT，但需要记录页面使用的先后关系，实现开销大。</p><h5 id="工作集算法"><a href="#工作集算法" class="headerlink" title="工作集算法"></a>工作集算法</h5><p><strong>工作集</strong>：进程运行正在使用的页面的集合。它会逐渐稳定。</p><p><strong>驻留集</strong>：每个进程驻留在内存的页面集合。</p><p>本算法选择不在工作集中的页面进行替换。</p><h3 id="抖动问题"><a href="#抖动问题" class="headerlink" title="抖动问题"></a>抖动问题</h3><p>随着驻留内存的进程数目增加，即进程并发程度的提高，处理器利用率先上升，然后下降。<br>这里下降的原因通常称为虚拟存储器发生“抖动”，每个进程的驻留集不断减小，当驻留集小于工作集后，缺页率急剧上升，频繁调页使得调页开销增大。<br>因此，OS要选择一个适当的进程数目，以在并发水平和缺页率之间达到一个平衡。</p><h4 id="抖动的消除与预防"><a href="#抖动的消除与预防" class="headerlink" title="抖动的消除与预防"></a>抖动的消除与预防</h4><p><strong>局部置换策略：</strong>如果一个进程出现抖动，它不能从另外的进程那里夺取内存块，从而不会引发其他进程出现抖动，使抖动局限于一个小的范围内</p><p><strong>挂起若干进程：</strong>挂起一个或几个进程，以便腾出内存空间供抖动进程使用，从而消除抖动现象</p><p><strong>引入工作集算法</strong></p><p><strong>预留部分页面</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;地址空间&lt;/strong&gt;：一个进程能够用于访问内存的地址集合&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序&lt;/str</summary>
      
    
    
    
    <category term="OperatingSystem" scheme="http://yoursite.com/categories/OperatingSystem/"/>
    
    
    <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>「C++ 基础」类 &amp; 对象</title>
    <link href="http://yoursite.com/2021/05/01/cpp/1%20-%20%E7%B1%BB%20&amp;%20%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2021/05/01/cpp/1%20-%20%E7%B1%BB%20&amp;%20%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-05-01T01:00:15.000Z</published>
    <updated>2021-05-26T15:40:00.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类-amp-对象"><a href="#类-amp-对象" class="headerlink" title="类 &amp; 对象"></a>类 &amp; 对象</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><table><thead><tr><th align="left">概念</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">类成员函数</td><td align="left">类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。</td></tr><tr><td align="left">类访问修饰符</td><td align="left">类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。</td></tr><tr><td align="left">构造函数 &amp; 析构函数</td><td align="left">类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。</td></tr><tr><td align="left">C++ 拷贝构造函数</td><td align="left">拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。</td></tr><tr><td align="left">C++ 友元函数</td><td align="left"><strong>友元函数</strong>可以访问类的 private 和 protected 成员。</td></tr><tr><td align="left">C++ 内联函数</td><td align="left">通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。</td></tr><tr><td align="left">C++ 中的 this 指针</td><td align="left">每个对象都有一个特殊的指针 <strong>this</strong>，它指向对象本身。</td></tr><tr><td align="left">C++ 中指向类的指针</td><td align="left">指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。</td></tr><tr><td align="left">C++ 类的静态成员</td><td align="left">类的数据成员和函数成员都可以被声明为静态的。</td></tr></tbody></table><h2 id="与-struct-区别"><a href="#与-struct-区别" class="headerlink" title="与 struct 区别"></a>与 struct 区别</h2><ol><li>成员的默认访问权限不同 ：class 默认 private，struct 默认 public</li><li>class 可以用在模板中代替 typename，struct 不能。</li></ol><p>可以看到区别很小 ，c++保留 struct 更多是为了兼容 C。但是语义上一般倾向于把struct当作C时代的struct来用，即只有成员变量，没有逻辑（或只有极其简单的数据存入读取逻辑），用来把多个变量打包成一个类型，而不用struct来做面向对象编程意义上的class。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。</p><h2 id="类成员函数"><a href="#类成员函数" class="headerlink" title="类成员函数"></a>类成员函数</h2><p>成员函数可以定义在类定义内部，或者单独使用<strong>范围解析运算符</strong><code>::</code>来定义。在类定义中定义的成员函数把函数声明为内联的，即便没有使用 inline 标识符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="comment">//  ...</span></span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以在类的外部使用范围解析运算符<code>::</code>定义该函数，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">double</span> length;         <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;        <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> height;         <span class="comment">// 高度</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 成员函数声明</span></span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 成员函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Box::getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类访问修饰符"><a href="#类访问修饰符" class="headerlink" title="类访问修饰符"></a>类访问修饰符</h2><p>数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记 <strong>public、private、protected</strong> 来指定的。</p><p>每个标记区域在下一个标记区域开始之前都是有效的。成员和类的默认访问修饰符是 private。</p><h3 id="公有成员"><a href="#公有成员" class="headerlink" title="公有成员"></a>公有成员</h3><p><strong>公有</strong>成员在类的外部可访问。</p><h3 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h3><p><strong>私有</strong>成员变量或函数在类的外部不可访问，只有类和友元函数可以访问私有成员。 </p><h3 id="保护成员"><a href="#保护成员" class="headerlink" title="保护成员"></a>保护成员</h3><p><strong>保护</strong>成员变量或函数可被派生类中的任何成员函数访问。除此外和私有成员相同。</p><h2 id="类构造函数-amp-析构函数"><a href="#类构造函数-amp-析构函数" class="headerlink" title="类构造函数 &amp; 析构函数"></a>类构造函数 &amp; 析构函数</h2><p>类的<strong>构造函数</strong>是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。</p><p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">( <span class="keyword">double</span> len )</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">      <span class="built_in">Line</span>(<span class="keyword">double</span> len);  <span class="comment">// 这是构造函数</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Line::<span class="built_in">Line</span>( <span class="keyword">double</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Line <span class="title">line</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用初始化列表来初始化字段"><a href="#使用初始化列表来初始化字段" class="headerlink" title="使用初始化列表来初始化字段"></a>使用初始化列表来初始化字段</h3><p>假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化 ，可以：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C::<span class="built_in">C</span>( <span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c): <span class="built_in">X</span>(a), <span class="built_in">Y</span>(b), <span class="built_in">Z</span>(c)<span class="comment">// 最好要按照变量在类声明的顺序一致</span></span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复制控制"><a href="#复制控制" class="headerlink" title="复制控制"></a>复制控制</h2><p>除了成员函数、构造函数定义了类型的对象的操作，类还可以通过特殊的成员函数（复制构造函数、赋值操作符、析构函数）来控制<strong>复制</strong>、<strong>赋值</strong>或<strong>撤销</strong>该类型对象时会发生什么。</p><h3 id="类的析构函数"><a href="#类的析构函数" class="headerlink" title="类的析构函数"></a>类的析构函数</h3><p>类的<strong>析构函数</strong>会在每次删除所创建的对象时执行。当对象的引用或指针超出作用域时，不会运行析构函数。只有删除指向动态分配对象的指针或实际对象超出作用域时，才会执行析构函数。</p><p>一般而言，如果需要析构函数，那么也需要赋值操作符和复制构造函数。</p><p>析构函数的名称与类的名称相同，在前面加<code>~</code>作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">( <span class="keyword">double</span> len )</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">      <span class="built_in">Line</span>();   <span class="comment">// 这是构造函数声明</span></span><br><span class="line">      ~<span class="built_in">Line</span>();  <span class="comment">// 这是析构函数声明</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;</span><br><span class="line">&#125;;</span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being created&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Line::~<span class="built_in">Line</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>拷贝构造函数通常用于： </p><ul><li>通过使用另一个同类型的对象来初始化新创建的对象。</li><li>复制对象把它作为参数传递给函数。</li><li>复制对象，并从函数返回这个对象。</li></ul><p>编译器会默认定义拷贝构造函数。如果类带有指针变量，或者有动态内存分配，则它必须有一个拷贝构造函数。</p><p>因为默认的拷贝构造函数实现的是浅拷贝，即直接将原对象的数据成员值依次复制给新对象中对应的数据成员，并没有为新对象另外分配内存资源。这样，如果对象的数据成员是指针，两个指针对象实际上指向的是同一块内存空间，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。</p><p>所以我们就必须定义一个深拷贝构造函数，为新的对象分配单独的内存资源。</p><p>拷贝构造函数的最常见形式如下： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">classname</span> (<span class="keyword">const</span> classname &amp;obj) &#123;<span class="comment">// obj 是一个对象引用，该对象是用于初始化另一个对象的。</span></span><br><span class="line">   <span class="comment">// 构造函数的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        a = b;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;creat: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">const</span> CExample &amp;C)</span><br><span class="line">    &#123;</span><br><span class="line">        a = C.a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">CExample</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;delete: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数，传入的是对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_Fun</span><span class="params">(CExample C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CExample <span class="title">test</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//传入对象</span></span><br><span class="line">    <span class="built_in">g_Fun</span>(test);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何防止默认拷贝发生</strong></p><p>声明一个私有的拷贝构造函数，这样因为拷贝构造函数是私有的，如果用户试图按值传递或函数返回该类的对象，编译器会报告错误，从而可以避免按值传递或返回对象。</p><p>当出现类的等号赋值时，会调用拷贝函数</p><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>友元机制允许一个类将对其非公有成员的访问权授予指定函数或类。友元不是授予友元关系那个类的成员，所以它们不受其声明出现部分的访问控制影响。</p><p>友元可以是一个函数，该函数被称为友元函数；也可以是一个类，称为友元类，在这种情况下，整个类及其所有成员都是友元。</p><p>如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 <strong>friend</strong></p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> width;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printWidth</span><span class="params">(Box box)</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BigBox</span>;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">double</span> wid)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigBox</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> width, Box &amp;box)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// BigBox是Box的友元类，它可以直接访问Box类的任何成员</span></span><br><span class="line">        box.<span class="built_in">setWidth</span>(width);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注意：printWidth() 不是任何类的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printWidth</span><span class="params">(Box box)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Box box;</span><br><span class="line">    BigBox big;</span><br><span class="line">    <span class="comment">// 使用成员函数设置宽度</span></span><br><span class="line">    box.<span class="built_in">setWidth</span>(<span class="number">10.0</span>);</span><br><span class="line">    <span class="comment">// 使用友元函数输出宽度</span></span><br><span class="line">    <span class="built_in">printWidth</span>(box);</span><br><span class="line">    <span class="comment">// 使用友元类中的方法设置宽度</span></span><br><span class="line">    big.<span class="built_in">Print</span>(<span class="number">20</span>, box);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>友元声明将已命名的类或非成员函数引入外围作用域中。此外友元函数可以在类内部定义，该函数的作用域扩展到包围该类定义的作用域。</p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>由于一般调用函数需要许多工作：保存寄存器，复制实参，跳转到入口地址，返回时恢复寄存器等等。</p><p>内联函数可以避免函数调用时的开销。在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。函数名前面放置关键字 <strong>inline</strong>就可定义为内联函数。</p><p>对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。</p><p>一般而言，内联机制适用于优化比较小的、经常被调用的函数。绝大多数编译器不支持递归函数的内联。</p><p>在类定义中的定义的函数都是内联函数。</p><h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><p>每一个对象都能通过 <strong>this</strong> 指针来访问自己的地址。<strong>this</strong> 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">Volume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(Box box)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">Volume</span>() &gt; box.<span class="built_in">Volume</span>();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="指向类的指针"><a href="#指向类的指针" class="headerlink" title="指向类的指针"></a>指向类的指针</h2><p>一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 **<code>-&gt;</code>**，就像访问指向结构的指针一样。与所有的指针一样，必须在使用指针之前对指针进行初始化。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Box <span class="title">Box1</span><span class="params">(<span class="number">3.3</span>, <span class="number">1.2</span>, <span class="number">1.5</span>)</span></span>;    <span class="comment">// Declare box1</span></span><br><span class="line">   Box *ptrBox;                <span class="comment">// Declare pointer to a class.</span></span><br><span class="line">   ptrBox = &amp;Box1;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Volume of Box1: &quot;</span> &lt;&lt; ptrBox-&gt;<span class="built_in">Volume</span>() &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 <strong>::</strong> 来重新声明静态变量从而对它进行初始化 </p><p>静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义，实际上是给静态成员变量分配内存。如果不加定义就会报错，初始化是赋一个初始值，而定义是分配内存。 </p><ul><li>常量变量：必须通过构造函数参数列表进行初始化。</li><li>引用变量：必须通过构造函数参数列表进行初始化。</li><li>普通静态变量：要在类外通过”::”初始化。</li><li>静态整型常量：可以直接在定义的时候初始化。</li><li>静态非整型常量：不能直接在定义的时候初始化。要在类外通过”::”初始化。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span> objectCount;</span><br><span class="line">      <span class="built_in">Box</span>(<span class="keyword">double</span> l=<span class="number">2.0</span>, <span class="keyword">double</span> b=<span class="number">2.0</span>, <span class="keyword">double</span> h=<span class="number">2.0</span>) &#123;</span><br><span class="line">         objectCount++;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Box::objectCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，<strong>静态函数</strong>只要使用类名加范围解析运算符 <code>::</code> 就可以访问。 </p><p>静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。 </p><p>静态成员函数有一个类范围，他们不能访问类的 this 指针。可以使用静态成员函数来判断类的某些对象是否已被创建。 </p><p><strong>静态成员函数与普通成员函数的区别：</strong></p><ul><li>静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</li><li>普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类-amp-对象&quot;&gt;&lt;a href=&quot;#类-amp-对象&quot; class=&quot;headerlink&quot; title=&quot;类 &amp;amp; 对象&quot;&gt;&lt;/a&gt;类 &amp;amp; 对象&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="C++ 基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
    <category term="OOP" scheme="http://yoursite.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>「Algorithmic questions」动态规划</title>
    <link href="http://yoursite.com/2021/04/26/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E3%80%8CAlgorithmic%20questions%E3%80%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2021/04/26/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E3%80%8CAlgorithmic%20questions%E3%80%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-04-26T04:22:16.000Z</published>
    <updated>2021-07-10T14:20:35.909Z</updated>
    
    <content type="html"><![CDATA[<p>开个坑。感觉算法题还是要经常练保持手感，前段时间蓝桥杯，感觉大一时洛谷那么多题白刷了，那么多算法模板白总结了，都忘完了。做算法题还是要尽量自己多想，不思考看题解忘得太快。虽然最近比较忙，但每两天做一点应该还是可以的（吧）。希望不咕。</p><h1 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h1><h2 id="T198-House-Robber"><a href="#T198-House-Robber" class="headerlink" title="T198. House Robber"></a>T198. House Robber</h2><blockquote><p>假如你是一个劫匪，并且决定抢劫一条街上的房子，每个房子内的钱财数量各不相同。如果 你抢了两栋相邻的房子，则会触发警报机关。求在不触发机关的情况下最多可以抢劫多少钱。</p></blockquote><p>输入是一个一维数组，表示每个房子的钱财数量；输出是劫匪可以最多抢劫的钱财数量。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>很基础的dp，<code>dp[i]</code>表示前<code>i</code>个房子劫匪最多抢劫的数量，那么它有两种情况组成：一种是我们选择不抢劫这个房子，此时累计的金额即为 <code>dp[i-1]</code>；另一种是我们选择抢劫这个房子，那么此前累计的最大金额只能是 <code>dp[i-2]</code>。因此本题的状态转移方程为 <code>dp[i] = max(dp[i-1], nums[i-1] + dp[i-2])</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = nums.<span class="built_in">size</span>(); </span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-2</span>]+nums[i<span class="number">-1</span>], dp[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>当然由于递推到<code>dp[i]</code>时，本数组此前有用的值只有<code>dp[i-1]</code>与<code>dp[i-2]</code>，所以可以简单状态压缩：用三个变量来代替这三个数，节省空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(); </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">int</span> pre2 = <span class="number">0</span>, pre1 = <span class="number">0</span>, cur; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; </span><br><span class="line">        cur = <span class="built_in">max</span>(pre2 + nums[i], pre1); pre2 = pre1; pre1 = cur;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> cur; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T413-Arithmetic-Slices"><a href="#T413-Arithmetic-Slices" class="headerlink" title="T413. Arithmetic Slices"></a>T413. Arithmetic Slices</h2><blockquote><p>给定一个数组，求这个数组中连续且等差的子数组一共有多少个。</p></blockquote><p>输入是一个一维数组，输出是满足等差条件的连续字数组个数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4] </span><br><span class="line">Output: 3  &#x2F;&#x2F; 等差数列有 [1,2,3]、[2,3,4] 和 [1,2,3,4]</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>对于<code>[1,2,3,4]</code>，在尾部加一个5，那么原来以4结尾的等差数列，增加了一个元素，它们的数量不变。但同时会形成一个新的数列<code>[3,4,5]</code>。因此设<code>dp[i]</code>表示<strong>以<code>nums[i]</code>结尾的等差数列</strong>的个数。</p><p>递推关系：如果<code>A[i]-A[i-1] = A[i-1]-A[i-2]</code>，则<code>dp[i]=1+dp[i-1]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]-nums[i<span class="number">-1</span>] == nums[i<span class="number">-1</span>]-nums[i<span class="number">-2</span>]) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        ans += dp[i];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h1><h2 id="T64-Minimum-Path-Sum"><a href="#T64-Minimum-Path-Sum" class="headerlink" title="T64. Minimum Path Sum"></a>T64. Minimum Path Sum</h2><blockquote><p>给定一个m × n 大小的非负整数矩阵，求从左上角开始到右下角结束的、经过的数字的和最小的路径。每次只能向右或者向下移动。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3,1], [1,5,1], [4,2,1]] </span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>很基础的二维dp，思路很好想：<code>dp[i][j]</code>表示左上角开始到<code>(i,j)</code>处最小路径的数字和。那么状态转移方程为：</p><p><code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</code>。当然边界要特判一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">dp</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j] + grid[i][j], dp[i][j - <span class="number">1</span>] + grid[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间压缩：因为 dp 数组的值由左边和上边转移而来，对于第 i 行，在遍历到第 j 列的时候，因为第j-1列已经更新过了，所以<code>dp[j-1]</code>代表<code>dp[i][j-1] </code>的值；而 <code>dp[j]</code> 还未更新，此时的值是在第 i-1 行的时候计算的，因此可以代表 <code>dp[i-1][j]</code> 的值。这样就把dp数组压成一维的了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = grid[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = dp[j - <span class="number">1</span>] + grid[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = dp[j] + grid[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T542-01-Matrix"><a href="#T542-01-Matrix" class="headerlink" title="T542. 01 Matrix"></a>T542. 01 Matrix</h2><blockquote><p>给定一个由 0 和 1 组成的二维矩阵，求每个位置到最近的 0 的距离</p></blockquote><p>和上一题主要的区别在于本次矩阵需要四个方向的搜索，我们就不能简单由上方和左方矩阵转移而来。我们可以从左上到右下进行一次 dp ，再从右下到左上进行一次 dp 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3fffffff</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = INF;<span class="comment">// 注意 inf 的设置</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里开始不一样，需要和之前dp所得的成果相比，取最小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp; j == m - <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(INF, dp[i][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == m - <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], <span class="built_in">min</span>(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T221-Maximal-Square"><a href="#T221-Maximal-Square" class="headerlink" title="T221. Maximal Square"></a>T221. Maximal Square</h2><blockquote><p>给定一个二维的 0-1 矩阵，求全由 1 构成的最大正方形面积。</p></blockquote><h3 id="悬线法"><a href="#悬线法" class="headerlink" title="悬线法"></a>悬线法</h3><p>悬线法常用来求解这种给定矩阵中满足条件的最大子矩阵。</p><p>首先我们用<code>left[i][j]</code>表示从<code>(i,j)</code>能到达的最左位置，用<code>right[i][j]</code>表示从<code>(i,j)</code>能到达的最右位置，用<code>up[i][j]</code>表示从<code>(i,j)</code>向上扩展的最长长度。</p><p>那么这道题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(vector &lt;vector&lt;<span class="keyword">char</span>&gt;&gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">left</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">right</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">up</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="comment">// 能到达的最右和最左都初始化为自己开始的横坐标</span></span><br><span class="line">            left[i][j] = j;</span><br><span class="line">            right[i][j] = j;</span><br><span class="line">            up[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;<span class="comment">// 注意 j 是最作坊元素的右边元素位置，因为要递推</span></span><br><span class="line">            <span class="keyword">if</span> ((matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &amp;&amp; (matrix[i][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)) &#123;</span><br><span class="line">                left[i][j] = left[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123;<span class="comment">// 这里 j 类似</span></span><br><span class="line">            <span class="keyword">if</span> ((matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &amp;&amp; (matrix[i][j + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)) &#123;</span><br><span class="line">                right[i][j] = right[i][j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &amp;&amp; (matrix[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>)) &#123; <span class="comment">// i类似</span></span><br><span class="line">                left[i][j] = <span class="built_in">max</span>(left[i][j], left[i - <span class="number">1</span>][j]); </span><br><span class="line">                <span class="comment">// 上下的left取最靠右的，确保满足</span></span><br><span class="line">                right[i][j] = <span class="built_in">min</span>(right[i][j], right[i - <span class="number">1</span>][j]);</span><br><span class="line">                up[i][j] = up[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = right[i][j] - left[i][j] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> height = <span class="built_in">min</span>(len, up[i][j]);</span><br><span class="line">                area = <span class="built_in">max</span>(area, height * height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常规的-dp-转移"><a href="#常规的-dp-转移" class="headerlink" title="常规的 dp 转移"></a>常规的 dp 转移</h3><p><code>dp[i][j] </code>表示满足题目条件的、以 <code>(i, j)</code> 为右下角的正方形或者长方形的属性。对于本题，则表示以 <code>(i, j)</code> 为右下角的全由 1 构成的最大正方形边长。如果当前位置是 0，那么 <code>dp[i][j]</code> 即为 0；如果当前位置是 1，我们假设 $dp[i][j]=k$，其充分条件为 <code>dp[i-1][j-1]</code>、<code>dp[i][j-1]</code> 和 <code>dp[i-1][j]</code> 的值必须 都不小于$(k-1)$，否则 <code>(i, j)</code> 位置不可以构成一个边长为 k 的正方形。同理，如果这三个值中的 的最小值为 k − 1，则 <code>(i, j)</code> 位置一定且最大可以构成一个边长为 k 的正方形。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>(), max_side = <span class="number">0</span>; </span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>)); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123; </span><br><span class="line">            <span class="keyword">if</span> (matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123; </span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            max_side = <span class="built_in">max</span>(max_side, dp[i][j]); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> max_side * max_side;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h1><h2 id="T279-Perfect-Squares"><a href="#T279-Perfect-Squares" class="headerlink" title="T279. Perfect Squares"></a>T279. Perfect Squares</h2><blockquote><p>给定一个正整数，求其最少可以由几个完全平方数相加构成。</p></blockquote><p>dp[i] 表示数字 i 最少可以由几个完全平方数相加构成。那么它可以由 $i-k^2$的数加$k^2$得到，组成数+1。遍历一下可能的 k 即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT32_MAX)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T91-Decode-Ways"><a href="#T91-Decode-Ways" class="headerlink" title="T91. Decode Ways"></a>T91. Decode Ways</h2><blockquote><p>已知字母A-Z可以表示成数字 1-26。给定一个数字串，求有多少种不同的字符串等价于这个 数字串。</p></blockquote><p>eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;226&quot; </span><br><span class="line">Output: 3&#x2F;&#x2F; BZ(2 26)、VF(22 6) BBF(2 2 6)</span><br></pre></td></tr></table></figure><p>用<code>dp[i]</code>表示前 i 个数字可以等价于多少字符串。那么<code>s[0:i]</code>可以由<code>s[0:i-1]</code>加一个<code>1~9</code>的数字组成，也可以由<code>s[0:i-2]</code>加一个<code>10~26</code>的数字组成，注意 01 并不代表一个字符。</p><p>注意多考虑一些特殊情况就好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = s[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">10</span> * (s[i - <span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>) + num1;</span><br><span class="line">        <span class="keyword">if</span> (num1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt; num2 &amp;&amp; num2 &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">2</span>];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt; num2 &amp;&amp; num2 &lt;= <span class="number">26</span> &amp;&amp; s[i - <span class="number">2</span>] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T139-Word-Break"><a href="#T139-Word-Break" class="headerlink" title="T139. Word Break"></a>T139. Word Break</h2><blockquote><p>给定一个字符串和一个字符串集合，求是否存在一种分割方式，使得原字符串分割后的子字符串都可以在集合内找到。</p></blockquote><p>eg:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = <span class="string">&quot;applepenapple&quot;</span>, wordDict = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pen&quot;</span>] </span><br><span class="line">Output: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在考虑每个分割位置时，遍历一下字符串集合，以确定当前位置是否可以成功分割。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt; &amp;wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(len + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> string &amp;word: wordDict) &#123;</span><br><span class="line">            <span class="keyword">int</span> wordLen = word.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">if</span> (i - wordLen &gt;= <span class="number">0</span> </span><br><span class="line">                &amp;&amp; (s.<span class="built_in">substr</span>(<span class="number">0</span>, i - wordLen) + word == s.<span class="built_in">substr</span>(<span class="number">0</span>, i))) &#123;</span><br><span class="line">                dp[i] = dp[i] || dp[i - wordLen];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="子序列"><a href="#子序列" class="headerlink" title="子序列"></a>子序列</h1><h2 id="T300-Longest-Increasing-Subsequence"><a href="#T300-Longest-Increasing-Subsequence" class="headerlink" title="T300. Longest Increasing Subsequence"></a>T300. Longest Increasing Subsequence</h2><blockquote><p>给定一个未排序的整数数组，求最长的递增子序列。</p></blockquote><p><code>dp[i]</code>表示以index为i处数字结尾的最长子序列长度。</p><p>$O(n^2)$解法很好想：遍历i之前所有加上i处的数还是递增的序列，找到长度最大的一个就好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用二分查找将时间复杂度降低为$O(n log n)$。我们定义一个dp数组，其中 dp[k]<br>存储长度为 k+1 的最长递增子序列的最后一个数字。我们遍历每一个位置 i，如果其对应的数字 大于 dp 数组中所有数字的值，那么我们把它放在 dp 数组尾部，表示最长递增子序列长度加 1； 如果我们发现这个数字在 dp 数组中比数字 a 大、比数字 b 小，则我们将 b 更新为此数字，使得之后构成递增序列的可能性增大（贪心的思想）。以这种方式维护的 dp 数组永远是递增的，因此可以用二分查找加速搜索。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">    dp.<span class="built_in">push_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp.<span class="built_in">back</span>() &lt; nums[i]) &#123;</span><br><span class="line">            dp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// lower_bound 返回一个指针，想获得数组下标要 -dp</span></span><br><span class="line">            <span class="keyword">auto</span> itr = <span class="built_in">lower_bound</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), nums[i]);</span><br><span class="line">            *itr = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T1143-Longest-Commom-Subsequence"><a href="#T1143-Longest-Commom-Subsequence" class="headerlink" title="T1143. Longest Commom Subsequence"></a>T1143. Longest Commom Subsequence</h2><blockquote><p>给定两个字符串，求它们最长的公共子序列长度</p></blockquote><p><code>dp[i][j]</code>表示到第一个字符串位置 i 为止、到第二个字符串位置 j 为止、最长的公共子序列长度。让 i 和 j 从 1 开始能避免繁琐的临界判断。</p><p>状态转移方程，画个图看看规律就懂了。由于没重复扫描，也不用和自身比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = text1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> len2 = text2.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(len1 + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(len2 + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 &amp;&amp; 空间复杂度：$O(MN)$</p><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p>有 N 个物品和容量为W 的背包，每个物品都有自己的体积w和价值 v，求拿哪些物品可以使得背包所装下物品的总价值最大。如果限定每种物品只能选择 0 个或 1 个，则问题称为 0-1 背包问题；如果不限定每种物品的数量，则问题称为无界背包问题或完全背包问题。</p><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><p><code>dp[i][j]</code> 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。在我们遍历到第 i 件物品时，在当前背包总容量为 j 的情况下，如果我们不将物品 i 放入背包，那么 <code>dp[i][j]</code> = <code>dp[i-1][j]</code>，即前 i 个物品的最大价值等于只取前 i-1 个物品时的最大价值；如果我们将物品 i 放 入背包，假设第 i 件物品体积为w，价值为 v，那么我们得到 <code>dp[i][j]</code> = <code>dp[i-1][j-w]</code> + v。我们只需 在遍历过程中对这两种情况取最大值即可，总时间复杂度和空间复杂度都为<code>O(NW)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; weights, vector&lt;<span class="keyword">int</span>&gt; values, <span class="keyword">int</span> N, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; dp(N + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = weights[i - <span class="number">1</span>], v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= W; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w] + v);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; dp[i][j] = dp[i - <span class="number">1</span>][j]; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间压缩：$O(W)$</p><p>遍历weight的时候必须逆向遍历，若按照从左往右的顺序进行正向遍历，则 <code>dp[j-w]</code> 的值在遍历到 j 之前就已经被更新成物品 i 的值了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; weights, vector&lt;<span class="keyword">int</span>&gt; values, <span class="keyword">int</span> N, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = weights[i - <span class="number">1</span>], v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = W; j &gt;= w; --j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w] + v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>在完全背包问题中，一个物品可以拿多次。假设我们遍历到物品 i = 2，且其体积为w = 2，价值为 v = 3；对于背包容量 j = 5，最多只能装下 2 个该物品。那么我们的状 态转移方程就变成了 <code>dp[2][5] = max(dp[1][5], dp[1][3] + 3, dp[1][1] + 6)</code>。如果采用这种方法，假设背包容量无穷大而物体的体积无穷小，我们这里的比较次数也会趋近于无穷大，远超 O(NW) 的 时间复杂度。 怎么解决这个问题呢？我们发现在 <code>dp[2][3]</code> 的时候我们其实已经考虑了 <code>dp[1][3]</code> 和 <code>dp[2][1]</code>的情况，而在时 <code>dp[2][1]</code> 也已经考虑了 <code>dp[1][1]</code> 的情况。因此，如图下半部分所示，对于拿多个 物品的情况，我们只需考虑 <code>dp[2][3]</code> 即可，即 <code>dp[2][5] = max(dp[1][5], dp[2][3] + 3)</code>。这样，我们就得到了完全背包问题的状态转移方程：<code>dp[i][j] = max(dp[i-1][j], dp[i][j-w] + v)</code>，其与 0-1 背包问 题的差别仅仅是把状态转移方程中的第二个 i-1 变成了 i</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; weights, vector&lt;<span class="keyword">int</span>&gt; values, <span class="keyword">int</span> N, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = weights[i - <span class="number">1</span>], v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= W; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - w] + v);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; dp[i][j] = dp[i - <span class="number">1</span>][j]; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间压缩：$O(W)$</p><p>遍历weight的时候必须正向遍历，因为我们需要利用当前物品在第 j-w 列的信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; weights, vector&lt;<span class="keyword">int</span>&gt; values, <span class="keyword">int</span> N, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = weights[i - <span class="number">1</span>], v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = w; j &lt;= W; ++j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w] + v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T474-Ones-and-Zeroes"><a href="#T474-Ones-and-Zeroes" class="headerlink" title="T474. Ones and Zeroes"></a>T474. Ones and Zeroes</h2><blockquote><p>给定m 个数字 0 和 n 个数字 1，以及一些由 0-1 构成的字符串，求利用这些数字最多可以构成多少个给定的字符串，字符串只可以构成一次。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: Array &#x3D; &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m &#x3D; 5, n &#x3D; 3 </span><br><span class="line">Output: 4</span><br><span class="line">在这个样例中，我们可以用 5 个 0 和 3 个 1 构成 [“10”, “0001”, “1”, “0”]。</span><br></pre></td></tr></table></figure><p>我们这么想，所有的字符串可以看作物品，现在要往背包里面装，背包体积限制为（5，3），每成功装进背包一个字符串，背包总价值就+1。现在求的就是背包的最大总价值。因此这实际上是一个和0-1背包，只不过物品扩展到了两维度。</p><p><code>dp[i][j][k]</code> 表示前 i 件物品 0 的数量不超过 j ，1的数量不超过 k 的情况下能达到的最大价值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt; &amp;strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = strs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> dp[N + <span class="number">1</span>][m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">int</span> count_zero[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; strs[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[i][j] == <span class="string">&#x27;0&#x27;</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        count_zero[i] = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> wei_zero = count_zero[i - <span class="number">1</span>], wei_one = strs[i - <span class="number">1</span>].<span class="built_in">size</span>() - count_zero[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= wei_zero &amp;&amp; k &gt;= wei_one) &#123;</span><br><span class="line">                    dp[i][j][k] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j][k], dp[i - <span class="number">1</span>][j - wei_zero][k - wei_one] + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j][k] = dp[i - <span class="number">1</span>][j][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T322-Coin-Change"><a href="#T322-Coin-Change" class="headerlink" title="T322. Coin Change"></a>T322. Coin Change</h2><blockquote><p>给定一些硬币的面额，求最少可以用多少颗硬币组成给定的金额。若不存在解，则返回-1</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: coins &#x3D; [1, 2, 5], amount &#x3D; 11 </span><br><span class="line">Output: 3</span><br><span class="line">最少的组合方法是 11 &#x3D; 5 + 5 + 1。</span><br></pre></td></tr></table></figure><p>完全背包。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = coins.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> MAX = amount + <span class="number">2</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, MAX)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> wei = coins[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = wei; j &lt;= amount; j++) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">min</span>(dp[j], dp[j - wei] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == MAX ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串编辑"><a href="#字符串编辑" class="headerlink" title="字符串编辑"></a>字符串编辑</h1><blockquote><p>给定两个字符串，已知你可以删除、替换和插入任意字符串的任意字符，求最少编辑几步可 以将两个字符串变成相同。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure><ul><li>Q：如果 <code>word1[0:i-1]</code> 到 <code>word2[0:j-1]</code> 的变换需要消耗 k 步，那<code>word1[0:i]</code>到 <code>word2[0:j]</code> 的变换需要几步呢？</li></ul><p>A：先使用 k 步，把 word1[0..i-1] 变换到 word2[0..j-1]，消耗 k 步。再把 word1[i] 改成 word2[j]，就行了。如果 word1[i] == word2[j]，什么也不用做，一共消耗 k 步，否则需要修改，一共消耗 k + 1 步。</p><ul><li>Q：如果 word1[0..i-1] 到 word2[0..j] 的变换需要消耗 k 步，那 word1[0..i] 到 word2[0..j] 的变换需要消耗几步呢？</li></ul><p>A：先经过 k 步，把 word1[0..i-1] 变换到 word2[0..j]，消耗掉 k 步，再把 word1[i] 删除，这样，word1[0..i] 就完全变成了 word2[0..j] 了。一共 k + 1 步。</p><ul><li>Q：如果 word1[0..i] 到 word2[0..j-1] 的变换需要消耗 k 步，那 word1[0..i] 到 word2[0..j] 的变换需要消耗几步呢？</li></ul><p>A：先经过 k 步，把 word1[0..i] 变换成 word2[0..j-1]，消耗掉 k 步，接下来，再插入一个字符 word2[j], word1[0..i] 就完全变成了 word2[0..j] 了。</p><p>综上，word1[0..i] 变换成 word2[0..j] 主要有三种手段，用哪个消耗少，就用哪个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = word1.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">int</span> n = word2.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">cost</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        cost[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        cost[<span class="number">0</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                cost[i][j] = cost[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cost[i][j] = <span class="number">1</span> + <span class="built_in">min</span>(cost[i - <span class="number">1</span>][j - <span class="number">1</span>], <span class="built_in">min</span>(cost[i][j - <span class="number">1</span>], cost[i - <span class="number">1</span>][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cost[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开个坑。感觉算法题还是要经常练保持手感，前段时间蓝桥杯，感觉大一时洛谷那么多题白刷了，那么多算法模板白总结了，都忘完了。做算法题还是要尽量自己多想，不思考看题解忘得太快。虽然最近比较忙，但每两天做一点应该还是可以的（吧）。希望不咕。&lt;/p&gt;
&lt;h1 id=&quot;一维&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Algorithm problems" scheme="http://yoursite.com/categories/Algorithm-problems/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="algorithmic questions" scheme="http://yoursite.com/tags/algorithmic-questions/"/>
    
    <category term="dp" scheme="http://yoursite.com/tags/dp/"/>
    
  </entry>
  
</feed>
